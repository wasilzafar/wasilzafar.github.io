<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 12: Synchronization & Coordination - Learn about locks, mutexes, semaphores, condition variables, and classic synchronization problems." />
    <meta name="keywords" content="synchronization, locks, mutexes, semaphores, condition variables, producer consumer, readers writers, dining philosophers, critical section" />
    
    <meta property="og:title" content="Part 12: Synchronization & Coordination | Computer Architecture & OS Mastery" />
    <meta property="og:description" content="Master synchronization primitives: locks, semaphores, condition variables, and classic problems." />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://wasilzafar.com/pages/series/computer-architecture/comp-arch-synchronization.html" />
    <meta property="article:published_time" content="2026-01-31" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />

    <title>Part 12: Synchronization & Coordination | Computer Architecture & OS Mastery - Wasil Zafar</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', { 'ad_storage': 'denied', 'ad_user_data': 'denied', 'ad_personalization': 'denied', 'analytics_storage': 'denied', 'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE'] });
        gtag('consent', 'default', { 'ad_storage': 'granted', 'ad_user_data': 'granted', 'ad_personalization': 'granted', 'analytics_storage': 'granted' });
        gtag('set', 'url_passthrough', true);
    </script>
    <script>
        (function(w, d, s, l, i) { w[l] = w[l] || []; w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'}); var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f); })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>
</head>
<body>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <section class="blog-hero">
        <div class="container py-5">
            <a href="../../categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
            <h1 class="display-4 fw-bold mt-4">Part 12: Synchronization & Coordination</h1>
            <div class="blog-meta">
                <span><i class="fas fa-calendar me-2"></i>January 31, 2026</span>
                <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                <span class="reading-time"><i class="fas fa-clock me-1"></i>30 min read</span>
                <button onclick="window.print()" class="print-btn" title="Print this article"><i class="fas fa-print"></i> Print</button>
            </div>
            <p class="lead mt-3">Master synchronization primitives—locks, semaphores, and condition variables—and solve classic coordination problems.</p>
        </div>
    </section>

    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents"><i class="fas fa-list"></i></button>

    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li><a href="#introduction" onclick="closeNav()">Introduction</a></li>
            <li><a href="#critical-section" onclick="closeNav()">Critical Section Problem</a></li>
            <li><a href="#locks" onclick="closeNav()">Locks & Mutexes</a></li>
            <li><a href="#semaphores" onclick="closeNav()">Semaphores</a></li>
            <li><a href="#condition-variables" onclick="closeNav()">Condition Variables</a></li>
            <li><a href="#producer-consumer" onclick="closeNav()">Producer-Consumer Problem</a></li>
            <li><a href="#readers-writers" onclick="closeNav()">Readers-Writers Problem</a></li>
            <li><a href="#dining-philosophers" onclick="closeNav()">Dining Philosophers</a></li>
            <li><a href="#conclusion" onclick="closeNav()">Conclusion & Next Steps</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-lock me-2 text-teal"></i>Introduction</h2>
                    <p>Synchronization ensures that concurrent processes or threads access shared resources safely. Without proper synchronization, race conditions lead to unpredictable behavior and data corruption.</p>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-sitemap me-2"></i>
                        <strong>Series Context:</strong> This is <strong>Part 12 of 24</strong> in the Computer Architecture & Operating Systems Mastery series. Building on CPU scheduling, we now explore how to coordinate concurrent execution safely.
                    </div>

                    <div class="experiment-card" id="series-nav">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">24-Part Series</span>
                            <span class="badge bg-crimson">Computer Architecture & OS Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="comp-arch-foundations.html"><strong>Part 1:</strong> Foundations of Computer Systems</a> — System overview, architectures, OS role</li>
                                <li><a href="comp-arch-digital-logic.html"><strong>Part 2:</strong> Digital Logic & CPU Building Blocks</a> — Gates, registers, datapath, microarchitecture</li>
                                <li><a href="comp-arch-isa.html"><strong>Part 3:</strong> Instruction Set Architecture (ISA)</a> — RISC vs CISC, instruction formats, addressing</li>
                                <li><a href="comp-arch-assembly.html"><strong>Part 4:</strong> Assembly Language & Machine Code</a> — Registers, stack, calling conventions</li>
                                <li><a href="comp-arch-linkers-loaders.html"><strong>Part 5:</strong> Assemblers, Linkers & Loaders</a> — Object files, ELF, dynamic linking</li>
                                <li><a href="comp-arch-compilers.html"><strong>Part 6:</strong> Compilers & Program Translation</a> — Lexing, parsing, code generation</li>
                                <li><a href="comp-arch-cpu-pipelining.html"><strong>Part 7:</strong> CPU Execution & Pipelining</a> — Fetch-decode-execute, hazards, prediction</li>
                                <li><a href="comp-arch-os-kernel.html"><strong>Part 8:</strong> OS Architecture & Kernel Design</a> — Monolithic, microkernel, system calls</li>
                                <li><a href="comp-arch-processes.html"><strong>Part 9:</strong> Processes & Program Execution</a> — Process lifecycle, PCB, fork/exec</li>
                                <li><a href="comp-arch-threads-concurrency.html"><strong>Part 10:</strong> Threads & Concurrency</a> — Threading models, pthreads, race conditions</li>
                                <li><a href="comp-arch-cpu-scheduling.html"><strong>Part 11:</strong> CPU Scheduling Algorithms</a> — FCFS, RR, CFS, real-time scheduling</li>
                                <li><strong>Part 12: Synchronization & Coordination (This Guide)</strong> — Locks, semaphores, classic problems</li>
                                <li><a href="comp-arch-deadlocks.html"><strong>Part 13:</strong> Deadlocks & Prevention</a> — Coffman conditions, Banker's algorithm</li>
                                <li><a href="comp-arch-cache-memory-hierarchy.html"><strong>Part 14:</strong> Memory Hierarchy & Cache</a> — L1/L2/L3, cache coherence, NUMA</li>
                                <li><a href="comp-arch-memory-management.html"><strong>Part 15:</strong> Memory Management Fundamentals</a> — Address spaces, fragmentation, allocation</li>
                                <li><a href="comp-arch-virtual-memory.html"><strong>Part 16:</strong> Virtual Memory & Paging</a> — Page tables, TLB, demand paging</li>
                                <li><a href="comp-arch-file-systems.html"><strong>Part 17:</strong> File Systems & Storage</a> — Inodes, journaling, ext4, NTFS</li>
                                <li><a href="comp-arch-io-devices.html"><strong>Part 18:</strong> I/O Systems & Device Drivers</a> — Interrupts, DMA, disk scheduling</li>
                                <li><a href="comp-arch-multiprocessor.html"><strong>Part 19:</strong> Multiprocessor Systems</a> — SMP, NUMA, cache coherence</li>
                                <li><a href="comp-arch-security.html"><strong>Part 20:</strong> OS Security & Protection</a> — Privilege levels, ASLR, sandboxing</li>
                                <li><a href="comp-arch-virtualization.html"><strong>Part 21:</strong> Virtualization & Containers</a> — Hypervisors, namespaces, cgroups</li>
                                <li><a href="comp-arch-kernel-internals.html"><strong>Part 22:</strong> Advanced Kernel Internals</a> — Linux subsystems, kernel debugging</li>
                                <li><a href="comp-arch-case-studies.html"><strong>Part 23:</strong> Case Studies</a> — Linux vs Windows vs macOS</li>
                                <li><a href="comp-arch-capstone-projects.html"><strong>Part 24:</strong> Capstone Projects</a> — Shell, thread pool, paging simulator</li>
                            </ol>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-question-circle me-2"></i>
                        <strong>The Coordination Challenge:</strong> When multiple threads access shared data, how do we prevent corruption? Synchronization primitives like locks, semaphores, and condition variables provide the answer.
                    </div>
                </div>

                <div id="critical-section" class="blog-content mt-5">
                    <h2><i class="fas fa-exclamation-triangle me-2 text-teal"></i>Critical Section Problem</h2>
                    
                    <p>A <strong>critical section</strong> is code that accesses shared resources. Only one thread should execute a critical section at a time.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-shield-alt me-2"></i>Critical Section Requirements</h4>
                        <div class="content">
<pre class="language-text"><code>Critical Section Problem:
══════════════════════════════════════════════════════════════

Thread A                     Thread B
━━━━━━━━━━━━━━━━━━━━━━━━━   ━━━━━━━━━━━━━━━━━━━━━━━━━
Entry Section                Entry Section
┌─────────────────────┐      ┌─────────────────────┐
│ Critical Section    │      │ Critical Section    │
│ (access shared data)│  ✗   │ (access shared data)│
└─────────────────────┘      └─────────────────────┘
Exit Section                 Exit Section
Remainder Section            Remainder Section

Only ONE thread in critical section at a time!


Three Requirements for a Solution:
══════════════════════════════════════════════════════════════

1. MUTUAL EXCLUSION
   • If one thread is in critical section, no other can enter
   • Prevents simultaneous access

2. PROGRESS
   • If no thread is in critical section, a waiting thread
     must be able to enter (no indefinite blocking)
   • Selection cannot be postponed indefinitely

3. BOUNDED WAITING
   • A thread cannot wait forever to enter
   • Limit on how many times others can go first
   • Prevents starvation</code></pre>
                        </div>
                    </div>

<pre class="language-c"><code>/* Peterson's Algorithm - Software-Only Solution */
/* Works for TWO threads only */

int flag[2] = {0, 0};  /* flag[i] = 1: thread i wants to enter */
int turn;              /* Whose turn if both want to enter */

void enter_critical_section(int i) {
    int j = 1 - i;     /* The other thread */
    flag[i] = 1;       /* I want to enter */
    turn = j;          /* But I'll let you go first */
    
    /* Wait if other wants to enter AND it's their turn */
    while (flag[j] && turn == j) {
        /* Busy wait (spin) */
    }
}

void exit_critical_section(int i) {
    flag[i] = 0;       /* I'm done, don't want to enter */
}

/* Usage */
void thread_0() {
    enter_critical_section(0);
    /* ... critical section ... */
    exit_critical_section(0);
}

void thread_1() {
    enter_critical_section(1);
    /* ... critical section ... */
    exit_critical_section(1);
}</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Modern CPUs Break Peterson's!</strong> Memory reordering can break software-only solutions. Modern systems need hardware support (atomic instructions) or memory barriers.
                    </div>
                </div>

                <div id="locks" class="blog-content mt-5">
                    <h2><i class="fas fa-lock me-2 text-teal"></i>Locks & Mutexes</h2>
                    
                    <p>A <strong>mutex (mutual exclusion lock)</strong> is the fundamental synchronization primitive. Only one thread can hold the lock at a time.</p>

<pre class="language-text"><code>Mutex Operations:
══════════════════════════════════════════════════════════════

lock()   - Acquire the mutex (block if already held)
unlock() - Release the mutex (allow another thread to acquire)

Thread A              Mutex State         Thread B
━━━━━━━━━━━━━━━━━    ━━━━━━━━━━━━━━     ━━━━━━━━━━━━━━━━
lock()              [LOCKED by A]
                                         lock() → BLOCKED
... critical ...
                    
unlock()            [UNLOCKED]           → WAKES UP
                    [LOCKED by B]        ... critical ...
                                         unlock()


Hardware Support: Atomic Instructions
══════════════════════════════════════════════════════════════
Test-And-Set (TAS):
   Atomically: read old value, write 1, return old value

Compare-And-Swap (CAS):
   Atomically: if (value == expected) { value = new; return true; }
               else { return false; }

x86 Examples:
   LOCK XCHG - atomic exchange
   LOCK CMPXCHG - compare and exchange</code></pre>

                    <div class="experiment-card">
                        <h4><i class="fas fa-code me-2"></i>Spinlock Implementation</h4>
                        <div class="content">
<pre class="language-c"><code>/* Simple Spinlock using atomic test-and-set */
#include &lt;stdatomic.h&gt;

typedef struct {
    atomic_flag locked;
} spinlock_t;

void spinlock_init(spinlock_t *lock) {
    atomic_flag_clear(&amp;lock-&gt;locked);
}

void spinlock_acquire(spinlock_t *lock) {
    /* Keep trying until we get the lock */
    while (atomic_flag_test_and_set(&amp;lock-&gt;locked)) {
        /* Spin - wastes CPU cycles */
        /* Better: add pause instruction for hyperthreading */
        __builtin_ia32_pause();
    }
}

void spinlock_release(spinlock_t *lock) {
    atomic_flag_clear(&amp;lock-&gt;locked);
}</code></pre>
                        </div>
                    </div>

<pre class="language-c"><code>/* POSIX Mutex (pthread_mutex) - Proper blocking mutex */
#include &lt;pthread.h&gt;

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int shared_counter = 0;

void* increment_thread(void* arg) {
    for (int i = 0; i &lt; 1000000; i++) {
        pthread_mutex_lock(&amp;mutex);      /* Acquire */
        shared_counter++;                 /* Critical section */
        pthread_mutex_unlock(&amp;mutex);    /* Release */
    }
    return NULL;
}

/* Spinlock vs Mutex:
 * - Spinlock: Busy waits, good for VERY short critical sections
 * - Mutex: Blocks thread, good for longer critical sections
 * - Rule: If hold time &lt; context switch time, use spinlock
 */</code></pre>
                </div>

                <div id="semaphores" class="blog-content mt-5">
                    <h2><i class="fas fa-traffic-light me-2 text-teal"></i>Semaphores</h2>
                    
                    <p>A <strong>semaphore</strong> is a counter that controls access. Unlike mutexes, semaphores can allow multiple threads (up to N) to access a resource.</p>

<pre class="language-text"><code>Semaphore Operations (Dijkstra's notation):
══════════════════════════════════════════════════════════════

P(S) or wait(S):     S--; if (S &lt; 0) block();
V(S) or signal(S):   S++; if (S &lt;= 0) wake_one_waiting();

(P = "proberen" = try, V = "verhogen" = increase in Dutch)


Types of Semaphores:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Binary Semaphore (0 or 1):
   • Same as mutex
   • init(1): one at a time

Counting Semaphore (0 to N):
   • init(N): up to N concurrent accesses
   • Example: Connection pool with 10 connections


Example: Parking Lot with 5 Spaces
══════════════════════════════════════════════════════════════
semaphore spaces = 5;  /* Initialize to capacity */

car_enter():
    wait(spaces);      /* Decrement, block if 0 */
    /* Enter and park */

car_leave():
    /* Leave parking space */
    signal(spaces);    /* Increment, wake waiting car */

State transitions:
spaces: 5 → 4 → 3 → 2 → 1 → 0 [FULL - cars block]
        ↑
car leaves: signal() increments, wakes waiting car</code></pre>

                    <div class="experiment-card">
                        <h4><i class="fas fa-code me-2"></i>POSIX Semaphores in C</h4>
                        <div class="content">
<pre class="language-c"><code>#include &lt;semaphore.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

#define MAX_CONCURRENT 3

sem_t resource_sem;

void* worker(void* arg) {
    int id = *(int*)arg;
    
    printf("Worker %d: Waiting for resource...\n", id);
    sem_wait(&amp;resource_sem);  /* P() - decrement or block */
    
    printf("Worker %d: Acquired resource!\n", id);
    sleep(2);  /* Use resource */
    
    printf("Worker %d: Releasing resource.\n", id);
    sem_post(&amp;resource_sem);  /* V() - increment */
    
    return NULL;
}

int main() {
    pthread_t threads[10];
    int ids[10];
    
    sem_init(&amp;resource_sem, 0, MAX_CONCURRENT);
    
    for (int i = 0; i &lt; 10; i++) {
        ids[i] = i;
        pthread_create(&amp;threads[i], NULL, worker, &amp;ids[i]);
    }
    
    for (int i = 0; i &lt; 10; i++) {
        pthread_join(threads[i], NULL);
    }
    
    sem_destroy(&amp;resource_sem);
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>

                <div id="condition-variables" class="blog-content mt-5">
                    <h2><i class="fas fa-bell me-2 text-teal"></i>Condition Variables</h2>
                    
                    <p><strong>Condition variables</strong> let threads wait for a specific condition to become true. Always used with a mutex to protect the condition.</p>

<pre class="language-text"><code>Condition Variable Operations:
══════════════════════════════════════════════════════════════

wait(cv, mutex):
   1. Atomically release mutex and sleep
   2. When woken, re-acquire mutex before returning

signal(cv):      Wake ONE waiting thread
broadcast(cv):   Wake ALL waiting threads


Why needed? Avoid busy-waiting:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
BAD (busy wait):
while (!condition) {
    /* Spin, wasting CPU */
}

GOOD (condition variable):
pthread_mutex_lock(&amp;mutex);
while (!condition) {
    pthread_cond_wait(&amp;cv, &amp;mutex);  /* Sleep until signaled */
}
/* condition is now true */
pthread_mutex_unlock(&amp;mutex);</code></pre>

<pre class="language-c"><code>/* Condition Variable Example: Bounded Buffer */
#include &lt;pthread.h&gt;

#define BUFFER_SIZE 10
int buffer[BUFFER_SIZE];
int count = 0;

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t not_full = PTHREAD_COND_INITIALIZER;
pthread_cond_t not_empty = PTHREAD_COND_INITIALIZER;

void produce(int item) {
    pthread_mutex_lock(&amp;mutex);
    
    while (count == BUFFER_SIZE) {
        /* Buffer full - wait for consumer */
        pthread_cond_wait(&amp;not_full, &amp;mutex);
    }
    
    buffer[count++] = item;
    
    /* Signal consumer that buffer has data */
    pthread_cond_signal(&amp;not_empty);
    pthread_mutex_unlock(&amp;mutex);
}

int consume() {
    pthread_mutex_lock(&amp;mutex);
    
    while (count == 0) {
        /* Buffer empty - wait for producer */
        pthread_cond_wait(&amp;not_empty, &amp;mutex);
    }
    
    int item = buffer[--count];
    
    /* Signal producer that buffer has space */
    pthread_cond_signal(&amp;not_full);
    pthread_mutex_unlock(&amp;mutex);
    
    return item;
}</code></pre>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Always Use While, Not If:</strong> Spurious wakeups can occur—threads may wake without a signal. Using <code>while</code> ensures the condition is re-checked after waking.
                    </div>
                </div>

                <div id="producer-consumer" class="blog-content mt-5">
                    <h2><i class="fas fa-exchange-alt me-2 text-teal"></i>Producer-Consumer Problem</h2>
                    
                    <p>The classic synchronization problem: producers add items to a bounded buffer, consumers remove items. Must synchronize to prevent overflow and underflow.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-box me-2"></i>Producer-Consumer with Semaphores</h4>
                        <div class="content">
<pre class="language-text"><code>Producer-Consumer Problem:
══════════════════════════════════════════════════════════════

┌──────────┐    ┌─────────────────────┐    ┌──────────┐
│ PRODUCER │ ─→ │  BOUNDED BUFFER     │ ─→ │ CONSUMER │
│          │    │  [■][■][■][ ][ ]    │    │          │
└──────────┘    │   ↑ items    ↑ empty │    └──────────┘
                └─────────────────────┘

Synchronization needs:
1. Mutual exclusion on buffer access
2. Block producer when buffer full
3. Block consumer when buffer empty


Semaphore Solution:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
semaphore mutex = 1;        /* Mutual exclusion */
semaphore empty = N;        /* Empty slots (start: all empty) */
semaphore full = 0;         /* Full slots (start: none full) */

PRODUCER:                   CONSUMER:
━━━━━━━━━━━━━━━━━━━━━━━━   ━━━━━━━━━━━━━━━━━━━━━━━━━━
while (true) {              while (true) {
    item = produce();           wait(full);      /* ① */
    wait(empty);    /* ① */     wait(mutex);     /* ② */
    wait(mutex);    /* ② */     item = buffer.remove();
    buffer.add(item);           signal(mutex);   /* ③ */
    signal(mutex);  /* ③ */     signal(empty);   /* ④ */
    signal(full);   /* ④ */     consume(item);
}                           }

Order matters! wait(mutex) THEN wait(empty) → DEADLOCK!</code></pre>
                        </div>
                    </div>

<pre class="language-c"><code>/* Complete Producer-Consumer Implementation */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;unistd.h&gt;

#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE];
int in = 0, out = 0;

sem_t mutex, empty_slots, full_slots;

void* producer(void* arg) {
    int id = *(int*)arg;
    for (int i = 0; i &lt; 10; i++) {
        int item = rand() % 100;
        
        sem_wait(&amp;empty_slots);    /* Wait for empty slot */
        sem_wait(&amp;mutex);          /* Enter critical section */
        
        buffer[in] = item;
        printf("Producer %d: Put %d at index %d\n", id, item, in);
        in = (in + 1) % BUFFER_SIZE;
        
        sem_post(&amp;mutex);          /* Exit critical section */
        sem_post(&amp;full_slots);     /* Signal item available */
        
        usleep(rand() % 100000);
    }
    return NULL;
}

void* consumer(void* arg) {
    int id = *(int*)arg;
    for (int i = 0; i &lt; 10; i++) {
        sem_wait(&amp;full_slots);     /* Wait for item */
        sem_wait(&amp;mutex);          /* Enter critical section */
        
        int item = buffer[out];
        printf("Consumer %d: Got %d from index %d\n", id, item, out);
        out = (out + 1) % BUFFER_SIZE;
        
        sem_post(&amp;mutex);          /* Exit critical section */
        sem_post(&amp;empty_slots);    /* Signal empty slot */
        
        usleep(rand() % 150000);
    }
    return NULL;
}

int main() {
    pthread_t prod[2], cons[2];
    int ids[] = {0, 1};
    
    sem_init(&amp;mutex, 0, 1);
    sem_init(&amp;empty_slots, 0, BUFFER_SIZE);
    sem_init(&amp;full_slots, 0, 0);
    
    pthread_create(&amp;prod[0], NULL, producer, &amp;ids[0]);
    pthread_create(&amp;prod[1], NULL, producer, &amp;ids[1]);
    pthread_create(&amp;cons[0], NULL, consumer, &amp;ids[0]);
    pthread_create(&amp;cons[1], NULL, consumer, &amp;ids[1]);
    
    for (int i = 0; i &lt; 2; i++) {
        pthread_join(prod[i], NULL);
        pthread_join(cons[i], NULL);
    }
    
    sem_destroy(&amp;mutex);
    sem_destroy(&amp;empty_slots);
    sem_destroy(&amp;full_slots);
    return 0;
}</code></pre>
                </div>

                <div id="readers-writers" class="blog-content mt-5">
                    <h2><i class="fas fa-book-reader me-2 text-teal"></i>Readers-Writers Problem</h2>
                    
                    <p>Multiple readers can read simultaneously, but writers need exclusive access. How do we balance reader concurrency with writer access?</p>

<pre class="language-text"><code>Readers-Writers Constraints:
══════════════════════════════════════════════════════════════

✓ Multiple readers can read simultaneously
✗ Only one writer at a time
✗ No readers while writing
✗ No writing while readers active

Timing Diagram:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Reader 1: ████████████
Reader 2:     ████████████████
Reader 3:         ████████
Writer:                       ████████  (waits for readers)
Reader 4:                               ████████


Two Variants:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Readers-Priority: Readers can starve writers
   • New readers join even if writer waiting
   
2. Writers-Priority: Writers can starve readers
   • Once writer waiting, no new readers start

3. Fair: Requests serviced in order (complex)</code></pre>

                    <div class="experiment-card">
                        <h4><i class="fas fa-code me-2"></i>Readers-Writers Solution (Readers Priority)</h4>
                        <div class="content">
<pre class="language-c"><code>/* Readers-Writers with Readers Priority */
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;

int read_count = 0;           /* Number of active readers */
sem_t mutex;                  /* Protect read_count */
sem_t write_lock;             /* Exclusive access for writing */

void reader() {
    sem_wait(&amp;mutex);
    read_count++;
    if (read_count == 1) {
        /* First reader locks out writers */
        sem_wait(&amp;write_lock);
    }
    sem_post(&amp;mutex);
    
    /* --- Reading (shared access) --- */
    printf("Reader reading...\n");
    
    sem_wait(&amp;mutex);
    read_count--;
    if (read_count == 0) {
        /* Last reader allows writers */
        sem_post(&amp;write_lock);
    }
    sem_post(&amp;mutex);
}

void writer() {
    sem_wait(&amp;write_lock);  /* Exclusive access */
    
    /* --- Writing (exclusive access) --- */
    printf("Writer writing...\n");
    
    sem_post(&amp;write_lock);
}

/* Problem: Writers may starve if readers keep arriving! */</code></pre>
                        </div>
                    </div>

<pre class="language-c"><code>/* pthread read-write lock (handles fairness internally) */
#include &lt;pthread.h&gt;

pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
int shared_data = 0;

void* reader_thread(void* arg) {
    pthread_rwlock_rdlock(&amp;rwlock);  /* Acquire read lock */
    printf("Read: %d\n", shared_data);
    pthread_rwlock_unlock(&amp;rwlock);
    return NULL;
}

void* writer_thread(void* arg) {
    pthread_rwlock_wrlock(&amp;rwlock);  /* Acquire write lock */
    shared_data++;
    printf("Wrote: %d\n", shared_data);
    pthread_rwlock_unlock(&amp;rwlock);
    return NULL;
}</code></pre>
                </div>

                <div id="dining-philosophers" class="blog-content mt-5">
                    <h2><i class="fas fa-utensils me-2 text-teal"></i>Dining Philosophers Problem</h2>
                    
                    <p>Five philosophers sit at a round table with five forks. Each needs two forks to eat. This classic problem illustrates <strong>deadlock</strong> and <strong>starvation</strong>.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-users me-2"></i>The Setup</h4>
                        <div class="content">
<pre class="language-text"><code>Dining Philosophers Problem:
══════════════════════════════════════════════════════════════

             P0
            /   \
         F0       F4
         /         \
       P1           P4
         \         /
         F1       F3
           \     /
            P2—F2—P3

• 5 philosophers alternate between THINKING and EATING
• Need BOTH adjacent forks to eat
• Forks can only be held by one philosopher


Naive Solution (DEADLOCK!):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
void philosopher(int id) {
    while (1) {
        think();
        pick_up(fork[id]);           /* Pick left fork */
        pick_up(fork[(id+1) % 5]);   /* Pick right fork */
        eat();
        put_down(fork[id]);
        put_down(fork[(id+1) % 5]);
    }
}

DEADLOCK: All pick up left fork → All wait for right fork
          → No one can proceed → DEADLOCK!</code></pre>
                        </div>
                    </div>

<pre class="language-text"><code>Solutions to Dining Philosophers:
══════════════════════════════════════════════════════════════

1. LIMIT DINERS
   • Allow at most 4 philosophers to sit at once
   • Guarantees at least one can get both forks

2. ASYMMETRIC
   • Odd philosophers: left then right
   • Even philosophers: right then left
   • Breaks circular wait

3. RESOURCE ORDERING (Best)
   • Always pick up lower-numbered fork first
   • Philosopher 4 picks F0 then F4 (not F4 then F0)
   • Prevents circular wait

4. WAITER/ARBITER
   • Central coordinator grants permission to pick up forks
   • Serializes access but bottleneck</code></pre>

<pre class="language-c"><code>/* Dining Philosophers - Resource Ordering Solution */
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define N 5
sem_t forks[N];

void think(int id) {
    printf("Philosopher %d is thinking\n", id);
    sleep(rand() % 3);
}

void eat(int id) {
    printf("Philosopher %d is eating\n", id);
    sleep(rand() % 2);
}

void* philosopher(void* arg) {
    int id = *(int*)arg;
    int left = id;
    int right = (id + 1) % N;
    
    /* Resource ordering: always pick lower-numbered fork first */
    int first = (left &lt; right) ? left : right;
    int second = (left &lt; right) ? right : left;
    
    while (1) {
        think(id);
        
        printf("Philosopher %d wants to eat\n", id);
        sem_wait(&amp;forks[first]);   /* Pick up first (lower #) */
        sem_wait(&amp;forks[second]);  /* Pick up second (higher #) */
        
        eat(id);
        
        sem_post(&amp;forks[second]);  /* Put down second */
        sem_post(&amp;forks[first]);   /* Put down first */
    }
    return NULL;
}

int main() {
    pthread_t threads[N];
    int ids[N];
    
    for (int i = 0; i &lt; N; i++) {
        sem_init(&amp;forks[i], 0, 1);
        ids[i] = i;
    }
    
    for (int i = 0; i &lt; N; i++) {
        pthread_create(&amp;threads[i], NULL, philosopher, &amp;ids[i]);
    }
    
    for (int i = 0; i &lt; N; i++) {
        pthread_join(threads[i], NULL);
    }
    return 0;
}</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Real-World Analog:</strong> Database transactions acquiring multiple locks, network protocols with bidirectional connections, or any system where processes need multiple resources. Resource ordering is a practical deadlock prevention strategy.
                    </div>
                </div>

                <div id="conclusion" class="blog-content mt-5">
                    <h2><i class="fas fa-flag-checkered me-2 text-teal"></i>Conclusion & Next Steps</h2>
                    
                    <p>Synchronization is fundamental to concurrent programming. We've covered:</p>
                    
                    <ul>
                        <li><strong>Critical Section:</strong> Mutual exclusion, progress, bounded waiting</li>
                        <li><strong>Locks/Mutexes:</strong> Hardware-supported mutual exclusion</li>
                        <li><strong>Semaphores:</strong> Counting-based synchronization</li>
                        <li><strong>Condition Variables:</strong> Wait for specific conditions</li>
                        <li><strong>Classic Problems:</strong> Producer-consumer, readers-writers, dining philosophers</li>
                    </ul>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Key Insight:</strong> Most bugs in concurrent programs come from incorrect synchronization—race conditions, deadlocks, and starvation. Use well-tested patterns and high-level abstractions when possible!
                    </div>

                    <div class="series-next">
                        <h4><i class="fas fa-arrow-right me-2"></i>Next in the Series</h4>
                        <p>In <a href="comp-arch-deadlocks.html"><strong>Part 13: Deadlocks & Prevention</strong></a>, we'll dive deeper into deadlock conditions, detection algorithms, and prevention strategies including the Banker's algorithm.</p>
                    </div>
                </div>

                <div class="related-posts">
                    <h3><i class="fas fa-book me-2"></i>Continue the Computer Architecture & OS Series</h3>
                    <div class="related-post-item">
                        <h5>Part 11: CPU Scheduling Algorithms</h5>
                        <p>FCFS, Round Robin, CFS, and real-time scheduling.</p>
                        <a href="comp-arch-cpu-scheduling.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 13: Deadlocks & Prevention</h5>
                        <p>Coffman conditions, detection, and Banker's algorithm.</p>
                        <a href="comp-arch-deadlocks.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 10: Threads & Concurrency</h5>
                        <p>Threading models, pthreads, and race conditions.</p>
                        <a href="comp-arch-threads-concurrency.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    <div id="categoryIndicator" class="category-indicator"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="../../../js/main.js"></script>
    <script src="../../../js/cookie-consent.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    <script>
        const themes = { 'prism-theme': 'Tomorrow Night', 'prism-default': 'Default', 'prism-dark': 'Dark', 'prism-twilight': 'Twilight', 'prism-okaidia': 'Okaidia', 'prism-solarizedlight': 'Solarized Light' };
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        function switchTheme(themeId) { Object.keys(themes).forEach(id => { const link = document.getElementById(id); if (link) link.disabled = true; }); const selectedLink = document.getElementById(themeId); if (selectedLink) { selectedLink.disabled = false; localStorage.setItem('prism-theme', themeId); } document.querySelectorAll('div.code-toolbar select').forEach(dropdown => { dropdown.value = themeId; }); setTimeout(() => Prism.highlightAll(), 10); }
        document.addEventListener('DOMContentLoaded', function() { switchTheme(savedTheme); });
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) { const select = document.createElement('select'); select.setAttribute('aria-label', 'Select code theme'); Object.keys(themes).forEach(themeId => { const option = document.createElement('option'); option.value = themeId; option.textContent = themes[themeId]; if (themeId === savedTheme) option.selected = true; select.appendChild(option); }); select.addEventListener('change', function(e) { switchTheme(e.target.value); }); return select; });
    </script>
</body>
</html>
