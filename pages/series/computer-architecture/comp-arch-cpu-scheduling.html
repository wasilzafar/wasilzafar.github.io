<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 11: CPU Scheduling Algorithms - Learn about FCFS, Round Robin, Priority Scheduling, CFS, and real-time scheduling algorithms." />
    <meta name="keywords" content="CPU scheduling, scheduling algorithms, FCFS, Round Robin, CFS, priority scheduling, real-time scheduling, preemptive scheduling, process scheduler" />
    
    <meta property="og:title" content="Part 11: CPU Scheduling Algorithms | Computer Architecture & OS Mastery" />
    <meta property="og:description" content="Master CPU scheduling: FCFS, Round Robin, CFS, priority scheduling, and real-time algorithms." />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://wasilzafar.com/pages/series/computer-architecture/comp-arch-cpu-scheduling.html" />
    <meta property="article:published_time" content="2026-01-31" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />

    <title>Part 11: CPU Scheduling Algorithms | Computer Architecture & OS Mastery - Wasil Zafar</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', { 'ad_storage': 'denied', 'ad_user_data': 'denied', 'ad_personalization': 'denied', 'analytics_storage': 'denied', 'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE'] });
        gtag('consent', 'default', { 'ad_storage': 'granted', 'ad_user_data': 'granted', 'ad_personalization': 'granted', 'analytics_storage': 'granted' });
        gtag('set', 'url_passthrough', true);
    </script>
    <script>
        (function(w, d, s, l, i) { w[l] = w[l] || []; w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'}); var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f); })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>
</head>
<body>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <section class="blog-hero">
        <div class="container py-5">
            <a href="../../categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
            <h1 class="display-4 fw-bold mt-4">Part 11: CPU Scheduling Algorithms</h1>
            <div class="blog-meta">
                <span><i class="fas fa-calendar me-2"></i>January 31, 2026</span>
                <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                <span class="reading-time"><i class="fas fa-clock me-1"></i>28 min read</span>
                <button onclick="window.print()" class="print-btn" title="Print this article"><i class="fas fa-print"></i> Print</button>
            </div>
            <p class="lead mt-3">Explore how operating systems decide which process runs next—from classic algorithms like FCFS and Round Robin to modern schedulers like Linux CFS.</p>
        </div>
    </section>

    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents"><i class="fas fa-list"></i></button>

    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li><a href="#introduction" onclick="closeNav()">Introduction</a></li>
            <li><a href="#scheduling-criteria" onclick="closeNav()">Scheduling Criteria</a></li>
            <li><a href="#fcfs" onclick="closeNav()">First-Come First-Served</a></li>
            <li><a href="#sjf" onclick="closeNav()">Shortest Job First</a></li>
            <li><a href="#round-robin" onclick="closeNav()">Round Robin</a></li>
            <li><a href="#priority" onclick="closeNav()">Priority Scheduling</a></li>
            <li><a href="#multilevel" onclick="closeNav()">Multilevel Queues</a></li>
            <li><a href="#cfs" onclick="closeNav()">Completely Fair Scheduler</a></li>
            <li><a href="#realtime" onclick="closeNav()">Real-Time Scheduling</a></li>
            <li><a href="#conclusion" onclick="closeNav()">Conclusion & Next Steps</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-clock me-2 text-teal"></i>Introduction</h2>
                    <p>CPU scheduling determines which process runs on the CPU at any given time. The scheduler's decisions directly impact system responsiveness, throughput, and fairness.</p>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-sitemap me-2"></i>
                        <strong>Series Context:</strong> This is <strong>Part 11 of 24</strong> in the Computer Architecture & Operating Systems Mastery series. Building on threads and concurrency, we now explore how the OS allocates CPU time.
                    </div>

                    <div class="experiment-card" id="series-nav">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">24-Part Series</span>
                            <span class="badge bg-crimson">Computer Architecture & OS Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="comp-arch-foundations.html"><strong>Part 1:</strong> Foundations of Computer Systems</a> — System overview, architectures, OS role</li>
                                <li><a href="comp-arch-digital-logic.html"><strong>Part 2:</strong> Digital Logic & CPU Building Blocks</a> — Gates, registers, datapath, microarchitecture</li>
                                <li><a href="comp-arch-isa.html"><strong>Part 3:</strong> Instruction Set Architecture (ISA)</a> — RISC vs CISC, instruction formats, addressing</li>
                                <li><a href="comp-arch-assembly.html"><strong>Part 4:</strong> Assembly Language & Machine Code</a> — Registers, stack, calling conventions</li>
                                <li><a href="comp-arch-linkers-loaders.html"><strong>Part 5:</strong> Assemblers, Linkers & Loaders</a> — Object files, ELF, dynamic linking</li>
                                <li><a href="comp-arch-compilers.html"><strong>Part 6:</strong> Compilers & Program Translation</a> — Lexing, parsing, code generation</li>
                                <li><a href="comp-arch-cpu-pipelining.html"><strong>Part 7:</strong> CPU Execution & Pipelining</a> — Fetch-decode-execute, hazards, prediction</li>
                                <li><a href="comp-arch-os-kernel.html"><strong>Part 8:</strong> OS Architecture & Kernel Design</a> — Monolithic, microkernel, system calls</li>
                                <li><a href="comp-arch-processes.html"><strong>Part 9:</strong> Processes & Program Execution</a> — Process lifecycle, PCB, fork/exec</li>
                                <li><a href="comp-arch-threads-concurrency.html"><strong>Part 10:</strong> Threads & Concurrency</a> — Threading models, pthreads, race conditions</li>
                                <li><strong>Part 11: CPU Scheduling Algorithms (This Guide)</strong> — FCFS, RR, CFS, real-time scheduling</li>
                                <li><a href="comp-arch-synchronization.html"><strong>Part 12:</strong> Synchronization & Coordination</a> — Locks, semaphores, classic problems</li>
                                <li><a href="comp-arch-deadlocks.html"><strong>Part 13:</strong> Deadlocks & Prevention</a> — Coffman conditions, Banker's algorithm</li>
                                <li><a href="comp-arch-cache-memory-hierarchy.html"><strong>Part 14:</strong> Memory Hierarchy & Cache</a> — L1/L2/L3, cache coherence, NUMA</li>
                                <li><a href="comp-arch-memory-management.html"><strong>Part 15:</strong> Memory Management Fundamentals</a> — Address spaces, fragmentation, allocation</li>
                                <li><a href="comp-arch-virtual-memory.html"><strong>Part 16:</strong> Virtual Memory & Paging</a> — Page tables, TLB, demand paging</li>
                                <li><a href="comp-arch-file-systems.html"><strong>Part 17:</strong> File Systems & Storage</a> — Inodes, journaling, ext4, NTFS</li>
                                <li><a href="comp-arch-io-devices.html"><strong>Part 18:</strong> I/O Systems & Device Drivers</a> — Interrupts, DMA, disk scheduling</li>
                                <li><a href="comp-arch-multiprocessor.html"><strong>Part 19:</strong> Multiprocessor Systems</a> — SMP, NUMA, cache coherence</li>
                                <li><a href="comp-arch-security.html"><strong>Part 20:</strong> OS Security & Protection</a> — Privilege levels, ASLR, sandboxing</li>
                                <li><a href="comp-arch-virtualization.html"><strong>Part 21:</strong> Virtualization & Containers</a> — Hypervisors, namespaces, cgroups</li>
                                <li><a href="comp-arch-kernel-internals.html"><strong>Part 22:</strong> Advanced Kernel Internals</a> — Linux subsystems, kernel debugging</li>
                                <li><a href="comp-arch-case-studies.html"><strong>Part 23:</strong> Case Studies</a> — Linux vs Windows vs macOS</li>
                                <li><a href="comp-arch-capstone-projects.html"><strong>Part 24:</strong> Capstone Projects</a> — Shell, thread pool, paging simulator</li>
                            </ol>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-question-circle me-2"></i>
                        <strong>The Scheduling Problem:</strong> With many processes wanting CPU time and only limited cores, how does the OS decide who runs next? This decision happens thousands of times per second and dramatically affects system performance.
                    </div>
                </div>

                <div id="scheduling-criteria" class="blog-content mt-5">
                    <h2><i class="fas fa-chart-bar me-2 text-teal"></i>Scheduling Criteria</h2>
                    
                    <p>Different scheduling algorithms optimize for different metrics. No single algorithm is best for all situations.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-ruler-combined me-2"></i>Performance Metrics</h4>
                        <div class="content">
<pre class="language-text"><code>Scheduling Metrics:
══════════════════════════════════════════════════════════════

1. CPU UTILIZATION
   • Percentage of time CPU is busy (not idle)
   • Goal: Keep CPU as busy as possible (40-90% typical)
   
2. THROUGHPUT
   • Number of processes completed per unit time
   • Goal: Maximize (complete more work)

3. TURNAROUND TIME
   • Total time from submission to completion
   • Turnaround = Completion Time - Arrival Time
   • Goal: Minimize

4. WAITING TIME
   • Time spent waiting in ready queue (not running)
   • Waiting = Turnaround - Burst Time
   • Goal: Minimize

5. RESPONSE TIME
   • Time from submission to first response
   • Critical for interactive systems
   • Goal: Minimize (users notice &gt;100ms delays)

Example:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Process arrives at t=0, starts at t=5, completes at t=15
Burst time (actual CPU needed) = 10

Turnaround = 15 - 0 = 15
Waiting    = 15 - 10 = 5  (or 5 - 0 = 5)
Response   = 5 - 0 = 5</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-balance-scale me-2"></i>
                        <strong>Trade-offs:</strong> Optimizing one metric often hurts another. High throughput may increase response time. Low response time may reduce throughput. The scheduler must balance based on system goals.
                    </div>
                </div>

                <div id="fcfs" class="blog-content mt-5">
                    <h2><i class="fas fa-list-ol me-2 text-teal"></i>First-Come First-Served (FCFS)</h2>
                    
                    <p>The simplest scheduling algorithm: processes run in the order they arrive. Non-preemptive—once a process starts, it runs to completion.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-calculator me-2"></i>FCFS Example</h4>
                        <div class="content">
<pre class="language-text"><code>FCFS Scheduling:
══════════════════════════════════════════════════════════════

Processes:
┌─────────┬──────────────┬────────────┐
│ Process │ Arrival Time │ Burst Time │
├─────────┼──────────────┼────────────┤
│   P1    │      0       │     24     │
│   P2    │      1       │      3     │
│   P3    │      2       │      3     │
└─────────┴──────────────┴────────────┘

Gantt Chart (FCFS order):
┌────────────────────────────┬─────┬─────┐
│            P1              │ P2  │ P3  │
└────────────────────────────┴─────┴─────┘
0                           24    27    30

Results:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Process  Completion  Turnaround    Waiting
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  P1         24       24-0=24       24-24=0
  P2         27       27-1=26       26-3=23
  P3         30       30-2=28       28-3=25
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Average Turnaround: (24+26+28)/3 = 26
Average Waiting:    (0+23+25)/3 = 16

CONVOY EFFECT: Short jobs (P2, P3) wait behind long job (P1)!</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Convoy Effect:</strong> FCFS suffers when a long CPU-bound process arrives first. All shorter processes must wait, causing poor average waiting time. Imagine being stuck behind a slow truck on a single-lane road!
                    </div>
                </div>

                <div id="sjf" class="blog-content mt-5">
                    <h2><i class="fas fa-sort-amount-up me-2 text-teal"></i>Shortest Job First (SJF)</h2>
                    
                    <p>Schedule the process with the smallest burst time next. Proven optimal for minimizing average waiting time, but requires knowing burst times in advance.</p>

<pre class="language-text"><code>SJF Scheduling (Same processes as FCFS):
══════════════════════════════════════════════════════════════

Gantt Chart (shortest first):
┌─────┬─────┬────────────────────────────┐
│ P2  │ P3  │            P1              │
└─────┴─────┴────────────────────────────┘
0     3     6                           30

Results:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Process  Completion  Turnaround    Waiting
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  P1         30       30-0=30       30-24=6
  P2          3        3-1=2         2-3=-1→0*
  P3          6        6-2=4         4-3=1
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Average Turnaround: (30+2+4)/3 = 12  (vs 26 for FCFS!)
Average Waiting:    (6+0+1)/3 = 2.3  (vs 16 for FCFS!)

*P2 arrived at t=1, started at t=1 (P1 hadn't started yet in 
 this non-preemptive version starting fresh)


SRTF (Shortest Remaining Time First) - Preemptive SJF:
══════════════════════════════════════════════════════════════
If new process arrives with shorter burst than current 
remaining time → preempt current process.

Arrival: P1(0,24), P2(1,3), P3(2,3)

Timeline:
t=0: P1 starts (only one)
t=1: P2 arrives, 3 &lt; 23 remaining → preempt P1, run P2
t=2: P3 arrives, 3 = 2 remaining → no preempt (tie)
t=4: P2 done, P3 runs (3 &lt; 23)
t=7: P3 done, P1 resumes
t=30: P1 done

┌───┬─────┬─────┬──────────────────────────┐
│P1 │ P2  │ P3  │          P1              │
└───┴─────┴─────┴──────────────────────────┘
0   1     4     7                          30</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-crystal-ball me-2"></i>
                        <strong>The Prediction Problem:</strong> SJF requires knowing burst times, but we can't know the future! Real systems estimate based on past behavior: exponential averaging of previous bursts.
                    </div>
                </div>

                <div id="round-robin" class="blog-content mt-5">
                    <h2><i class="fas fa-sync-alt me-2 text-teal"></i>Round Robin</h2>
                    
                    <p><strong>Round Robin (RR)</strong> gives each process a fixed time slice (quantum), then moves to the next. Preemptive and fair—every process gets equal CPU time.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-redo me-2"></i>Round Robin with Time Quantum = 4</h4>
                        <div class="content">
<pre class="language-text"><code>Round Robin (quantum = 4):
══════════════════════════════════════════════════════════════

Processes (all arrive at t=0):
P1: 24ms, P2: 3ms, P3: 3ms

Ready Queue Evolution:
t=0:  [P1, P2, P3]  → Run P1 for 4ms
t=4:  [P2, P3, P1]  → Run P2 for 3ms (finishes)
t=7:  [P3, P1]      → Run P3 for 3ms (finishes)
t=10: [P1]          → Run P1 for 4ms
t=14: [P1]          → Run P1 for 4ms
t=18: [P1]          → Run P1 for 4ms
t=22: [P1]          → Run P1 for 4ms
t=26: [P1]          → Run P1 for 4ms (finishes, 4 remaining)

Wait, P1 needs 24ms total: 24 = 4+4+4+4+4+4 = 6 quanta
After t=4: P1 has 20ms left
After 5 more quanta (20ms): P1 done at t=4+3+3+20 = t=30

Gantt Chart:
┌────┬───┬───┬────┬────┬────┬────┬────┬────┐
│ P1 │P2 │P3 │ P1 │ P1 │ P1 │ P1 │ P1 │ P1 │
└────┴───┴───┴────┴────┴────┴────┴────┴────┘
0    4   7  10   14   18   22   26   30

Results:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
P1: Turnaround = 30, Waiting = 30-24 = 6
P2: Turnaround = 7,  Waiting = 7-3 = 4
P3: Turnaround = 10, Waiting = 10-3 = 7
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Average Turnaround: (30+7+10)/3 = 15.67
Average Waiting:    (6+4+7)/3 = 5.67</code></pre>
                        </div>
                    </div>

<pre class="language-text"><code>Time Quantum Selection:
══════════════════════════════════════════════════════════════

Too Large (q → ∞):
• Becomes FCFS (no preemption)
• Poor response time

Too Small (q → 0):
• Too many context switches
• Overhead dominates useful work
• "Processor sharing" - everyone progresses but slowly

Rule of thumb: 80% of CPU bursts should complete within one quantum
Typical values: 10-100 milliseconds

Context Switch Overhead:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Quantum    Context Switches    Overhead (if switch = 0.1ms)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
100ms      10/sec              0.1%
10ms       100/sec             1%
1ms        1000/sec            10%  ← Too much overhead!</code></pre>
                </div>

                <div id="priority" class="blog-content mt-5">
                    <h2><i class="fas fa-star me-2 text-teal"></i>Priority Scheduling</h2>
                    
                    <p>Each process has a priority; highest priority runs first. Can be preemptive or non-preemptive.</p>

<pre class="language-text"><code>Priority Scheduling:
══════════════════════════════════════════════════════════════

Processes (lower number = higher priority):
┌─────────┬──────────┬────────────┐
│ Process │ Priority │ Burst Time │
├─────────┼──────────┼────────────┤
│   P1    │    3     │     10     │
│   P2    │    1     │      1     │  ← Highest priority
│   P3    │    4     │      2     │
│   P4    │    5     │      1     │
│   P5    │    2     │      5     │
└─────────┴──────────┴────────────┘

Execution order: P2 → P5 → P1 → P3 → P4

Gantt Chart:
┌───┬───────┬────────────┬────┬───┐
│P2 │  P5   │     P1     │ P3 │P4 │
└───┴───────┴────────────┴────┴───┘
0   1       6           16   18  19


STARVATION PROBLEM:
══════════════════════════════════════════════════════════════
Low priority processes may NEVER run if high priority 
processes keep arriving.

Example: MIT's IBM 7094 in 1973 - low priority job submitted 
in 1967 still hadn't run!

SOLUTION: AGING
• Gradually increase priority of waiting processes
• Eventually even lowest priority will become highest
• Prevents indefinite starvation

Aging Example:
Priority increases by 1 every 15 minutes of waiting
Process at priority 127 → after 32 hours → priority 0 (highest)</code></pre>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Priority Sources:</strong> Internal (time limits, memory needs, I/O vs CPU bound) or External (user importance, payment tier, process type). Unix "nice" values: -20 (highest) to +19 (lowest).
                    </div>
                </div>

                <div id="multilevel" class="blog-content mt-5">
                    <h2><i class="fas fa-layer-group me-2 text-teal"></i>Multilevel Queue Scheduling</h2>
                    
                    <p>Multiple ready queues with different priorities and scheduling algorithms. Processes are permanently assigned to a queue based on type.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-sitemap me-2"></i>Multilevel Queue Structure</h4>
                        <div class="content">
<pre class="language-text"><code>Multilevel Queue:
══════════════════════════════════════════════════════════════

┌─────────────────────────────────────────┐ Highest Priority
│ Queue 1: Real-Time Processes            │
│ (FCFS or Priority within queue)         │
├─────────────────────────────────────────┤
│ Queue 2: System Processes               │
│ (Priority scheduling)                   │
├─────────────────────────────────────────┤
│ Queue 3: Interactive Processes          │
│ (Round Robin, q=20ms)                   │
├─────────────────────────────────────────┤
│ Queue 4: Batch Processes                │
│ (FCFS)                                  │
└─────────────────────────────────────────┘ Lowest Priority

Rules:
• Higher queue always preempts lower
• No process in lower queue runs if higher queue non-empty
• Each queue can use different algorithm


Multilevel FEEDBACK Queue:
══════════════════════════════════════════════════════════════
Processes can MOVE between queues based on behavior!

┌─────────────────────────────────────────┐
│ Queue 0: RR, quantum = 8ms              │ ← New processes start here
│                                         │
│    Didn't finish? ─────────────────┐    │
└─────────────────────────────────────│───┘
                                      ▼
┌─────────────────────────────────────────┐
│ Queue 1: RR, quantum = 16ms             │
│                                         │
│    Didn't finish? ─────────────────┐    │
└─────────────────────────────────────│───┘
                                      ▼
┌─────────────────────────────────────────┐
│ Queue 2: FCFS (batch queue)             │ ← CPU-bound processes end here
└─────────────────────────────────────────┘

Benefits:
• Interactive processes (short bursts) stay in high queues
• CPU-bound processes sink to lower queues
• Self-adjusting based on actual behavior</code></pre>
                        </div>
                    </div>
                </div>

                <div id="cfs" class="blog-content mt-5">
                    <h2><i class="fas fa-balance-scale me-2 text-teal"></i>Completely Fair Scheduler (CFS)</h2>
                    
                    <p>Linux's default scheduler since 2.6.23. Instead of time slices, CFS tracks <strong>virtual runtime</strong>—how much CPU time each process has received.</p>

                    <div class="experiment-card">
                        <h4><i class="fab fa-linux me-2"></i>CFS Concept</h4>
                        <div class="content">
<pre class="language-text"><code>Completely Fair Scheduler (CFS):
══════════════════════════════════════════════════════════════

Idea: Track "virtual runtime" (vruntime) for each process.
Always run the process with SMALLEST vruntime.

Virtual Runtime:
vruntime += actual_runtime × (default_weight / process_weight)

• Higher weight (lower nice) → vruntime increases slower
• Lower weight (higher nice) → vruntime increases faster

Example with nice values:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Process  Nice   Weight    After 10ms real time
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  P1      0     1024      vruntime += 10ms
  P2     -5     3121      vruntime += 3.3ms   (runs more)
  P3     +5      335      vruntime += 30.5ms  (runs less)

P2 gets ~3x more CPU than P1, P1 gets ~3x more than P3


Data Structure: Red-Black Tree
══════════════════════════════════════════════════════════════
                    [P3: 50ms]
                   /          \
            [P1: 30ms]      [P5: 80ms]
            /        \
     [P2: 20ms]  [P4: 45ms]

• Ordered by vruntime (leftmost = smallest = runs next)
• O(log n) insert, delete, find-min
• Leftmost node cached for O(1) access

Scheduling:
1. Pick leftmost node (smallest vruntime)
2. Run for "time slice" (dynamic, based on load)
3. Update vruntime
4. Reinsert into tree
5. Repeat</code></pre>
                        </div>
                    </div>

<pre class="language-bash"><code># View scheduler settings on Linux
$ cat /proc/sys/kernel/sched_latency_ns
24000000  # Target latency: 24ms

$ cat /proc/sys/kernel/sched_min_granularity_ns
3000000   # Minimum time slice: 3ms

# Check a process's nice value
$ ps -o pid,ni,comm -p $$
  PID  NI COMMAND
12345   0 bash

# Change nice value
$ nice -n 10 ./cpu_intensive_task  # Lower priority
$ sudo nice -n -10 ./important_task  # Higher priority (need root)</code></pre>
                </div>

                <div id="realtime" class="blog-content mt-5">
                    <h2><i class="fas fa-stopwatch me-2 text-teal"></i>Real-Time Scheduling</h2>
                    
                    <p><strong>Real-time systems</strong> have strict timing requirements. Missing a deadline can be catastrophic (hard real-time) or degrading (soft real-time).</p>

<pre class="language-text"><code>Real-Time Scheduling:
══════════════════════════════════════════════════════════════

HARD REAL-TIME:
• Deadline MUST be met (100% guarantee)
• Examples: Pacemakers, aircraft controls, ABS brakes
• Missing deadline = system failure

SOFT REAL-TIME:  
• Deadline SHOULD be met (best effort)
• Examples: Video playback, audio processing
• Missing deadline = degraded quality


Linux Real-Time Policies:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Policy        Priority    Description
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
SCHED_FIFO    1-99       FIFO within priority, no preemption
SCHED_RR      1-99       Round-robin within priority
SCHED_OTHER   0          CFS (normal processes)
SCHED_BATCH   0          CFS, throughput-oriented
SCHED_IDLE    0          Only when system idle

Real-time (FIFO/RR) ALWAYS preempts normal (OTHER/BATCH/IDLE)


Rate Monotonic Scheduling (RMS):
══════════════════════════════════════════════════════════════
For periodic tasks: Higher frequency → Higher priority

Tasks:
T1: Period=50ms, Execution=25ms  → Priority HIGH
T2: Period=100ms, Execution=35ms → Priority LOW

Schedulable if: Σ(Ci/Pi) ≤ n(2^(1/n) - 1)
For n=2: 25/50 + 35/100 = 0.5 + 0.35 = 0.85 ≤ 0.83

0.85 &gt; 0.83 → Might miss deadlines! (need EDF or faster CPU)</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Priority Inversion:</strong> A high-priority task waiting for a resource held by a low-priority task, while medium-priority tasks run. Famous example: Mars Pathfinder 1997 reset bug. Solution: Priority inheritance—temporarily boost holder's priority.
                    </div>
                </div>

                <div id="conclusion" class="blog-content mt-5">
                    <h2><i class="fas fa-flag-checkered me-2 text-teal"></i>Conclusion & Next Steps</h2>
                    
                    <p>CPU scheduling is fundamental to OS performance. We've covered:</p>
                    
                    <ul>
                        <li><strong>FCFS:</strong> Simple but suffers from convoy effect</li>
                        <li><strong>SJF:</strong> Optimal average waiting but requires prediction</li>
                        <li><strong>Round Robin:</strong> Fair and responsive with proper quantum</li>
                        <li><strong>Priority:</strong> Flexible but needs aging to prevent starvation</li>
                        <li><strong>Multilevel Feedback:</strong> Adaptive based on process behavior</li>
                        <li><strong>CFS:</strong> Linux's fair scheduler using virtual runtime</li>
                        <li><strong>Real-Time:</strong> Guaranteed deadlines for critical systems</li>
                    </ul>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Key Insight:</strong> There's no universally "best" scheduler. Desktop systems prioritize responsiveness (CFS), servers prioritize throughput, embedded systems prioritize real-time guarantees. Know your workload!
                    </div>

                    <div class="series-next">
                        <h4><i class="fas fa-arrow-right me-2"></i>Next in the Series</h4>
                        <p>In <a href="comp-arch-synchronization.html"><strong>Part 12: Synchronization & Coordination</strong></a>, we'll explore how threads coordinate access to shared resources using locks, semaphores, and classic synchronization problems like producer-consumer and readers-writers.</p>
                    </div>
                </div>

                <div class="related-posts">
                    <h3><i class="fas fa-book me-2"></i>Continue the Computer Architecture & OS Series</h3>
                    <div class="related-post-item">
                        <h5>Part 10: Threads & Concurrency</h5>
                        <p>Threading models, pthreads, and race conditions.</p>
                        <a href="comp-arch-threads-concurrency.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 12: Synchronization & Coordination</h5>
                        <p>Locks, semaphores, and classic synchronization problems.</p>
                        <a href="comp-arch-synchronization.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 13: Deadlocks & Prevention</h5>
                        <p>Coffman conditions, detection, and Banker's algorithm.</p>
                        <a href="comp-arch-deadlocks.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    <div id="categoryIndicator" class="category-indicator"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="../../../js/main.js"></script>
    <script src="../../../js/cookie-consent.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    <script>
        const themes = { 'prism-theme': 'Tomorrow Night', 'prism-default': 'Default', 'prism-dark': 'Dark', 'prism-twilight': 'Twilight', 'prism-okaidia': 'Okaidia', 'prism-solarizedlight': 'Solarized Light' };
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        function switchTheme(themeId) { Object.keys(themes).forEach(id => { const link = document.getElementById(id); if (link) link.disabled = true; }); const selectedLink = document.getElementById(themeId); if (selectedLink) { selectedLink.disabled = false; localStorage.setItem('prism-theme', themeId); } document.querySelectorAll('div.code-toolbar select').forEach(dropdown => { dropdown.value = themeId; }); setTimeout(() => Prism.highlightAll(), 10); }
        document.addEventListener('DOMContentLoaded', function() { switchTheme(savedTheme); });
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) { const select = document.createElement('select'); select.setAttribute('aria-label', 'Select code theme'); Object.keys(themes).forEach(themeId => { const option = document.createElement('option'); option.value = themeId; option.textContent = themes[themeId]; if (themeId === savedTheme) option.selected = true; select.appendChild(option); }); select.addEventListener('change', function(e) { switchTheme(e.target.value); }); return select; });
    </script>
</body>
</html>
