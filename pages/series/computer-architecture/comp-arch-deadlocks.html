<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 13: Deadlocks & Prevention - Learn about Coffman conditions, deadlock detection, prevention strategies, and Banker's algorithm." />
    <meta name="keywords" content="deadlocks, Coffman conditions, deadlock prevention, deadlock detection, Banker's algorithm, resource allocation, deadlock avoidance, circular wait" />
    
    <meta property="og:title" content="Part 13: Deadlocks & Prevention | Computer Architecture & OS Mastery" />
    <meta property="og:description" content="Master deadlock handling: Coffman conditions, detection, prevention, and Banker's algorithm." />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://wasilzafar.com/pages/series/computer-architecture/comp-arch-deadlocks.html" />
    <meta property="article:published_time" content="2026-01-31" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />

    <title>Part 13: Deadlocks & Prevention | Computer Architecture & OS Mastery - Wasil Zafar</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', { 'ad_storage': 'denied', 'ad_user_data': 'denied', 'ad_personalization': 'denied', 'analytics_storage': 'denied', 'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE'] });
        gtag('consent', 'default', { 'ad_storage': 'granted', 'ad_user_data': 'granted', 'ad_personalization': 'granted', 'analytics_storage': 'granted' });
        gtag('set', 'url_passthrough', true);
    </script>
    <script>
        (function(w, d, s, l, i) { w[l] = w[l] || []; w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'}); var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f); })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>
</head>
<body>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <section class="blog-hero">
        <div class="container py-5">
            <a href="../../categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
            <h1 class="display-4 fw-bold mt-4">Part 13: Deadlocks & Prevention</h1>
            <div class="blog-meta">
                <span><i class="fas fa-calendar me-2"></i>January 31, 2026</span>
                <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                <span class="reading-time"><i class="fas fa-clock me-1"></i>25 min read</span>
                <button onclick="window.print()" class="print-btn" title="Print this article"><i class="fas fa-print"></i> Print</button>
            </div>
            <p class="lead mt-3">Understand deadlock conditions, learn detection algorithms, and master prevention strategies including Banker's algorithm.</p>
        </div>
    </section>

    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents"><i class="fas fa-list"></i></button>

    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li><a href="#introduction" onclick="closeNav()">Introduction</a></li>
            <li><a href="#coffman-conditions" onclick="closeNav()">Coffman Conditions</a></li>
            <li><a href="#resource-allocation-graph" onclick="closeNav()">Resource Allocation Graph</a></li>
            <li><a href="#deadlock-prevention" onclick="closeNav()">Deadlock Prevention</a></li>
            <li><a href="#deadlock-avoidance" onclick="closeNav()">Deadlock Avoidance</a></li>
            <li><a href="#bankers-algorithm" onclick="closeNav()">Banker's Algorithm</a></li>
            <li><a href="#deadlock-detection" onclick="closeNav()">Deadlock Detection</a></li>
            <li><a href="#recovery" onclick="closeNav()">Recovery from Deadlock</a></li>
            <li><a href="#conclusion" onclick="closeNav()">Conclusion & Next Steps</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-ban me-2 text-teal"></i>Introduction</h2>
                    <p>A deadlock occurs when processes are waiting for resources held by each other, creating a circular dependency that prevents any progress. Understanding deadlocks is crucial for building reliable systems.</p>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-sitemap me-2"></i>
                        <strong>Series Context:</strong> This is <strong>Part 13 of 24</strong> in the Computer Architecture & Operating Systems Mastery series. Building on synchronization, we now explore the dangerous deadlock condition.
                    </div>

                    <div class="experiment-card" id="series-nav">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">24-Part Series</span>
                            <span class="badge bg-crimson">Computer Architecture & OS Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="comp-arch-foundations.html"><strong>Part 1:</strong> Foundations of Computer Systems</a> — System overview, architectures, OS role</li>
                                <li><a href="comp-arch-digital-logic.html"><strong>Part 2:</strong> Digital Logic & CPU Building Blocks</a> — Gates, registers, datapath, microarchitecture</li>
                                <li><a href="comp-arch-isa.html"><strong>Part 3:</strong> Instruction Set Architecture (ISA)</a> — RISC vs CISC, instruction formats, addressing</li>
                                <li><a href="comp-arch-assembly.html"><strong>Part 4:</strong> Assembly Language & Machine Code</a> — Registers, stack, calling conventions</li>
                                <li><a href="comp-arch-linkers-loaders.html"><strong>Part 5:</strong> Assemblers, Linkers & Loaders</a> — Object files, ELF, dynamic linking</li>
                                <li><a href="comp-arch-compilers.html"><strong>Part 6:</strong> Compilers & Program Translation</a> — Lexing, parsing, code generation</li>
                                <li><a href="comp-arch-cpu-pipelining.html"><strong>Part 7:</strong> CPU Execution & Pipelining</a> — Fetch-decode-execute, hazards, prediction</li>
                                <li><a href="comp-arch-os-kernel.html"><strong>Part 8:</strong> OS Architecture & Kernel Design</a> — Monolithic, microkernel, system calls</li>
                                <li><a href="comp-arch-processes.html"><strong>Part 9:</strong> Processes & Program Execution</a> — Process lifecycle, PCB, fork/exec</li>
                                <li><a href="comp-arch-threads-concurrency.html"><strong>Part 10:</strong> Threads & Concurrency</a> — Threading models, pthreads, race conditions</li>
                                <li><a href="comp-arch-cpu-scheduling.html"><strong>Part 11:</strong> CPU Scheduling Algorithms</a> — FCFS, RR, CFS, real-time scheduling</li>
                                <li><a href="comp-arch-synchronization.html"><strong>Part 12:</strong> Synchronization & Coordination</a> — Locks, semaphores, classic problems</li>
                                <li><strong>Part 13: Deadlocks & Prevention (This Guide)</strong> — Coffman conditions, Banker's algorithm</li>
                                <li><a href="comp-arch-cache-memory-hierarchy.html"><strong>Part 14:</strong> Memory Hierarchy & Cache</a> — L1/L2/L3, cache coherence, NUMA</li>
                                <li><a href="comp-arch-memory-management.html"><strong>Part 15:</strong> Memory Management Fundamentals</a> — Address spaces, fragmentation, allocation</li>
                                <li><a href="comp-arch-virtual-memory.html"><strong>Part 16:</strong> Virtual Memory & Paging</a> — Page tables, TLB, demand paging</li>
                                <li><a href="comp-arch-file-systems.html"><strong>Part 17:</strong> File Systems & Storage</a> — Inodes, journaling, ext4, NTFS</li>
                                <li><a href="comp-arch-io-devices.html"><strong>Part 18:</strong> I/O Systems & Device Drivers</a> — Interrupts, DMA, disk scheduling</li>
                                <li><a href="comp-arch-multiprocessor.html"><strong>Part 19:</strong> Multiprocessor Systems</a> — SMP, NUMA, cache coherence</li>
                                <li><a href="comp-arch-security.html"><strong>Part 20:</strong> OS Security & Protection</a> — Privilege levels, ASLR, sandboxing</li>
                                <li><a href="comp-arch-virtualization.html"><strong>Part 21:</strong> Virtualization & Containers</a> — Hypervisors, namespaces, cgroups</li>
                                <li><a href="comp-arch-kernel-internals.html"><strong>Part 22:</strong> Advanced Kernel Internals</a> — Linux subsystems, kernel debugging</li>
                                <li><a href="comp-arch-case-studies.html"><strong>Part 23:</strong> Case Studies</a> — Linux vs Windows vs macOS</li>
                                <li><a href="comp-arch-capstone-projects.html"><strong>Part 24:</strong> Capstone Projects</a> — Shell, thread pool, paging simulator</li>
                            </ol>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-question-circle me-2"></i>
                        <strong>The Deadlock Problem:</strong> Two cars meet on a narrow bridge. Neither can proceed because each is waiting for the other to back up. This is deadlock—and it happens in computer systems too!
                    </div>
                </div>

                <div id="coffman-conditions" class="blog-content mt-5">
                    <h2><i class="fas fa-list-ol me-2 text-teal"></i>Coffman Conditions</h2>
                    
                    <p>Deadlock can only occur when <strong>all four</strong> conditions hold simultaneously. Break any one condition to prevent deadlock.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-exclamation-circle me-2"></i>The Four Coffman Conditions</h4>
                        <div class="content">
<pre class="language-text"><code>Coffman Conditions for Deadlock (1971):
══════════════════════════════════════════════════════════════

1. MUTUAL EXCLUSION
   • At least one resource must be non-shareable
   • Only one process can use resource at a time
   Example: Printer can only print one job at a time

2. HOLD AND WAIT
   • Process holds at least one resource while waiting
     for additional resources held by others
   Example: Hold lock A, wait for lock B

3. NO PREEMPTION
   • Resources cannot be forcibly taken away
   • Process must voluntarily release resources
   Example: Cannot force a process to release a mutex

4. CIRCULAR WAIT
   • Chain of processes: P1 waits for P2, P2 waits for P3,
     ..., Pn waits for P1
   Example: Dining philosophers all holding left fork


ALL FOUR must be true for deadlock to occur!
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
┌────────────┐     ┌────────────┐
│ Process A  │────→│ Resource 1 │ (holds)
│ waits for  │     └────────────┘
│ Resource 2 │            ↑
└────────────┘     ┌──────┴─────┐
      │            │ Process B  │ (holds)
      └───────────→│ waits for  │
                   │ Resource 1 │
                   └────────────┘
      
DEADLOCK! Circular wait exists.</code></pre>
                        </div>
                    </div>
                </div>

                <div id="resource-allocation-graph" class="blog-content mt-5">
                    <h2><i class="fas fa-project-diagram me-2 text-teal"></i>Resource Allocation Graph</h2>
                    
                    <p>A <strong>Resource Allocation Graph (RAG)</strong> visualizes the state of resource allocation and can detect potential deadlocks.</p>

<pre class="language-text"><code>Resource Allocation Graph Notation:
══════════════════════════════════════════════════════════════

Nodes:
  ○ Process (circle)
  ▢ Resource type (rectangle with dots for instances)

Edges:
  ○ ──→ ▢  Request edge: Process requests resource
  ▢ ──→ ○  Assignment edge: Resource assigned to process


Example RAG - No Deadlock:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

     ┌──────────────────────────┐
     ↓                          │
    ○ P1     ○ P2 ───────→ ▢ R2 ●
     │        ↑              │
     │        │              │
     ▼        └──────────────┘
   ▢ R1 ● ───────────────→ P3 ○

P1 holds R1, P2 waits for R2
R2 assigned to P3 → P2 can proceed when P3 releases R2
No cycle → No deadlock


Example RAG - With Deadlock:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

   ○ P1 ───────→ ▢ R1 ● ───────→ ○ P2
     ↑                             │
     │                             ▼
     └────────── ▢ R2 ● ←──────────┘

P1 holds R2, requests R1
P2 holds R1, requests R2
Cycle exists → DEADLOCK!


Detection Rule:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Single instance per resource type: Cycle = Deadlock
• Multiple instances: Cycle necessary but not sufficient
  (may still be able to satisfy from other instances)</code></pre>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Graph Reduction:</strong> Remove processes that can complete (have all needed resources). If all processes can be removed, no deadlock. If reduction gets stuck with remaining processes—deadlock!
                    </div>
                </div>

                <div id="deadlock-prevention" class="blog-content mt-5">
                    <h2><i class="fas fa-shield-alt me-2 text-teal"></i>Deadlock Prevention</h2>
                    
                    <p>Prevent deadlock by ensuring at least one Coffman condition can <strong>never</strong> hold.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-ban me-2"></i>Breaking Each Condition</h4>
                        <div class="content">
<pre class="language-text"><code>Deadlock Prevention Strategies:
══════════════════════════════════════════════════════════════

1. BREAK MUTUAL EXCLUSION
   • Make resources shareable where possible
   • Example: Read-only files, spooling (virtual printers)
   ✗ Often not practical - many resources inherently exclusive

2. BREAK HOLD AND WAIT
   Option A: Request ALL resources at once before starting
      • process_start(need: [R1, R2, R3])
      ✗ Poor utilization, process may not know all needs
   
   Option B: Release all resources before requesting new ones
      • release_all(); request(new_resources);
      ✗ May lose work, expensive to re-acquire

3. BREAK NO PREEMPTION
   • If process can't get resource, release what it holds
   • OS can forcibly take resources
   ✗ Only works for state-saveable resources (CPU, memory)
   ✗ Doesn't work for printers, mutex locks

4. BREAK CIRCULAR WAIT (Most Practical!)
   • Impose total ordering on all resource types
   • Processes must request resources in order
   
   Example: R1 &lt; R2 &lt; R3 &lt; R4
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Process holding R3 can only request R4 (higher)
   Process holding R4 cannot request R1, R2, R3 (lower)
   
   ✓ No circular wait possible!
   ✗ Must define ordering, may be inconvenient</code></pre>
                        </div>
                    </div>

<pre class="language-c"><code>/* Resource Ordering to Prevent Circular Wait */

/* Define resource ordering: LOCK_A &lt; LOCK_B &lt; LOCK_C */
#define LOCK_A 1
#define LOCK_B 2
#define LOCK_C 3

pthread_mutex_t locks[4];

void safe_acquire(int resource1, int resource2) {
    /* Always acquire in order to prevent circular wait */
    int first = (resource1 &lt; resource2) ? resource1 : resource2;
    int second = (resource1 &lt; resource2) ? resource2 : resource1;
    
    pthread_mutex_lock(&amp;locks[first]);
    pthread_mutex_lock(&amp;locks[second]);
}

void safe_release(int resource1, int resource2) {
    pthread_mutex_unlock(&amp;locks[resource1]);
    pthread_mutex_unlock(&amp;locks[resource2]);
}

/* Usage */
void thread_func() {
    safe_acquire(LOCK_B, LOCK_A);  /* Automatically acquires A then B */
    /* ... critical section ... */
    safe_release(LOCK_A, LOCK_B);
}</code></pre>
                </div>

                <div id="deadlock-avoidance" class="blog-content mt-5">
                    <h2><i class="fas fa-route me-2 text-teal"></i>Deadlock Avoidance</h2>
                    
                    <p>Prevention is restrictive. <strong>Avoidance</strong> allows more flexibility—dynamically check if granting a request could lead to deadlock.</p>

<pre class="language-text"><code>Deadlock Avoidance Concept:
══════════════════════════════════════════════════════════════

SAFE STATE:
• System can allocate resources to each process (up to max)
  in SOME order and avoid deadlock
• Exists at least one "safe sequence" of execution

UNSAFE STATE:
• No guaranteed safe sequence
• Deadlock is POSSIBLE (not certain, but might occur)


State Transitions:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

      ┌─────────────────────┐
      │                     │
      │     SAFE STATE      │──── All requests considered
      │                     │     carefully before granting
      └─────────────────────┘
               │
      Request would make │
      state unsafe       │
               ↓
      ┌─────────────────────┐
      │                     │
      │    UNSAFE STATE     │──── Deadlock may or may not
      │                     │     occur
      └─────────────────────┘
               │
      Processes make bad  │
      decisions           │
               ↓
      ┌─────────────────────┐
      │                     │
      │      DEADLOCK       │──── Guaranteed stuck
      │                     │
      └─────────────────────┘


Avoidance Strategy:
• Only grant request if resulting state is SAFE
• If granting would lead to unsafe state → make process wait</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Key Insight:</strong> An unsafe state doesn't mean deadlock has occurred—it means the system can no longer guarantee deadlock won't occur. The system might still complete successfully if processes happen to request resources in a favorable order.
                    </div>
                </div>

                <div id="bankers-algorithm" class="blog-content mt-5">
                    <h2><i class="fas fa-university me-2 text-teal"></i>Banker's Algorithm</h2>
                    
                    <p>Dijkstra's <strong>Banker's Algorithm</strong> determines if granting a request leaves the system in a safe state. Named after how a banker decides loan requests.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-calculator me-2"></i>Banker's Algorithm Example</h4>
                        <div class="content">
<pre class="language-text"><code>Banker's Algorithm:
══════════════════════════════════════════════════════════════

Data Structures (n processes, m resource types):
• Available[m]:    Available instances of each resource
• Max[n][m]:       Maximum demand of each process
• Allocation[n][m]: Currently allocated to each process
• Need[n][m]:      Remaining need (Max - Allocation)


Example: 5 processes (P0-P4), 3 resource types (A, B, C)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Available: A=3, B=3, C=2

         Allocation    Max        Need
         A  B  C      A  B  C    A  B  C
   P0    0  1  0      7  5  3    7  4  3
   P1    2  0  0      3  2  2    1  2  2
   P2    3  0  2      9  0  2    6  0  0
   P3    2  1  1      2  2  2    0  1  1
   P4    0  0  2      4  3  3    4  3  1


Safety Algorithm - Find Safe Sequence:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Work = Available = [3, 3, 2]
Finish = [false, false, false, false, false]

Round 1: Find process with Need ≤ Work
  P0: Need[7,4,3] ≤ [3,3,2]? NO
  P1: Need[1,2,2] ≤ [3,3,2]? YES ✓
  
  Execute P1: Work = Work + Allocation[P1] = [3,3,2]+[2,0,0] = [5,3,2]
  Finish[P1] = true
  Sequence: &lt;P1&gt;

Round 2: Work = [5, 3, 2]
  P0: Need[7,4,3] ≤ [5,3,2]? NO
  P3: Need[0,1,1] ≤ [5,3,2]? YES ✓
  
  Execute P3: Work = [5,3,2]+[2,1,1] = [7,4,3]
  Finish[P3] = true
  Sequence: &lt;P1, P3&gt;

Round 3: Work = [7, 4, 3]
  P0: Need[7,4,3] ≤ [7,4,3]? YES ✓
  
  Execute P0: Work = [7,4,3]+[0,1,0] = [7,5,3]
  Sequence: &lt;P1, P3, P0&gt;

Round 4: Work = [7, 5, 3]
  P2: Need[6,0,0] ≤ [7,5,3]? YES ✓
  
  Execute P2: Work = [7,5,3]+[3,0,2] = [10,5,5]
  Sequence: &lt;P1, P3, P0, P2&gt;

Round 5: Work = [10, 5, 5]
  P4: Need[4,3,1] ≤ [10,5,5]? YES ✓
  
  Execute P4
  Sequence: &lt;P1, P3, P0, P2, P4&gt;

SAFE! All processes can complete.</code></pre>
                        </div>
                    </div>

<pre class="language-python"><code># Banker's Algorithm Implementation
def is_safe_state(available, max_need, allocation):
    n = len(allocation)  # Number of processes
    m = len(available)   # Number of resource types
    
    # Calculate need matrix
    need = [[max_need[i][j] - allocation[i][j] 
             for j in range(m)] for i in range(n)]
    
    work = available[:]
    finish = [False] * n
    safe_sequence = []
    
    while len(safe_sequence) &lt; n:
        found = False
        for i in range(n):
            if not finish[i]:
                # Check if Need[i] &lt;= Work
                if all(need[i][j] &lt;= work[j] for j in range(m)):
                    # Process can complete
                    for j in range(m):
                        work[j] += allocation[i][j]
                    finish[i] = True
                    safe_sequence.append(f"P{i}")
                    found = True
                    break
        
        if not found:
            # No process can proceed - unsafe!
            return False, []
    
    return True, safe_sequence

# Example usage
available = [3, 3, 2]
max_need = [[7,5,3], [3,2,2], [9,0,2], [2,2,2], [4,3,3]]
allocation = [[0,1,0], [2,0,0], [3,0,2], [2,1,1], [0,0,2]]

safe, sequence = is_safe_state(available, max_need, allocation)
print(f"Safe: {safe}, Sequence: {sequence}")
# Output: Safe: True, Sequence: ['P1', 'P3', 'P0', 'P2', 'P4']</code></pre>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Practical Limitations:</strong> Banker's requires knowing maximum resource needs in advance (often unknown), runs in O(n²m) per request (expensive), and assumes fixed number of processes/resources.
                    </div>
                </div>

                <div id="deadlock-detection" class="blog-content mt-5">
                    <h2><i class="fas fa-search me-2 text-teal"></i>Deadlock Detection</h2>
                    
                    <p>Instead of preventing/avoiding, allow deadlock to occur but <strong>detect</strong> it and recover. May be more efficient if deadlocks are rare.</p>

<pre class="language-text"><code>Deadlock Detection Algorithm:
══════════════════════════════════════════════════════════════

Similar to Safety Algorithm, but:
• Use current Request matrix instead of Max
• Optimistic: assume processes will release resources

Algorithm:
1. Work = Available
2. For each process not known to be involved in deadlock:
   - If Request[i] ≤ Work, assume it will complete
   - Work = Work + Allocation[i]
   - Mark process as able to finish
3. Repeat until no more processes can finish
4. Any unmarked processes are DEADLOCKED


When to Run Detection?
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• On every resource request (expensive, immediate detection)
• Periodically (e.g., every 5 minutes)
• When CPU utilization drops below threshold
• When resource request fails

Trade-off: Detection frequency vs overhead</code></pre>

<pre class="language-c"><code>/* Simple deadlock detection via wait-for graph */
#include &lt;stdbool.h&gt;

#define MAX_PROCS 100

/* Wait-for graph: waitfor[i][j] = 1 if process i waits for j */
int waitfor[MAX_PROCS][MAX_PROCS];
bool visited[MAX_PROCS];
bool rec_stack[MAX_PROCS];  /* Recursion stack for cycle detection */

/* DFS to detect cycle (deadlock) */
bool detect_cycle(int proc, int n) {
    visited[proc] = true;
    rec_stack[proc] = true;
    
    for (int j = 0; j &lt; n; j++) {
        if (waitfor[proc][j]) {  /* proc waits for j */
            if (!visited[j]) {
                if (detect_cycle(j, n))
                    return true;  /* Cycle found */
            } else if (rec_stack[j]) {
                return true;  /* Back edge = cycle */
            }
        }
    }
    
    rec_stack[proc] = false;
    return false;
}

bool deadlock_exists(int n) {
    for (int i = 0; i &lt; n; i++) {
        visited[i] = false;
        rec_stack[i] = false;
    }
    
    for (int i = 0; i &lt; n; i++) {
        if (!visited[i] &amp;&amp; detect_cycle(i, n))
            return true;
    }
    return false;
}</code></pre>
                </div>

                <div id="recovery" class="blog-content mt-5">
                    <h2><i class="fas fa-redo me-2 text-teal"></i>Recovery from Deadlock</h2>
                    
                    <p>Once deadlock is detected, the system must break it. Options range from gentle to drastic.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-tools me-2"></i>Recovery Strategies</h4>
                        <div class="content">
<pre class="language-text"><code>Deadlock Recovery Options:
══════════════════════════════════════════════════════════════

1. PROCESS TERMINATION
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Option A: Abort ALL deadlocked processes
      ✓ Guaranteed to break deadlock
      ✗ Expensive - lose all work
   
   Option B: Abort ONE at a time until deadlock broken
      ✓ Less work lost
      ✗ Multiple detection cycles needed
   
   Which to abort? Consider:
   • Priority of process
   • How long it has computed
   • How much longer to complete
   • Resources it holds
   • Resources it needs to complete
   • Type of process (interactive vs batch)


2. RESOURCE PREEMPTION
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Temporarily take resources from a process
   
   Selecting victim:
   • Choose process that loses least work
   • Consider cost of rollback
   
   Rollback:
   • Roll back process to safe state (checkpoint)
   • Or roll back completely and restart
   
   Starvation prevention:
   • Limit how many times same process can be victim
   • Include rollback count in victim selection


3. CHECKPOINT AND ROLLBACK
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Periodically save process state
   On deadlock: roll back one process to earlier checkpoint
   
   ┌─────────────────────────────────────────────────┐
   │ Process execution                               │
   │ ─────●─────────●─────────●──────────►          │
   │    chkpt1    chkpt2    chkpt3                  │
   │                                     ↑           │
   │              Deadlock detected here─┘           │
   │                        │                        │
   │              Roll back to chkpt2               │
   └─────────────────────────────────────────────────┘</code></pre>
                        </div>
                    </div>

<pre class="language-text"><code>Real-World Deadlock Handling:
══════════════════════════════════════════════════════════════

Operating Systems:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Most ignore deadlock (ostrich algorithm)!
• Assume deadlocks are rare
• User reboot is the "recovery"
• Windows: Waits with timeouts

Databases:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Actively detect deadlocks (wait-for graphs)
• ABORT one transaction (victim selection)
• Transaction automatically retries
• PostgreSQL: deadlock_timeout parameter

Distributed Systems:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Much harder - no global state!
• Timeout-based detection
• Two-phase locking with deadlock prevention
• Distributed deadlock detection algorithms</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Practical Reality:</strong> Most systems use a combination—prevention for easy cases (resource ordering), timeouts for detection, and termination for recovery. Pure avoidance (Banker's) is rarely used due to overhead.
                    </div>
                </div>

                <div id="conclusion" class="blog-content mt-5">
                    <h2><i class="fas fa-flag-checkered me-2 text-teal"></i>Conclusion & Next Steps</h2>
                    
                    <p>Deadlocks are a fundamental challenge in concurrent systems. We've covered:</p>
                    
                    <ul>
                        <li><strong>Coffman Conditions:</strong> The four necessary conditions for deadlock</li>
                        <li><strong>Resource Allocation Graphs:</strong> Visual deadlock analysis</li>
                        <li><strong>Prevention:</strong> Break Coffman conditions (especially circular wait)</li>
                        <li><strong>Avoidance:</strong> Dynamic safety checking (Banker's algorithm)</li>
                        <li><strong>Detection &amp; Recovery:</strong> Allow deadlock, then fix it</li>
                    </ul>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Key Takeaway:</strong> Resource ordering to prevent circular wait is the most practical prevention strategy. For systems where deadlocks are rare, detection and recovery may be more efficient than prevention overhead.
                    </div>

                    <div class="series-next">
                        <h4><i class="fas fa-arrow-right me-2"></i>Next in the Series</h4>
                        <p>In <a href="comp-arch-cache-memory-hierarchy.html"><strong>Part 14: Memory Hierarchy & Cache</strong></a>, we'll explore how memory systems are organized for performance—from CPU registers through L1/L2/L3 caches to main memory and beyond.</p>
                    </div>
                </div>

                <div class="related-posts">
                    <h3><i class="fas fa-book me-2"></i>Continue the Computer Architecture & OS Series</h3>
                    <div class="related-post-item">
                        <h5>Part 12: Synchronization & Coordination</h5>
                        <p>Locks, semaphores, and classic synchronization problems.</p>
                        <a href="comp-arch-synchronization.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 14: Memory Hierarchy & Cache</h5>
                        <p>L1/L2/L3 caches, cache coherence, and NUMA.</p>
                        <a href="comp-arch-cache-memory-hierarchy.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 19: Multiprocessor Systems</h5>
                        <p>SMP, NUMA, and multiprocessor scheduling.</p>
                        <a href="comp-arch-multiprocessor.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    <div id="categoryIndicator" class="category-indicator"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="../../../js/main.js"></script>
    <script src="../../../js/cookie-consent.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    <script>
        const themes = { 'prism-theme': 'Tomorrow Night', 'prism-default': 'Default', 'prism-dark': 'Dark', 'prism-twilight': 'Twilight', 'prism-okaidia': 'Okaidia', 'prism-solarizedlight': 'Solarized Light' };
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        function switchTheme(themeId) { Object.keys(themes).forEach(id => { const link = document.getElementById(id); if (link) link.disabled = true; }); const selectedLink = document.getElementById(themeId); if (selectedLink) { selectedLink.disabled = false; localStorage.setItem('prism-theme', themeId); } document.querySelectorAll('div.code-toolbar select').forEach(dropdown => { dropdown.value = themeId; }); setTimeout(() => Prism.highlightAll(), 10); }
        document.addEventListener('DOMContentLoaded', function() { switchTheme(savedTheme); });
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) { const select = document.createElement('select'); select.setAttribute('aria-label', 'Select code theme'); Object.keys(themes).forEach(themeId => { const option = document.createElement('option'); option.value = themeId; option.textContent = themes[themeId]; if (themeId === savedTheme) option.selected = true; select.appendChild(option); }); select.addEventListener('change', function(e) { switchTheme(e.target.value); }); return select; });
    </script>
</body>
</html>
