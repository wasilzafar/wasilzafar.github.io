<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 16: Virtual Memory & Paging - Learn about page tables, TLB, demand paging, page replacement algorithms, and memory-mapped files." />
    <meta name="keywords" content="virtual memory, paging, page tables, TLB, page fault, demand paging, page replacement, LRU, swapping, memory-mapped files" />
    
    <meta property="og:title" content="Part 16: Virtual Memory & Paging | Computer Architecture & OS Mastery" />
    <meta property="og:description" content="Master virtual memory: page tables, TLB, demand paging, and page replacement algorithms." />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://wasilzafar.com/pages/series/computer-architecture/comp-arch-virtual-memory.html" />
    <meta property="article:published_time" content="2026-01-31" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />

    <title>Part 16: Virtual Memory & Paging | Computer Architecture & OS Mastery - Wasil Zafar</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', { 'ad_storage': 'denied', 'ad_user_data': 'denied', 'ad_personalization': 'denied', 'analytics_storage': 'denied', 'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE'] });
        gtag('consent', 'default', { 'ad_storage': 'granted', 'ad_user_data': 'granted', 'ad_personalization': 'granted', 'analytics_storage': 'granted' });
        gtag('set', 'url_passthrough', true);
    </script>
    <script>
        (function(w, d, s, l, i) { w[l] = w[l] || []; w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'}); var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f); })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>
</head>
<body>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <section class="blog-hero">
        <div class="container py-5">
            <a href="../../categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
            <h1 class="display-4 fw-bold mt-4">Part 16: Virtual Memory & Paging</h1>
            <div class="blog-meta">
                <span><i class="fas fa-calendar me-2"></i>January 31, 2026</span>
                <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                <span class="reading-time"><i class="fas fa-clock me-1"></i>35 min read</span>
                <button onclick="window.print()" class="print-btn" title="Print this article"><i class="fas fa-print"></i> Print</button>
            </div>
            <p class="lead mt-3">Dive deep into virtual memory—page tables, TLB, demand paging, and page replacement algorithms.</p>
        </div>
    </section>

    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents"><i class="fas fa-list"></i></button>

    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li><a href="#introduction" onclick="closeNav()">Introduction</a></li>
            <li><a href="#virtual-addressing" onclick="closeNav()">Virtual Addressing</a></li>
            <li><a href="#page-tables" onclick="closeNav()">Page Tables</a></li>
            <li><a href="#tlb" onclick="closeNav()">Translation Lookaside Buffer</a></li>
            <li><a href="#demand-paging" onclick="closeNav()">Demand Paging</a></li>
            <li><a href="#page-faults" onclick="closeNav()">Page Faults</a></li>
            <li><a href="#replacement" onclick="closeNav()">Page Replacement Algorithms</a></li>
            <li><a href="#thrashing" onclick="closeNav()">Thrashing</a></li>
            <li><a href="#memory-mapped" onclick="closeNav()">Memory-Mapped Files</a></li>
            <li><a href="#conclusion" onclick="closeNav()">Conclusion & Next Steps</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-layer-group me-2 text-teal"></i>Introduction</h2>
                    <p>Virtual memory creates the illusion that each process has its own large, contiguous address space. This abstraction enables memory protection, process isolation, and efficient memory utilization.</p>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-sitemap me-2"></i>
                        <strong>Series Context:</strong> This is <strong>Part 16 of 24</strong> in the Computer Architecture & Operating Systems Mastery series. Building on memory management fundamentals, we explore virtual memory in depth.
                    </div>

                    <div class="experiment-card" id="series-nav">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">24-Part Series</span>
                            <span class="badge bg-crimson">Computer Architecture & OS Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="comp-arch-foundations.html"><strong>Part 1:</strong> Foundations of Computer Systems</a> — System overview, architectures, OS role</li>
                                <li><a href="comp-arch-digital-logic.html"><strong>Part 2:</strong> Digital Logic & CPU Building Blocks</a> — Gates, registers, datapath, microarchitecture</li>
                                <li><a href="comp-arch-isa.html"><strong>Part 3:</strong> Instruction Set Architecture (ISA)</a> — RISC vs CISC, instruction formats, addressing</li>
                                <li><a href="comp-arch-assembly.html"><strong>Part 4:</strong> Assembly Language & Machine Code</a> — Registers, stack, calling conventions</li>
                                <li><a href="comp-arch-linkers-loaders.html"><strong>Part 5:</strong> Assemblers, Linkers & Loaders</a> — Object files, ELF, dynamic linking</li>
                                <li><a href="comp-arch-compilers.html"><strong>Part 6:</strong> Compilers & Program Translation</a> — Lexing, parsing, code generation</li>
                                <li><a href="comp-arch-cpu-pipelining.html"><strong>Part 7:</strong> CPU Execution & Pipelining</a> — Fetch-decode-execute, hazards, prediction</li>
                                <li><a href="comp-arch-os-kernel.html"><strong>Part 8:</strong> OS Architecture & Kernel Design</a> — Monolithic, microkernel, system calls</li>
                                <li><a href="comp-arch-processes.html"><strong>Part 9:</strong> Processes & Program Execution</a> — Process lifecycle, PCB, fork/exec</li>
                                <li><a href="comp-arch-threads-concurrency.html"><strong>Part 10:</strong> Threads & Concurrency</a> — Threading models, pthreads, race conditions</li>
                                <li><a href="comp-arch-cpu-scheduling.html"><strong>Part 11:</strong> CPU Scheduling Algorithms</a> — FCFS, RR, CFS, real-time scheduling</li>
                                <li><a href="comp-arch-synchronization.html"><strong>Part 12:</strong> Synchronization & Coordination</a> — Locks, semaphores, classic problems</li>
                                <li><a href="comp-arch-deadlocks.html"><strong>Part 13:</strong> Deadlocks & Prevention</a> — Coffman conditions, Banker's algorithm</li>
                                <li><a href="comp-arch-cache-memory-hierarchy.html"><strong>Part 14:</strong> Memory Hierarchy & Cache</a> — L1/L2/L3, cache coherence, NUMA</li>
                                <li><a href="comp-arch-memory-management.html"><strong>Part 15:</strong> Memory Management Fundamentals</a> — Address spaces, fragmentation, allocation</li>
                                <li><strong>Part 16: Virtual Memory & Paging (This Guide)</strong> — Page tables, TLB, demand paging</li>
                                <li><a href="comp-arch-file-systems.html"><strong>Part 17:</strong> File Systems & Storage</a> — Inodes, journaling, ext4, NTFS</li>
                                <li><a href="comp-arch-io-devices.html"><strong>Part 18:</strong> I/O Systems & Device Drivers</a> — Interrupts, DMA, disk scheduling</li>
                                <li><a href="comp-arch-multiprocessor.html"><strong>Part 19:</strong> Multiprocessor Systems</a> — SMP, NUMA, cache coherence</li>
                                <li><a href="comp-arch-security.html"><strong>Part 20:</strong> OS Security & Protection</a> — Privilege levels, ASLR, sandboxing</li>
                                <li><a href="comp-arch-virtualization.html"><strong>Part 21:</strong> Virtualization & Containers</a> — Hypervisors, namespaces, cgroups</li>
                                <li><a href="comp-arch-kernel-internals.html"><strong>Part 22:</strong> Advanced Kernel Internals</a> — Linux subsystems, kernel debugging</li>
                                <li><a href="comp-arch-case-studies.html"><strong>Part 23:</strong> Case Studies</a> — Linux vs Windows vs macOS</li>
                                <li><a href="comp-arch-capstone-projects.html"><strong>Part 24:</strong> Capstone Projects</a> — Shell, thread pool, paging simulator</li>
                            </ol>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-question-circle me-2"></i>
                        <strong>The Magic of Virtual Memory:</strong> Every process thinks it has 256 TB of contiguous memory, even on a machine with 16 GB RAM. How? Virtual memory creates this powerful illusion.
                    </div>
                </div>

                <div id="virtual-addressing" class="blog-content mt-5">
                    <h2><i class="fas fa-map-marker-alt me-2 text-teal"></i>Virtual Addressing</h2>
                    
                    <p>Virtual memory gives each process its own <strong>private address space</strong>, mapped to physical memory by the MMU (Memory Management Unit).</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-eye me-2"></i>Virtual Memory Benefits</h4>
                        <div class="content">
<pre class="language-text"><code>Why Virtual Memory?
══════════════════════════════════════════════════════════════

1. ISOLATION
   • Each process has private address space
   • Process A cannot access Process B's memory
   • Buggy program can't crash the whole system

2. ABSTRACTION
   • Programs don't need to know physical addresses
   • Same virtual addresses work on any machine
   • Simplifies programming model

3. EFFICIENT MEMORY USE
   • Only active pages need physical RAM
   • Inactive pages can live on disk (swap)
   • Sparse address spaces don't waste RAM

4. SHARING
   • Multiple processes can share same physical pages
   • Shared libraries loaded once, mapped many times
   • fork() uses copy-on-write (COW)

5. FLEXIBILITY
   • Memory can be relocated without program changes
   • OS can defragment physical memory transparently


64-bit Virtual Address Space:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
0xFFFFFFFFFFFFFFFF ┌─────────────────────┐
                   │    Kernel Space     │ (upper half)
                   │                     │
0xFFFF800000000000 ├─────────────────────┤
                   │    (non-canonical)  │ Hole - unused
0x00007FFFFFFFFFFF ├─────────────────────┤
                   │     User Space      │ (lower half)
                   │  256 TB available!  │
0x0000000000000000 └─────────────────────┘</code></pre>
                        </div>
                    </div>
                </div>

                <div id="page-tables" class="blog-content mt-5">
                    <h2><i class="fas fa-table me-2 text-teal"></i>Page Tables</h2>
                    
                    <p>The <strong>page table</strong> maps virtual pages to physical frames. Modern systems use multi-level page tables to save memory.</p>

<pre class="language-text"><code>Page Table Entry (PTE):
══════════════════════════════════════════════════════════════

┌───────────────────────────────────────────────────────────┐
│  Frame Number (40 bits)  │ Flags (12 bits)               │
└───────────────────────────────────────────────────────────┘

Common Flag Bits:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Bit   Name      Meaning
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 0    Present   Page is in physical memory (not swapped)
 1    R/W       0=read-only, 1=read-write
 2    U/S       0=supervisor only, 1=user accessible
 3    PWT       Page-level write-through
 4    PCD       Page-level cache disable
 5    Accessed  Page was read (set by hardware)
 6    Dirty     Page was written (set by hardware)
 7    PAT       Page Attribute Table
 8    Global    Don't flush from TLB on context switch
63    NX        No-execute (prevent code execution)


4-Level Page Table (x86-64):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Virtual Address (48 bits used):
┌────────┬────────┬────────┬────────┬──────────┐
│ PML4   │  PDPT  │   PD   │   PT   │  Offset  │
│ 9 bits │ 9 bits │ 9 bits │ 9 bits │ 12 bits  │
└────────┴────────┴────────┴────────┴──────────┘

       CR3 (Page Table Base)
         │
         ▼
    ┌─────────┐
    │  PML4   │ ─── 512 entries
    └────┬────┘
         │ [PML4 index]
         ▼
    ┌─────────┐
    │  PDPT   │ ─── 512 entries
    └────┬────┘
         │ [PDPT index]
         ▼
    ┌─────────┐
    │   PD    │ ─── 512 entries
    └────┬────┘
         │ [PD index]
         ▼
    ┌─────────┐
    │   PT    │ ─── 512 entries
    └────┬────┘
         │ [PT index]
         ▼
    Physical Frame + Offset = Physical Address</code></pre>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Why Multi-Level?</strong> Single-level table for 48-bit addresses with 4KB pages would need 2^36 entries × 8 bytes = 512 GB per process! Multi-level only allocates tables for used regions.
                    </div>
                </div>

                <div id="tlb" class="blog-content mt-5">
                    <h2><i class="fas fa-bolt me-2 text-teal"></i>Translation Lookaside Buffer (TLB)</h2>
                    
                    <p>The <strong>TLB</strong> is a cache for page table entries. Without it, every memory access would require 4 extra memory accesses!</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-microchip me-2"></i>TLB Operation</h4>
                        <div class="content">
<pre class="language-text"><code>TLB Lookup Process:
══════════════════════════════════════════════════════════════

                        ┌─────────────┐
Virtual Address ───────→│    TLB      │
                        │   Cache     │
                        └──────┬──────┘
                               │
              ┌────────────────┼────────────────┐
              │                │                │
           TLB HIT         TLB MISS         TLB MISS
         (~1 cycle)      (hardware)        (software)
              │                │                │
              ▼                ▼                ▼
        Get frame#       Page Table        OS Handler
        immediately       Walk            (older CPUs)
                       (15-30 cycles)
                               │
                               ▼
                        Update TLB
                               │
                               ▼
                        Physical Address


Typical TLB Specifications:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Component        Entries    Miss Penalty
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
L1 iTLB          64-128     ~7 cycles (L2 TLB hit)
L1 dTLB          64-128     ~7 cycles
L2 TLB (unified) 512-2048   ~30 cycles (page walk)

TLB hit rate typically &gt;99% due to locality!</code></pre>
                        </div>
                    </div>

<pre class="language-bash"><code># View TLB statistics on Linux
$ perf stat -e dTLB-loads,dTLB-load-misses ./my_program
     1,234,567,890      dTLB-loads
           123,456      dTLB-load-misses  # 0.01% miss rate

# Flush TLB (happens on context switch, CR3 reload)
# Each process has different page tables → TLB must be flushed
# PCID (Process Context ID) allows keeping multiple process entries</code></pre>
                </div>

                <div id="demand-paging" class="blog-content mt-5">
                    <h2><i class="fas fa-hand-paper me-2 text-teal"></i>Demand Paging</h2>
                    
                    <p><strong>Demand paging</strong> loads pages into memory only when accessed. No need to load entire program at startup!</p>

<pre class="language-text"><code>Demand Paging Concept:
══════════════════════════════════════════════════════════════

Traditional (Eager) Loading:
┌─────────────────────────────────────────────────────────────┐
│ Load ALL pages of program into RAM before starting          │
│ • Slow startup                                              │
│ • Wastes memory on unused code paths                        │
└─────────────────────────────────────────────────────────────┘

Demand Paging (Lazy Loading):
┌─────────────────────────────────────────────────────────────┐
│ Load pages ONLY when accessed (page fault triggers load)    │
│ • Fast startup (load only what's needed)                    │
│ • Memory efficient (unused pages never loaded)              │
└─────────────────────────────────────────────────────────────┘


Page States:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Not in memory, not on disk
   • Uninitialized (zero page on first access)
   
2. Not in memory, on disk
   • Swapped out, or file-backed but not loaded
   • Page fault → load from disk
   
3. In memory, clean
   • Loaded and unmodified
   • Can be discarded (file-backed) or swapped
   
4. In memory, dirty
   • Modified since load
   • Must write to disk before eviction</code></pre>
                </div>

                <div id="page-faults" class="blog-content mt-5">
                    <h2><i class="fas fa-exclamation-circle me-2 text-teal"></i>Page Faults</h2>
                    
                    <p>A <strong>page fault</strong> occurs when accessing a page not in physical memory. The OS handles it and resumes execution.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-cog me-2"></i>Page Fault Handling</h4>
                        <div class="content">
<pre class="language-text"><code>Page Fault Sequence:
══════════════════════════════════════════════════════════════

1. CPU executes instruction accessing virtual address
2. MMU checks TLB - MISS
3. MMU walks page table - finds Present bit = 0
4. MMU raises PAGE FAULT exception
5. CPU traps to OS page fault handler

6. OS determines fault type:
   ┌─────────────────────────────────────────────────────────┐
   │ VALID PAGE FAULT (legitimate, recoverable):            │
   │ • Page swapped out → load from swap                    │
   │ • File-backed page → load from file                    │
   │ • Zero page (BSS) → allocate zeroed frame              │
   │ • Copy-on-write → copy page, update mapping            │
   ├─────────────────────────────────────────────────────────┤
   │ INVALID PAGE FAULT (error, unrecoverable):             │
   │ • Address not in process's address space               │
   │ • Permission violation (write to read-only)            │
   │ → Send SIGSEGV (segmentation fault) to process         │
   └─────────────────────────────────────────────────────────┘

7. For valid fault:
   a. Find free frame (may need to evict another page)
   b. Load page into frame (I/O - SLOW!)
   c. Update page table entry (Present=1, frame number)
   d. Resume faulting instruction


Page Fault Cost:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
SSD page fault:  ~50-100 microseconds
HDD page fault:  ~5-10 milliseconds
Memory access:   ~100 nanoseconds

Page fault is 1000-100,000× slower than memory access!</code></pre>
                        </div>
                    </div>
                </div>

                <div id="replacement" class="blog-content mt-5">
                    <h2><i class="fas fa-exchange-alt me-2 text-teal"></i>Page Replacement Algorithms</h2>
                    
                    <p>When RAM is full, which page do we evict? The <strong>page replacement algorithm</strong> decides.</p>

<pre class="language-text"><code>Page Replacement Algorithms:
══════════════════════════════════════════════════════════════

1. OPTIMAL (OPT) - Theoretical best
   • Evict page that won't be used for longest time
   • Requires future knowledge - impossible in practice!
   • Used as benchmark for other algorithms

2. FIFO (First-In, First-Out)
   • Evict oldest page
   • Simple queue implementation
   • Belady's Anomaly: More frames can cause MORE faults!

3. LRU (Least Recently Used)
   • Evict page unused for longest time
   • Good approximation of OPT (uses past as future predictor)
   • Expensive: must track access order

4. CLOCK (Second Chance)
   • Approximates LRU with less overhead
   • Pages arranged in circular list with reference bit
   • On eviction: if ref=1, clear and skip; if ref=0, evict


CLOCK Algorithm Visualization:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        ┌──── Clock hand (victim pointer)
        ▼
    ┌───────┐
    │ P1: 1 │ ← Reference bit = 1 (recently used)
    └───────┘
   /         \
┌───────┐   ┌───────┐
│ P4: 0 │   │ P2: 1 │
└───────┘   └───────┘
   \         /
    ┌───────┐
    │ P3: 0 │ ← ref=0, EVICT this page!
    └───────┘

Hardware sets reference bit on access.
OS clears bits during clock sweep.</code></pre>

<pre class="language-bash"><code># View page replacement statistics on Linux
$ vmstat 1
procs -----------memory---------- ---swap-- -----io----
 r  b   swpd   free   buff  cache   si   so    bi    bo
 1  0  12345  98765  54321 234567    0    5   100    50
                                     ↑    ↑
                                  swap  swap
                                  in    out

# si (swap in) = pages loaded from swap
# so (swap out) = pages written to swap (evicted)</code></pre>
                </div>

                <div id="thrashing" class="blog-content mt-5">
                    <h2><i class="fas fa-tachometer-alt me-2 text-teal"></i>Thrashing</h2>
                    
                    <p><strong>Thrashing</strong> occurs when the system spends more time paging than executing. Performance collapses.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-chart-line me-2"></i>Thrashing Behavior</h4>
                        <div class="content">
<pre class="language-text"><code>Thrashing:
══════════════════════════════════════════════════════════════

CPU Utilization vs Degree of Multiprogramming:

     CPU Utilization
     │
100% │           ┌───────┐
     │          /         \
     │         /           \
     │        /             \
     │       /               \  ← Thrashing!
     │      /                 \
     │     /                   \
  0% │────/─────────────────────\────────
     └───────────────────────────────────→
           # of Processes
              ↑
         Optimal point


What Causes Thrashing:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Too many processes competing for limited RAM
2. Each process's working set &gt; available memory
3. Pages constantly swapped in and out
4. I/O wait dominates CPU time

Working Set: Pages a process actively uses in a time window.
If Σ(working sets) &gt; physical RAM → Thrashing!


Solutions:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Add more RAM (hardware solution)
2. Kill memory-hungry processes
3. Reduce degree of multiprogramming (swap out entire processes)
4. Use working set model for scheduling
5. Page fault frequency (PFF) control:
   - High fault rate → give more frames
   - Low fault rate → take away frames</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Linux OOM Killer:</strong> When memory is critically low, Linux's Out-Of-Memory killer selects and terminates processes. Check <code>dmesg</code> for "Out of memory: Kill process" messages.
                    </div>
                </div>

                <div id="memory-mapped" class="blog-content mt-5">
                    <h2><i class="fas fa-file-code me-2 text-teal"></i>Memory-Mapped Files</h2>
                    
                    <p><strong>Memory-mapped files</strong> map file contents directly into virtual address space. Access file like memory!</p>

<pre class="language-c"><code>/* Memory-Mapped File Example */
#include &lt;sys/mman.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int fd = open("data.bin", O_RDWR);
    
    /* Map file into memory */
    char *data = mmap(
        NULL,           /* Let OS choose address */
        4096,           /* Map 4KB */
        PROT_READ | PROT_WRITE,  /* Read/write access */
        MAP_SHARED,     /* Changes written back to file */
        fd,             /* File descriptor */
        0               /* Offset in file */
    );
    
    /* Access file like memory! */
    printf("First byte: %c\n", data[0]);
    data[0] = 'X';  /* Modify - will be written to file */
    
    /* Unmap when done */
    munmap(data, 4096);
    close(fd);
    return 0;
}

/*
Benefits:
- No explicit read()/write() calls
- Kernel handles caching efficiently
- Multiple processes can share mapping
- Perfect for large files (only load needed pages)

Use cases:
- Database engines
- Shared libraries (.so files)
- Inter-process communication
*/</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Shared Libraries:</strong> When you link against libc.so, it's memory-mapped into your process. Since the code is read-only, all processes share the SAME physical pages—saving huge amounts of RAM!
                    </div>
                </div>

                <div id="conclusion" class="blog-content mt-5">
                    <h2><i class="fas fa-flag-checkered me-2 text-teal"></i>Conclusion & Next Steps</h2>
                    
                    <p>Virtual memory is a cornerstone of modern operating systems. We've covered:</p>
                    
                    <ul>
                        <li><strong>Virtual Addressing:</strong> Process isolation and flexibility</li>
                        <li><strong>Page Tables:</strong> Multi-level translation structures</li>
                        <li><strong>TLB:</strong> Critical cache for address translation</li>
                        <li><strong>Demand Paging:</strong> Load pages only when needed</li>
                        <li><strong>Page Faults:</strong> Exception handling and recovery</li>
                        <li><strong>Page Replacement:</strong> FIFO, LRU, Clock algorithms</li>
                        <li><strong>Thrashing:</strong> When paging overwhelms the system</li>
                        <li><strong>Memory-Mapped Files:</strong> File I/O through memory</li>
                    </ul>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Key Insight:</strong> Virtual memory is all about indirection—separating what the program sees from physical reality. This indirection enables isolation, efficiency, and powerful features like copy-on-write.
                    </div>

                    <div class="series-next">
                        <h4><i class="fas fa-arrow-right me-2"></i>Next in the Series</h4>
                        <p>In <a href="comp-arch-file-systems.html"><strong>Part 17: File Systems & Storage</strong></a>, we'll explore how operating systems organize and manage persistent data—inodes, directories, journaling, and modern file systems.</p>
                    </div>
                </div>

                <div class="related-posts">
                    <h3><i class="fas fa-book me-2"></i>Continue the Computer Architecture & OS Series</h3>
                    <div class="related-post-item">
                        <h5>Part 15: Memory Management Fundamentals</h5>
                        <p>Address spaces, fragmentation, and allocation strategies.</p>
                        <a href="comp-arch-memory-management.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 17: File Systems & Storage</h5>
                        <p>Inodes, journaling, ext4, and NTFS.</p>
                        <a href="comp-arch-file-systems.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 24: Capstone Projects</h5>
                        <p>Build a paging simulator project.</p>
                        <a href="comp-arch-capstone-projects.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    <div id="categoryIndicator" class="category-indicator"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="../../../js/main.js"></script>
    <script src="../../../js/cookie-consent.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    <script>
        const themes = { 'prism-theme': 'Tomorrow Night', 'prism-default': 'Default', 'prism-dark': 'Dark', 'prism-twilight': 'Twilight', 'prism-okaidia': 'Okaidia', 'prism-solarizedlight': 'Solarized Light' };
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        function switchTheme(themeId) { Object.keys(themes).forEach(id => { const link = document.getElementById(id); if (link) link.disabled = true; }); const selectedLink = document.getElementById(themeId); if (selectedLink) { selectedLink.disabled = false; localStorage.setItem('prism-theme', themeId); } document.querySelectorAll('div.code-toolbar select').forEach(dropdown => { dropdown.value = themeId; }); setTimeout(() => Prism.highlightAll(), 10); }
        document.addEventListener('DOMContentLoaded', function() { switchTheme(savedTheme); });
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) { const select = document.createElement('select'); select.setAttribute('aria-label', 'Select code theme'); Object.keys(themes).forEach(themeId => { const option = document.createElement('option'); option.value = themeId; option.textContent = themes[themeId]; if (themeId === savedTheme) option.selected = true; select.appendChild(option); }); select.addEventListener('change', function(e) { switchTheme(e.target.value); }); return select; });
    </script>
</body>
</html>
