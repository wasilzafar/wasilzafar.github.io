<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 7: CPU Execution & Pipelining - Learn about fetch-decode-execute cycle, pipeline stages, hazards, and branch prediction techniques." />
    <meta name="keywords" content="CPU pipelining, fetch decode execute, instruction cycle, pipeline stages, pipeline hazards, branch prediction, data hazards, control hazards, CPU execution" />
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Part 7: CPU Execution & Pipelining | Computer Architecture & OS Mastery" />
    <meta property="og:description" content="Master CPU execution: fetch-decode-execute cycle, pipeline stages, hazard detection, and branch prediction strategies." />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://wasilzafar.com/pages/series/computer-architecture/comp-arch-cpu-pipelining.html" />
    <meta property="article:published_time" content="2026-01-31" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />

    <title>Part 7: CPU Execution & Pipelining | Computer Architecture & OS Mastery - Wasil Zafar</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <!-- Prism.js Syntax Highlighting - Multiple Themes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <!-- Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE']
        });
        gtag('consent', 'default', {
            'ad_storage': 'granted',
            'ad_user_data': 'granted',
            'ad_personalization': 'granted',
            'analytics_storage': 'granted'
        });
        gtag('set', 'url_passthrough', true);
    </script>

    <!-- Google Tag Manager -->
    <script>
        (function(w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript>
        <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>

    <!-- GDPR Cookie Consent Banner -->
    <div id="cookieBanner" class="light display-bottom" style="display: none;">
        <div id="closeIcon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                <path fill="currentColor" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"></path>
            </svg>
        </div>
        
        <div class="content-wrap">
            <div class="msg-wrap">
                <div class="title-wrap">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="20" height="20">
                        <path fill="#3B9797" d="M510.52 255.82c-69.97-.85-126.47-57.69-126.47-127.86-70.17 0-127-56.49-127.86-126.45-27.26-4.14-55.13.3-79.72 12.82l-69.13 35.22a132.221 132.221 0 0 0-57.79 57.81l-35.1 68.88a132.645 132.645 0 0 0-12.82 80.95l12.08 76.27a132.521 132.521 0 0 0 37.16 70.37l54.64 54.64a132.036 132.036 0 0 0 70.37 37.16l76.27 12.15c27.51 4.36 55.7-.11 80.95-12.8l68.88-35.08a132.166 132.166 0 0 0 57.79-57.81l35.1-68.88c12.56-24.64 17.01-52.58 12.91-79.91zM176 368c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32zm32-160c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32zm160 128c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32z"></path>
                    </svg>
                    <h4 style="margin: 0; font-size: 18px; color: var(--color-navy); font-weight: 700;">Cookie Consent</h4>
                </div>
                <p style="font-size: 14px; line-height: 1.6; color: var(--color-navy); margin-bottom: 15px;">
                    We use cookies to enhance your browsing experience, serve personalized content, and analyze our traffic. 
                    By clicking "Accept All", you consent to our use of cookies. See our 
                    <a href="/privacy-policy.html" style="color: var(--color-teal); border-bottom: 1px dotted var(--color-teal);">Privacy Policy</a> 
                    for more information.
                </p>
                
                <div id="cookieSettings" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="14" height="14">
                        <path fill="currentColor" d="M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z"></path>
                    </svg>
                    <span style="margin-left: 5px; font-size: 12px; font-weight: 600; color: var(--color-navy);">Customize Settings</span>
                </div>
                
                <div id="cookieTypes" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(59, 151, 151, 0.2);">
                    <h5 style="font-size: 12px; font-weight: 700; color: var(--color-navy); margin-bottom: 10px; text-transform: uppercase;">Cookie Preferences</h5>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" checked disabled style="margin-top: 2px; margin-right: 8px; cursor: not-allowed;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Essential Cookies (Required)</strong>
                                <span style="font-size: 12px; color: #666;">Necessary for the website to function properly.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" id="analyticsCookies" checked style="margin-top: 2px; margin-right: 8px;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Analytics Cookies</strong>
                                <span style="font-size: 12px; color: #666;">Help us understand how you interact with the website.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" id="marketingCookies" style="margin-top: 2px; margin-right: 8px;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Marketing Cookies</strong>
                                <span style="font-size: 12px; color: #666;">Used to deliver relevant advertisements.</span>
                            </div>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="btn-wrap">
                <button id="cookieAccept" style="background: var(--color-teal); color: white; font-weight: 600;">Accept All</button>
                <button id="cookieReject" style="background: transparent; color: var(--color-navy); border: 2px solid var(--color-teal); font-weight: 600;">Reject All</button>
                <button id="cookieSave" style="background: var(--color-blue); color: white; font-weight: 600; display: none;">Save Preferences</button>
            </div>
        </div>
    </div>

    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/">
                <span class="gradient-text">Wasil Zafar</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#about">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#skills">Skills</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#certifications">Certifications</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#interests">Interests</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Blog Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <a href="../../categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
            <h1 class="display-4 fw-bold mt-4">Part 7: CPU Execution & Pipelining</h1>
            <div class="blog-meta">
                <span><i class="fas fa-calendar me-2"></i>January 31, 2026</span>
                <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                <span class="reading-time"><i class="fas fa-clock me-1"></i>28 min read</span>
                <button onclick="window.print()" class="print-btn" title="Print this article"><i class="fas fa-print"></i> Print</button>
            </div>
            <p class="lead mt-3">Master CPU execution fundamentals—the fetch-decode-execute cycle, pipeline stages, hazard detection and resolution, and branch prediction techniques.</p>
        </div>
    </section>

    <!-- Table of Contents Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation TOC -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li>
                <a href="#introduction" onclick="closeNav()">Introduction</a>
            </li>
            <li>
                <a href="#instruction-cycle" onclick="closeNav()">Instruction Cycle</a>
                <ul>
                    <li><a href="#fetch-stage" onclick="closeNav()">Fetch Stage</a></li>
                    <li><a href="#decode-stage" onclick="closeNav()">Decode Stage</a></li>
                    <li><a href="#execute-stage" onclick="closeNav()">Execute Stage</a></li>
                    <li><a href="#memory-writeback" onclick="closeNav()">Memory & Writeback</a></li>
                </ul>
            </li>
            <li>
                <a href="#pipeline-stages" onclick="closeNav()">Pipeline Stages</a>
                <ul>
                    <li><a href="#classic-5-stage" onclick="closeNav()">Classic 5-Stage Pipeline</a></li>
                    <li><a href="#pipeline-throughput" onclick="closeNav()">Pipeline Throughput</a></li>
                    <li><a href="#deep-pipelines" onclick="closeNav()">Deep Pipelines</a></li>
                </ul>
            </li>
            <li>
                <a href="#pipeline-hazards" onclick="closeNav()">Pipeline Hazards</a>
                <ul>
                    <li><a href="#data-hazards" onclick="closeNav()">Data Hazards</a></li>
                    <li><a href="#control-hazards" onclick="closeNav()">Control Hazards</a></li>
                    <li><a href="#structural-hazards" onclick="closeNav()">Structural Hazards</a></li>
                    <li><a href="#hazard-resolution" onclick="closeNav()">Hazard Resolution</a></li>
                </ul>
            </li>
            <li>
                <a href="#branch-prediction" onclick="closeNav()">Branch Prediction</a>
                <ul>
                    <li><a href="#static-prediction" onclick="closeNav()">Static Prediction</a></li>
                    <li><a href="#dynamic-prediction" onclick="closeNav()">Dynamic Prediction</a></li>
                    <li><a href="#branch-target-buffer" onclick="closeNav()">Branch Target Buffer</a></li>
                </ul>
            </li>
            <li><a href="#conclusion" onclick="closeNav()">Conclusion & Next Steps</a></li>
        </ol>
    </div>

    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Main Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <!-- Introduction -->
                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-microchip me-2 text-teal"></i>Introduction</h2>
                    
                    <p>CPU pipelining is a fundamental technique that allows processors to execute multiple instructions simultaneously by overlapping their execution stages. Understanding pipelining reveals how modern CPUs achieve high throughput despite instruction-level dependencies.</p>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-sitemap me-2"></i>
                        <strong>Series Context:</strong> This is <strong>Part 7 of 24</strong> in the Computer Architecture & Operating Systems Mastery series. Building on compilers and program translation, we now explore how CPUs execute instructions efficiently through pipelining.
                    </div>

                    <div class="experiment-card" id="series-nav">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">24-Part Series</span>
                            <span class="badge bg-crimson">Computer Architecture & OS Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="comp-arch-foundations.html"><strong>Part 1:</strong> Foundations of Computer Systems</a> — System overview, architectures, OS role</li>
                                <li><a href="comp-arch-digital-logic.html"><strong>Part 2:</strong> Digital Logic & CPU Building Blocks</a> — Gates, registers, datapath, microarchitecture</li>
                                <li><a href="comp-arch-isa.html"><strong>Part 3:</strong> Instruction Set Architecture (ISA)</a> — RISC vs CISC, instruction formats, addressing</li>
                                <li><a href="comp-arch-assembly.html"><strong>Part 4:</strong> Assembly Language & Machine Code</a> — Registers, stack, calling conventions</li>
                                <li><a href="comp-arch-linkers-loaders.html"><strong>Part 5:</strong> Assemblers, Linkers & Loaders</a> — Object files, ELF, dynamic linking</li>
                                <li><a href="comp-arch-compilers.html"><strong>Part 6:</strong> Compilers & Program Translation</a> — Lexing, parsing, code generation</li>
                                <li><strong>Part 7: CPU Execution & Pipelining (This Guide)</strong> — Fetch-decode-execute, hazards, prediction</li>
                                <li><a href="comp-arch-os-kernel.html"><strong>Part 8:</strong> OS Architecture & Kernel Design</a> — Monolithic, microkernel, system calls</li>
                                <li><a href="comp-arch-processes.html"><strong>Part 9:</strong> Processes & Program Execution</a> — Process lifecycle, PCB, fork/exec</li>
                                <li><a href="comp-arch-threads-concurrency.html"><strong>Part 10:</strong> Threads & Concurrency</a> — Threading models, pthreads, race conditions</li>
                                <li><a href="comp-arch-cpu-scheduling.html"><strong>Part 11:</strong> CPU Scheduling Algorithms</a> — FCFS, RR, CFS, real-time scheduling</li>
                                <li><a href="comp-arch-synchronization.html"><strong>Part 12:</strong> Synchronization & Coordination</a> — Locks, semaphores, classic problems</li>
                                <li><a href="comp-arch-deadlocks.html"><strong>Part 13:</strong> Deadlocks & Prevention</a> — Coffman conditions, Banker's algorithm</li>
                                <li><a href="comp-arch-cache-memory-hierarchy.html"><strong>Part 14:</strong> Memory Hierarchy & Cache</a> — L1/L2/L3, cache coherence, NUMA</li>
                                <li><a href="comp-arch-memory-management.html"><strong>Part 15:</strong> Memory Management Fundamentals</a> — Address spaces, fragmentation, allocation</li>
                                <li><a href="comp-arch-virtual-memory.html"><strong>Part 16:</strong> Virtual Memory & Paging</a> — Page tables, TLB, demand paging</li>
                                <li><a href="comp-arch-file-systems.html"><strong>Part 17:</strong> File Systems & Storage</a> — Inodes, journaling, ext4, NTFS</li>
                                <li><a href="comp-arch-io-devices.html"><strong>Part 18:</strong> I/O Systems & Device Drivers</a> — Interrupts, DMA, disk scheduling</li>
                                <li><a href="comp-arch-multiprocessor.html"><strong>Part 19:</strong> Multiprocessor Systems</a> — SMP, NUMA, cache coherence</li>
                                <li><a href="comp-arch-security.html"><strong>Part 20:</strong> OS Security & Protection</a> — Privilege levels, ASLR, sandboxing</li>
                                <li><a href="comp-arch-virtualization.html"><strong>Part 21:</strong> Virtualization & Containers</a> — Hypervisors, namespaces, cgroups</li>
                                <li><a href="comp-arch-kernel-internals.html"><strong>Part 22:</strong> Advanced Kernel Internals</a> — Linux subsystems, kernel debugging</li>
                                <li><a href="comp-arch-case-studies.html"><strong>Part 23:</strong> Case Studies</a> — Linux vs Windows vs macOS</li>
                                <li><a href="comp-arch-capstone-projects.html"><strong>Part 24:</strong> Capstone Projects</a> — Shell, thread pool, paging simulator</li>
                            </ol>
                        </div>
                    </div>

                    <!-- CONTENT PLACEHOLDER -->
                    <h3>The Assembly Line Analogy</h3>
                    <p>Imagine a car factory where each vehicle takes 5 hours to build. Without pipelining, you'd build one car at a time—5 hours per car, or only 4.8 cars per day (24/5).</p>

                    <p>Now imagine splitting the work into 5 stations (1 hour each): frame, engine, interior, paint, inspection. While station 2 works on Car A's engine, station 1 starts Car B's frame. After initial warm-up, you complete one car every hour—24 cars per day! That's a 5x throughput increase.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-industry me-2"></i>Pipeline Throughput Improvement</h4>
                        <div class="content">
<pre class="language-text"><code>Without Pipeline (Sequential Execution):
══════════════════════════════════════════════════════════════
Time:    1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
Car A:  [F] [E] [I] [P] [Q]
Car B:                      [F] [E] [I] [P] [Q]
Car C:                                          [F] [E] [I] [P] [Q]

→ 15 hours for 3 cars


With 5-Stage Pipeline:
══════════════════════════════════════════════════════════════
Time:    1   2   3   4   5   6   7   8   9
Car A:  [F] [E] [I] [P] [Q]               ← Done at T=5
Car B:      [F] [E] [I] [P] [Q]           ← Done at T=6
Car C:          [F] [E] [I] [P] [Q]       ← Done at T=7
Car D:              [F] [E] [I] [P] [Q]   ← Done at T=8
Car E:                  [F] [E] [I] [P] [Q] ← Done at T=9

→ 9 hours for 5 cars (vs 25 hours sequential)

Pipeline stages: F=Frame, E=Engine, I=Interior, P=Paint, Q=Quality Check

After "filling" the pipeline (T=5), one car completes every cycle!</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb me-2"></i>
                        <strong>Key Insight:</strong> Pipelining doesn't make individual instructions faster (latency stays the same). It increases <em>throughput</em>—how many instructions complete per unit time. In the ideal case, an N-stage pipeline achieves N× throughput improvement.
                    </div>

                </div>

                <!-- Instruction Cycle Section -->
                <div id="instruction-cycle" class="blog-content mt-5">
                    <h2><i class="fas fa-sync-alt me-2 text-teal"></i>Instruction Cycle</h2>
                    
                    <p>Every instruction goes through the same basic cycle: <strong>fetch</strong> the instruction from memory, <strong>decode</strong> what it means, <strong>execute</strong> the operation, access <strong>memory</strong> if needed, and <strong>write back</strong> the result. This is the foundation of all CPU execution.</p>

                    <h3 id="fetch-stage">Fetch Stage</h3>
                    
                    <p>The <strong>Instruction Fetch (IF)</strong> stage retrieves the next instruction from memory using the Program Counter (PC).</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-download me-2"></i>Fetch Stage Operations</h4>
                        <div class="content">
<pre class="language-text"><code>Fetch Stage (IF):
══════════════════════════════════════════════════════════════
                    ┌─────────────────┐
    PC ────────────→│  Instruction    │────→ IR (Instruction Register)
   (addr)           │    Memory       │
                    └─────────────────┘
                            ↑
                            │
         ┌──────────────────┘
         │
    PC = PC + 4   (or + instruction_length)


Operations:
1. Send PC value to instruction memory/cache
2. Read instruction at that address
3. Store instruction in Instruction Register (IR)
4. Increment PC to point to next instruction
   - Normally: PC = PC + 4 (for 32-bit instructions)
   - Branches may override this later

Example (x86-64):
PC = 0x401000
Memory[0x401000] = 48 89 E5    (mov %rsp, %rbp)
IR ← 0x4889E5
PC ← 0x401003 (3-byte instruction)</code></pre>
                        </div>
                    </div>

                    <h3 id="decode-stage">Decode Stage</h3>
                    
                    <p>The <strong>Instruction Decode (ID)</strong> stage interprets the instruction bits, identifies the operation, and reads source registers.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-code me-2"></i>Decode Stage Operations</h4>
                        <div class="content">
<pre class="language-text"><code>Decode Stage (ID):
══════════════════════════════════════════════════════════════
                                    ┌──────────────┐
    IR ─────→ Control Unit ─────────│ Control      │─→ ALU op, MemRead,
             (Instruction           │ Signals      │   MemWrite, RegWrite,
              Decoder)              └──────────────┘   Branch, etc.
                 │
                 │ (register specifiers)
                 ▼
         ┌─────────────────┐
         │ Register File   │
         │   Read Port 1 ──┼──→ Read Data 1 (rs1 value)
         │   Read Port 2 ──┼──→ Read Data 2 (rs2 value)
         └─────────────────┘

Example: ADD R3, R1, R2
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Instruction bits:  | opcode | rd  | rs1 | rs2 | funct |
                   | 0110011| 011 | 001 | 010 | 000   |

Decode outputs:
- Operation: ADD (from opcode + funct)
- Destination: R3
- Read R1 → Data1 = 100
- Read R2 → Data2 = 50
- Control: ALU_OP=ADD, RegWrite=1, MemRead=0, etc.</code></pre>
                        </div>
                    </div>

                    <h3 id="execute-stage">Execute Stage</h3>
                    
                    <p>The <strong>Execute (EX)</strong> stage performs the actual computation using the ALU, calculates addresses, or evaluates branch conditions.</p>

<pre class="language-text"><code>Execute Stage (EX):
══════════════════════════════════════════════════════════════
Read Data 1 ─────┐
                 │     ┌─────────┐
                 ├────→│   ALU   │────→ ALU Result
                 │     │         │
Read Data 2 ─────┤     │ + - * / │
or               │     │ &amp; | ^   │
Immediate  ──────┘     │ &lt; > ==  │
                       └─────────┘
                            │
                            └──→ Zero flag (for branches)

Operation depends on instruction type:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Instruction Type   ALU Operation
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
R-type (ADD)       Result = Data1 + Data2
I-type (ADDI)      Result = Data1 + Immediate
Load (LW)          Address = Base + Offset
Store (SW)         Address = Base + Offset
Branch (BEQ)       Compare Data1 == Data2, compute target
Jump (JAL)         Compute return address (PC+4)</code></pre>

                    <h3 id="memory-writeback">Memory & Writeback</h3>
                    
                    <p>The <strong>Memory (MEM)</strong> stage accesses data memory for loads/stores. The <strong>Write Back (WB)</strong> stage writes results to the register file.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-database me-2"></i>Memory and Write-Back Stages</h4>
                        <div class="content">
<pre class="language-text"><code>Memory Stage (MEM):
══════════════════════════════════════════════════════════════
                    ┌─────────────────┐
ALU Result ────────→│   Data Memory   │
(address)           │                 │
                    │  Read ──────────┼──→ Memory Data (for loads)
Write Data ────────→│  Write          │
(store value)       └─────────────────┘

- Load: Read from address, output to next stage
- Store: Write data to address
- Other instructions: Pass through (no memory access)


Write-Back Stage (WB):
══════════════════════════════════════════════════════════════
                            ┌────────────────┐
ALU Result ─────┬──→ MUX ──→│ Register File  │
                │           │   Write Port   │
Memory Data ────┘           └────────────────┘
                             ↑
                    Destination Register (rd)

- ALU instructions: Write ALU result to rd
- Loads: Write memory data to rd
- Stores/Branches: No write-back (rd unused)</code></pre>
                        </div>
                    </div>

                </div>

                <!-- Pipeline Stages Section -->
                <div id="pipeline-stages" class="blog-content mt-5">
                    <h2><i class="fas fa-stream me-2 text-teal"></i>Pipeline Stages</h2>
                    
                    <h3 id="classic-5-stage">Classic 5-Stage Pipeline</h3>
                    
                    <p>The <strong>classic MIPS 5-stage pipeline</strong> is the canonical example studied in computer architecture. It divides instruction execution into five stages of roughly equal duration.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-layer-group me-2"></i>5-Stage RISC Pipeline</h4>
                        <div class="content">
<pre class="language-text"><code>Classic 5-Stage Pipeline:
══════════════════════════════════════════════════════════════
    IF          ID          EX          MEM         WB
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
│ Fetch   │→│ Decode  │→│ Execute │→│ Memory  │→│ Write   │
│ Instr   │ │ + Read  │ │ ALU     │ │ Access  │ │ Back    │
│         │ │ Regs    │ │         │ │         │ │         │
└─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘
    ↓           ↓           ↓           ↓           ↓
 IF/ID       ID/EX       EX/MEM      MEM/WB
Register   Register    Register    Register
 (latch)    (latch)     (latch)     (latch)


Pipeline Diagram - 5 Instructions:
══════════════════════════════════════════════════════════════
Clock:      1    2    3    4    5    6    7    8    9
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
I1:         IF   ID   EX   MEM  WB
I2:              IF   ID   EX   MEM  WB
I3:                   IF   ID   EX   MEM  WB
I4:                        IF   ID   EX   MEM  WB
I5:                             IF   ID   EX   MEM  WB
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Active      1    2    3    4    5    5    5    5    5
stages

At clock 5: All 5 stages are busy (pipeline is "full")
After warm-up: 1 instruction completes per cycle!</code></pre>
                        </div>
                    </div>

                    <h3 id="pipeline-throughput">Pipeline Throughput</h3>
                    
                    <p>Pipeline performance is measured by <strong>throughput</strong> (instructions per cycle) and <strong>latency</strong> (time for one instruction).</p>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-calculator me-2"></i>
                        <strong>Pipeline Math:</strong>
                        <ul class="mb-0 mt-2">
                            <li><strong>Latency:</strong> N cycles (N = number of stages) for one instruction</li>
                            <li><strong>Throughput:</strong> 1 instruction per cycle (after pipeline is full)</li>
                            <li><strong>Speedup:</strong> Ideally N× over non-pipelined (limited by hazards)</li>
                            <li><strong>CPI (Cycles Per Instruction):</strong> Ideally 1.0 (realistically 1.0-2.0)</li>
                        </ul>
                    </div>

<pre class="language-text"><code>Throughput Calculation:
══════════════════════════════════════════════════════════════
For N instructions in a K-stage pipeline:

Time (non-pipelined) = N × K cycles
Time (pipelined)     = K + (N-1) cycles
                       └─┬─┘  └──┬───┘
                      Warmup   1 instr/cycle

Example: 1000 instructions, 5-stage pipeline
Non-pipelined: 1000 × 5 = 5000 cycles
Pipelined:     5 + 999 = 1004 cycles

Speedup = 5000 / 1004 ≈ 4.98× (approaches 5× for large N)</code></pre>

                    <h3 id="deep-pipelines">Deep Pipelines</h3>
                    
                    <p>Modern CPUs use <strong>deep pipelines</strong> (10-20+ stages) to achieve higher clock frequencies. Each stage does less work, allowing faster clocking.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-ruler-vertical me-2"></i>Pipeline Depth Comparison</h4>
                        <div class="content">
                            <table class="table table-striped">
                                <thead>
                                    <tr><th>Processor</th><th>Pipeline Stages</th><th>Clock Speed</th></tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>MIPS R3000 (1988)</td>
                                        <td>5</td>
                                        <td>25 MHz</td>
                                    </tr>
                                    <tr>
                                        <td>Intel Pentium (1993)</td>
                                        <td>5</td>
                                        <td>66 MHz</td>
                                    </tr>
                                    <tr>
                                        <td>Intel Pentium 4 (2000)</td>
                                        <td>20</td>
                                        <td>1.5 GHz</td>
                                    </tr>
                                    <tr>
                                        <td>Intel Pentium 4 Prescott (2004)</td>
                                        <td>31</td>
                                        <td>3.8 GHz</td>
                                    </tr>
                                    <tr>
                                        <td>Intel Core (2006)</td>
                                        <td>14</td>
                                        <td>2.0 GHz</td>
                                    </tr>
                                    <tr>
                                        <td>Apple M1 (2020)</td>
                                        <td>~16</td>
                                        <td>3.2 GHz</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Deep Pipeline Trade-offs:</strong> More stages = higher clock frequency but also larger branch misprediction penalty (more instructions to flush), more complex hazard handling, and higher power consumption. Intel actually <em>reduced</em> pipeline depth after Pentium 4.
                    </div>

                </div>

                <!-- Pipeline Hazards Section -->
                <div id="pipeline-hazards" class="blog-content mt-5">
                    <h2><i class="fas fa-exclamation-triangle me-2 text-teal"></i>Pipeline Hazards</h2>
                    
                    <p>Hazards are situations that prevent the next instruction from executing in its designated clock cycle. There are three types: <strong>data hazards</strong>, <strong>control hazards</strong>, and <strong>structural hazards</strong>.</p>

                    <h3 id="data-hazards">Data Hazards</h3>
                    
                    <p><strong>Data hazards</strong> occur when instructions depend on results from previous instructions that haven't completed yet. There are three types:</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-exchange-alt me-2"></i>Data Hazard Types (RAW, WAR, WAW)</h4>
                        <div class="content">
<pre class="language-text"><code>1. RAW (Read After Write) - TRUE DEPENDENCY
══════════════════════════════════════════════════════════════
I1:  ADD  R1, R2, R3    # R1 = R2 + R3  (writes R1)
I2:  SUB  R4, R1, R5    # R4 = R1 - R5  (reads R1) ← HAZARD!

Problem: I2 needs R1's new value, but I1 hasn't written it yet

Pipeline view:
       1    2    3    4    5    6
I1:   IF   ID   EX   MEM  WB        ← Writes R1 at cycle 5
I2:        IF   ID   ??             ← Reads R1 at cycle 3!
                  ↑
           Reads OLD value of R1 (incorrect!)


2. WAR (Write After Read) - ANTI-DEPENDENCY
══════════════════════════════════════════════════════════════
I1:  SUB  R4, R1, R3    # R4 = R1 - R3  (reads R1)
I2:  ADD  R1, R2, R5    # R1 = R2 + R5  (writes R1)

Problem: If I2 writes R1 before I1 reads it → wrong value
(Rare in simple 5-stage pipelines, common with out-of-order)


3. WAW (Write After Write) - OUTPUT DEPENDENCY
══════════════════════════════════════════════════════════════
I1:  ADD  R1, R2, R3    # R1 = R2 + R3  (writes R1)
I2:  SUB  R1, R4, R5    # R1 = R4 - R5  (writes R1)

Problem: If I2 writes R1 before I1 → R1 has wrong final value
(Only matters with out-of-order execution or multi-cycle ops)</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Most Common:</strong> RAW hazards are the most frequent in practice. In simple in-order pipelines, WAR and WAW rarely cause issues because instructions complete in order.
                    </div>

                    <h3 id="control-hazards">Control Hazards</h3>
                    
                    <p><strong>Control hazards</strong> (branch hazards) occur when the pipeline doesn't know which instruction to fetch next because a branch decision hasn't been made yet.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-code-branch me-2"></i>Branch Hazard Problem</h4>
                        <div class="content">
<pre class="language-text"><code>Control Hazard Example:
══════════════════════════════════════════════════════════════
    0x100:  BEQ  R1, R2, target    # Branch if R1 == R2
    0x104:  ADD  R3, R4, R5        # Next sequential instruction
    0x108:  SUB  R6, R7, R8
    ...
    0x200:  target: MUL R9, R10, R11   # Branch target

Pipeline:
       1    2    3    4    5
BEQ:  IF   ID   EX   MEM  WB
             ↑
      Branch decision made here (cycle 3)

But we already fetched instructions after BEQ!
       1    2    3    4    5
BEQ:  IF   ID   EX   MEM  WB
ADD:       IF   ID   ← Wrong instruction if branch taken!
SUB:            IF   ← Also wrong!

If branch IS taken:
- Must FLUSH (cancel) ADD and SUB
- Fetch from target (0x200) instead
- Lost 2 cycles = "branch penalty"</code></pre>
                        </div>
                    </div>

                    <h3 id="structural-hazards">Structural Hazards</h3>
                    
                    <p><strong>Structural hazards</strong> occur when hardware resources are insufficient—two instructions need the same resource simultaneously.</p>

<pre class="language-text"><code>Structural Hazard Examples:
══════════════════════════════════════════════════════════════
1. Single Memory Port (common in simple designs):

       1    2    3    4    5
I1:   IF   ID   EX   MEM  WB     ← MEM stage reads data
I4:                  IF          ← IF stage reads instruction
                      ↑
            Both need memory in cycle 4!

Solution: Separate instruction cache (I$) and data cache (D$)
          → Harvard architecture (split caches)


2. Single ALU with Multi-Cycle Operations:

       1    2    3    4    5    6    7
DIV:  IF   ID  EX1  EX2  EX3  MEM  WB   ← Division takes 3 EX cycles
ADD:       IF   ID   ??                  ← Can't use ALU until DIV done

Solution: Multiple functional units (one for DIV, one for ADD)


3. Register File Port Conflict:

       1    2    3    4    5
I1:   IF   ID   EX   MEM  WB    ← Writes to register file
I4:                  IF   ID    ← Reads from register file
                           ↑
            Both access register file in cycle 5

Solution: Multiple register file ports (2 read, 1 write typical)</code></pre>

                    <h3 id="hazard-resolution">Hazard Resolution</h3>
                    
                    <p>Processors use several techniques to handle hazards:</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-tools me-2"></i>Hazard Resolution Techniques</h4>
                        <div class="content">
                            <table class="table table-striped">
                                <thead>
                                    <tr><th>Technique</th><th>Description</th><th>Performance Impact</th></tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Stalling (Bubbles)</strong></td>
                                        <td>Pause dependent instruction until data is ready</td>
                                        <td>❌ Wastes cycles (1-3 cycle penalty)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Forwarding (Bypassing)</strong></td>
                                        <td>Route data directly from EX/MEM output to EX input</td>
                                        <td>✅ Often eliminates stall entirely</td>
                                    </tr>
                                    <tr>
                                        <td><strong>NOP Insertion</strong></td>
                                        <td>Compiler inserts no-operation instructions</td>
                                        <td>❌ Increases code size, wastes cycles</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Reordering</strong></td>
                                        <td>Compiler schedules independent instructions between</td>
                                        <td>✅ Zero overhead if independent work exists</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Branch Prediction</strong></td>
                                        <td>Guess branch direction, speculate</td>
                                        <td>✅ Correct: no penalty; Wrong: flush penalty</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-forward me-2"></i>Data Forwarding (Bypassing)</h4>
                        <div class="content">
<pre class="language-text"><code>Without Forwarding (Stall required):
══════════════════════════════════════════════════════════════
I1: ADD R1, R2, R3      # Writes R1
I2: SUB R4, R1, R5      # Reads R1 ← needs I1's result

       1    2    3    4    5    6    7    8
I1:   IF   ID   EX   MEM  WB
I2:        IF   ID   --   --   ID   EX   MEM  WB
                ↑    ↑↑        ↑
           Detects  Stall    Retry after R1 written
           hazard   (bubbles)

→ 2 cycle penalty


With Forwarding:
══════════════════════════════════════════════════════════════
                     ┌─────────────────┐
                     │   Forwarding    │
                     │     Unit        │
                     └────────┬────────┘
                              │
       1    2    3    4    5  │
I1:   IF   ID   EX   MEM  WB  │
                 │            │
I2:        IF   ID   EX   MEM  WB
                     ↑
           Receives R1 value directly from I1's EX output!

→ 0 cycle penalty (data arrives just in time)</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Load-Use Hazard:</strong> Even with forwarding, loads require at least 1 stall. The data isn't available until after MEM stage, but the next instruction needs it in EX. This is called a "load-use hazard" and requires a "load delay slot."
                    </div>

                </div>

                <!-- Branch Prediction Section -->
                <div id="branch-prediction" class="blog-content mt-5">
                    <h2><i class="fas fa-code-branch me-2 text-teal"></i>Branch Prediction</h2>
                    
                    <p>Branches occur every 5-7 instructions in typical code. With a 3-cycle branch penalty on a 20-stage pipeline, CPI would be terrible without prediction. Modern CPUs achieve &gt;95% branch prediction accuracy.</p>

                    <h3 id="static-prediction">Static Prediction</h3>
                    
                    <p><strong>Static prediction</strong> uses fixed rules without runtime history. Simple but limited accuracy.</p>

<pre class="language-text"><code>Static Branch Prediction Strategies:
══════════════════════════════════════════════════════════════
1. Always Predict NOT TAKEN
   - Assume branch falls through
   - Fetch sequential instruction (PC + 4)
   - Simple, ~40-50% accuracy

2. Always Predict TAKEN
   - Assume branch jumps
   - Problem: Don't know target until decode
   - ~60-70% accuracy (loops taken more often)

3. Backward Taken, Forward Not Taken (BTFNT)
   - Backward branches (target &lt; PC): Predict TAKEN
     → Loops usually taken (except last iteration)
   - Forward branches (target &gt; PC): Predict NOT TAKEN
     → if-statements often fall through
   - ~65-75% accuracy

Loop example:
    0x100:  loop: ...
    0x110:        ...
    0x120:        BNE  R1, R0, loop   ← Backward branch: predict TAKEN
    0x124:        ...

    0x200:        BEQ  R2, R3, skip   ← Forward branch: predict NOT TAKEN
    0x204:        ...
    0x220:  skip: ...</code></pre>

                    <h3 id="dynamic-prediction">Dynamic Prediction</h3>
                    
                    <p><strong>Dynamic prediction</strong> uses runtime history to predict future behavior. Each branch has state tracked in a prediction table.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-chart-line me-2"></i>1-Bit and 2-Bit Predictors</h4>
                        <div class="content">
<pre class="language-text"><code>1-Bit Predictor:
══════════════════════════════════════════════════════════════
State: Last outcome (Taken or Not Taken)
Predict: Same as last time

Problem with loops:
for (i=0; i&lt;1000; i++) { ... }

Iteration:  1    2    3   ...  999  1000
Actual:     T    T    T   ...   T    NT
Predicted:  ?    T    T   ...   T    T
Result:     ?    ✓    ✓   ...   ✓    ✗ (mispredicted)

Next loop iteration 1:
Predicted: NT (from last loop's exit)
Actual:    T
Result:    ✗ (mispredicted again!)

→ 2 mispredictions per loop (first and last iteration)


2-Bit Saturating Counter:
══════════════════════════════════════════════════════════════
4 states, requires 2 consecutive mispredictions to change

        ┌───────────┐                 ┌───────────┐
   NT   │ Strongly  │      T          │ Strongly  │   T
   ┌───→│ Not Taken │←────────────────│   Taken   │←───┐
   │    │  (00)     │                 │   (11)    │    │
   │    └─────┬─────┘                 └─────┬─────┘    │
   │          │ T                       NT  │          │
   │          ▼                             ▼          │
   │    ┌───────────┐                 ┌───────────┐    │
   │    │  Weakly   │       T         │  Weakly   │    │
   └────│ Not Taken │────────────────→│   Taken   │────┘
    NT  │  (01)     │                 │   (10)    │ NT
        └───────────┘                 └───────────┘

Prediction: States 10, 11 → Taken; States 00, 01 → Not Taken

Loop with 2-bit predictor:
Iteration:  1    2    3   ...  999  1000  | 1    2
Actual:     T    T    T   ...   T    NT   | T    T
State:      11   11   11  ...  11    10   | 11   11
Predicted:  T    T    T   ...   T    T    | T    T
Result:     ✓    ✓    ✓   ...   ✓    ✗    | ✓    ✓

→ Only 1 misprediction per loop (last iteration only)</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-brain me-2"></i>
                        <strong>Modern Predictors:</strong> Real CPUs use far more sophisticated predictors:
                        <ul class="mb-0 mt-2">
                            <li><strong>Correlating predictors:</strong> Use history of other branches</li>
                            <li><strong>Tournament predictors:</strong> Multiple predictors, pick best one</li>
                            <li><strong>Neural predictors:</strong> Small neural networks (used in AMD Zen)</li>
                            <li><strong>TAGE predictor:</strong> Tagged geometric history length (Intel)</li>
                        </ul>
                    </div>

                    <h3 id="branch-target-buffer">Branch Target Buffer</h3>
                    
                    <p>The <strong>Branch Target Buffer (BTB)</strong> caches branch target addresses so we don't have to wait for decode to know where to fetch next.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-memory me-2"></i>BTB Structure and Operation</h4>
                        <div class="content">
<pre class="language-text"><code>Branch Target Buffer (BTB):
══════════════════════════════════════════════════════════════
┌─────────────────────────────────────────────────────────────┐
│  PC Tag  │  Target Address  │  Prediction Bits  │  Valid   │
├──────────┼──────────────────┼───────────────────┼──────────┤
│  0x1020  │     0x1200       │       11 (ST)     │    1     │
│  0x2048  │     0x2000       │       10 (WT)     │    1     │
│  0x3100  │     0x3500       │       01 (WNT)    │    1     │
│  ...     │     ...          │       ...         │   ...    │
└─────────────────────────────────────────────────────────────┘

BTB Lookup Process:
                                                              
   Fetch Stage                                                
   ┌────────┐       ┌─────────┐                              
   │   PC   │──────→│   BTB   │                              
   │        │       │ Lookup  │                              
   └────────┘       └────┬────┘                              
                         │                                    
           ┌─────────────┼─────────────┐                     
           │             │             │                      
           ▼             ▼             ▼                      
        No Hit       Hit + NT       Hit + T                   
         │             │             │                        
         ▼             ▼             ▼                        
     Fetch PC+4    Fetch PC+4   Fetch Target                 
                                                              

Timeline with BTB:
══════════════════════════════════════════════════════════════
Without BTB (must wait for decode):
       1    2    3    4    5
BEQ:  IF   ID   EX   MEM  WB
            ↑
      Target known here (cycle 2)
      Then fetch from target → 1+ cycle penalty always

With BTB (lookup in parallel with fetch):
       1    2    3    4    5
BEQ:  IF   ID   EX   MEM  WB
      ↑
      BTB provides target HERE (cycle 1)
      Start fetching target immediately
      → 0 cycle penalty if prediction correct!</code></pre>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-rocket me-2"></i>Speculative Execution</h4>
                        <div class="content">
<pre class="language-text"><code>Speculative Execution:
══════════════════════════════════════════════════════════════
CPU predicts branch outcome and executes speculatively
→ If correct: full speed, no penalty
→ If wrong: flush speculated instructions, restart

Example: Predicted TAKEN (but actually NOT TAKEN)

       1    2    3    4    5    6    7    8
BEQ:  IF   ID   EX   MEM  WB
                 ↑
          Branch resolved: NOT TAKEN!

target:    IF   ID   ← Speculative (wrong path)
target+4:       IF   ← Speculative (wrong path)
                      
       1    2    3    4    5    6    7    8
BEQ:  IF   ID   EX   MEM  WB
target:    IF   ID   XX   XX  ← FLUSHED (wrong prediction)
target+4:       IF   XX   XX  ← FLUSHED
PC+4:               IF   ID   EX  MEM  WB  ← Correct path

Misprediction Penalty = 2 cycles (for 5-stage)
In deep pipelines (20+ stages): 10-20+ cycle penalty!


Why Misprediction Penalty Matters:
═══════════════════════════════════════════════════════════════
Pipeline Depth    Misprediction Penalty    Impact at 15% mispredict
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5-stage           2 cycles                 CPI = 1.3
14-stage          7 cycles                 CPI = 2.05  
20-stage          10 cycles                CPI = 2.5
31-stage          15+ cycles               CPI = 3.25

This is why Intel reduced pipeline depth after Pentium 4!</code></pre>
                        </div>
                    </div>

                </div>

                <!-- Conclusion -->
                <div id="conclusion" class="blog-content mt-5">
                    <h2><i class="fas fa-flag-checkered me-2 text-teal"></i>Conclusion & Next Steps</h2>
                    
                    <p>CPU pipelining is one of the most important techniques in computer architecture, enabling processors to execute multiple instructions simultaneously and achieve high throughput. We've explored:</p>

                    <ul>
                        <li><strong>Instruction Cycle:</strong> Fetch, decode, execute, memory, write-back stages</li>
                        <li><strong>Pipeline Benefits:</strong> N-stage pipeline can approach N× throughput improvement</li>
                        <li><strong>Hazards:</strong> Data (RAW, WAR, WAW), control (branches), structural (resource conflicts)</li>
                        <li><strong>Hazard Resolution:</strong> Stalling, forwarding, branch prediction, compiler scheduling</li>
                        <li><strong>Branch Prediction:</strong> Static (BTFNT), dynamic (2-bit saturating counters), BTB</li>
                    </ul>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Key Takeaway:</strong> Pipelining increases throughput, not latency. Modern CPUs use deep pipelines (14-20 stages) with sophisticated branch predictors (95%+ accuracy) and forwarding networks to minimize stalls.
                    </div>

                    <div class="series-next">
                        <h4><i class="fas fa-arrow-right me-2"></i>Next in the Series</h4>
                        <p>In <a href="comp-arch-os-kernel.html"><strong>Part 8: OS Architecture & Kernel Design</strong></a>, we'll explore how the operating system kernel manages hardware resources, system calls, interrupts, and privilege levels.</p>
                    </div>
                </div>

                <!-- Related Posts -->
                <div class="related-posts">
                    <h3><i class="fas fa-book me-2"></i>Continue the Computer Architecture & OS Series</h3>
                    <div class="related-post-item">
                        <h5>Part 6: Compilers & Program Translation</h5>
                        <p>Lexing, parsing, AST, code generation, and optimization techniques.</p>
                        <a href="comp-arch-compilers.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 8: OS Architecture & Kernel Design</h5>
                        <p>Monolithic vs microkernel, system calls, interrupts, and privilege levels.</p>
                        <a href="comp-arch-os-kernel.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 9: Process & Thread Management</h5>
                        <p>Process states, context switching, threading models, and synchronization.</p>
                        <a href="comp-arch-processes.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Scroll-to-Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>

    <!-- Category Indicator -->
    <div id="categoryIndicator" class="category-indicator"></div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Custom JS -->
    <script src="../../../js/main.js"></script>
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-asm6502.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    <!-- Prism Theme Switcher -->
    <script>
        const themes = {
            'prism-theme': 'Tomorrow Night',
            'prism-default': 'Default',
            'prism-dark': 'Dark',
            'prism-twilight': 'Twilight',
            'prism-okaidia': 'Okaidia',
            'prism-solarizedlight': 'Solarized Light'
        };
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        function switchTheme(themeId) {
            Object.keys(themes).forEach(id => {
                const link = document.getElementById(id);
                if (link) link.disabled = true;
            });
            const selectedLink = document.getElementById(themeId);
            if (selectedLink) {
                selectedLink.disabled = false;
                localStorage.setItem('prism-theme', themeId);
            }
            document.querySelectorAll('div.code-toolbar select').forEach(dropdown => {
                dropdown.value = themeId;
            });
            setTimeout(() => Prism.highlightAll(), 10);
        }
        document.addEventListener('DOMContentLoaded', function() { switchTheme(savedTheme); });
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) {
            const select = document.createElement('select');
            select.setAttribute('aria-label', 'Select code theme');
            Object.keys(themes).forEach(themeId => {
                const option = document.createElement('option');
                option.value = themeId;
                option.textContent = themes[themeId];
                if (themeId === savedTheme) option.selected = true;
                select.appendChild(option);
            });
            select.addEventListener('change', function(e) { switchTheme(e.target.value); });
            return select;
        });
    </script>
</body>
</html>
