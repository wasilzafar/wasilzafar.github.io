<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 9: Processes & Program Execution - Learn about process lifecycle, process control blocks, fork/exec model, and process states." />
    <meta name="keywords" content="processes, program execution, process lifecycle, PCB, process control block, fork, exec, process states, context switching" />
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Part 9: Processes & Program Execution | Computer Architecture & OS Mastery" />
    <meta property="og:description" content="Master process fundamentals: lifecycle, PCB, fork/exec model, process states, and context switching." />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://wasilzafar.com/pages/series/computer-architecture/comp-arch-processes.html" />
    <meta property="article:published_time" content="2026-01-31" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />

    <title>Part 9: Processes & Program Execution | Computer Architecture & OS Mastery - Wasil Zafar</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <!-- Prism.js Syntax Highlighting - Multiple Themes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <!-- Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE']
        });
        gtag('consent', 'default', {
            'ad_storage': 'granted',
            'ad_user_data': 'granted',
            'ad_personalization': 'granted',
            'analytics_storage': 'granted'
        });
        gtag('set', 'url_passthrough', true);
    </script>

    <!-- Google Tag Manager -->
    <script>
        (function(w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript>
        <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>

    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/">
                <span class="gradient-text">Wasil Zafar</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#about">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#skills">Skills</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#certifications">Certifications</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#interests">Interests</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Blog Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <a href="../../categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
            <h1 class="display-4 fw-bold mt-4">Part 9: Processes & Program Execution</h1>
            <div class="blog-meta">
                <span><i class="fas fa-calendar me-2"></i>January 31, 2026</span>
                <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                <span class="reading-time"><i class="fas fa-clock me-1"></i>28 min read</span>
                <button onclick="window.print()" class="print-btn" title="Print this article"><i class="fas fa-print"></i> Print</button>
            </div>
            <p class="lead mt-3">Understand how operating systems manage processes—from creation and scheduling to termination—and learn the fork/exec model that powers Unix systems.</p>
        </div>
    </section>

    <!-- Table of Contents Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation TOC -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li>
                <a href="#introduction" onclick="closeNav()">Introduction</a>
            </li>
            <li>
                <a href="#process-concept" onclick="closeNav()">Process Concept</a>
                <ul>
                    <li><a href="#process-vs-program" onclick="closeNav()">Process vs Program</a></li>
                    <li><a href="#process-memory" onclick="closeNav()">Process Memory Layout</a></li>
                    <li><a href="#process-states" onclick="closeNav()">Process States</a></li>
                </ul>
            </li>
            <li>
                <a href="#pcb" onclick="closeNav()">Process Control Block</a>
                <ul>
                    <li><a href="#pcb-contents" onclick="closeNav()">PCB Contents</a></li>
                    <li><a href="#context-switching" onclick="closeNav()">Context Switching</a></li>
                </ul>
            </li>
            <li>
                <a href="#process-creation" onclick="closeNav()">Process Creation</a>
                <ul>
                    <li><a href="#fork-syscall" onclick="closeNav()">fork() System Call</a></li>
                    <li><a href="#exec-syscall" onclick="closeNav()">exec() System Call</a></li>
                    <li><a href="#fork-exec-pattern" onclick="closeNav()">Fork-Exec Pattern</a></li>
                </ul>
            </li>
            <li>
                <a href="#process-termination" onclick="closeNav()">Process Termination</a>
                <ul>
                    <li><a href="#exit-codes" onclick="closeNav()">Exit Codes</a></li>
                    <li><a href="#zombie-orphan" onclick="closeNav()">Zombies & Orphans</a></li>
                </ul>
            </li>
            <li>
                <a href="#ipc" onclick="closeNav()">Inter-Process Communication</a>
            </li>
            <li><a href="#conclusion" onclick="closeNav()">Conclusion & Next Steps</a></li>
        </ol>
    </div>

    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Main Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <!-- Introduction -->
                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-running me-2 text-teal"></i>Introduction</h2>
                    
                    <p>A process is a program in execution—it's the fundamental unit of work in an operating system. Understanding processes is essential for systems programming, performance tuning, and debugging complex applications.</p>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-sitemap me-2"></i>
                        <strong>Series Context:</strong> This is <strong>Part 9 of 24</strong> in the Computer Architecture & Operating Systems Mastery series. Building on kernel architecture, we now explore how the OS manages running programs.
                    </div>

                    <div class="experiment-card" id="series-nav">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">24-Part Series</span>
                            <span class="badge bg-crimson">Computer Architecture & OS Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="comp-arch-foundations.html"><strong>Part 1:</strong> Foundations of Computer Systems</a> — System overview, architectures, OS role</li>
                                <li><a href="comp-arch-digital-logic.html"><strong>Part 2:</strong> Digital Logic & CPU Building Blocks</a> — Gates, registers, datapath, microarchitecture</li>
                                <li><a href="comp-arch-isa.html"><strong>Part 3:</strong> Instruction Set Architecture (ISA)</a> — RISC vs CISC, instruction formats, addressing</li>
                                <li><a href="comp-arch-assembly.html"><strong>Part 4:</strong> Assembly Language & Machine Code</a> — Registers, stack, calling conventions</li>
                                <li><a href="comp-arch-linkers-loaders.html"><strong>Part 5:</strong> Assemblers, Linkers & Loaders</a> — Object files, ELF, dynamic linking</li>
                                <li><a href="comp-arch-compilers.html"><strong>Part 6:</strong> Compilers & Program Translation</a> — Lexing, parsing, code generation</li>
                                <li><a href="comp-arch-cpu-pipelining.html"><strong>Part 7:</strong> CPU Execution & Pipelining</a> — Fetch-decode-execute, hazards, prediction</li>
                                <li><a href="comp-arch-os-kernel.html"><strong>Part 8:</strong> OS Architecture & Kernel Design</a> — Monolithic, microkernel, system calls</li>
                                <li><strong>Part 9: Processes & Program Execution (This Guide)</strong> — Process lifecycle, PCB, fork/exec</li>
                                <li><a href="comp-arch-threads-concurrency.html"><strong>Part 10:</strong> Threads & Concurrency</a> — Threading models, pthreads, race conditions</li>
                                <li><a href="comp-arch-cpu-scheduling.html"><strong>Part 11:</strong> CPU Scheduling Algorithms</a> — FCFS, RR, CFS, real-time scheduling</li>
                                <li><a href="comp-arch-synchronization.html"><strong>Part 12:</strong> Synchronization & Coordination</a> — Locks, semaphores, classic problems</li>
                                <li><a href="comp-arch-deadlocks.html"><strong>Part 13:</strong> Deadlocks & Prevention</a> — Coffman conditions, Banker's algorithm</li>
                                <li><a href="comp-arch-cache-memory-hierarchy.html"><strong>Part 14:</strong> Memory Hierarchy & Cache</a> — L1/L2/L3, cache coherence, NUMA</li>
                                <li><a href="comp-arch-memory-management.html"><strong>Part 15:</strong> Memory Management Fundamentals</a> — Address spaces, fragmentation, allocation</li>
                                <li><a href="comp-arch-virtual-memory.html"><strong>Part 16:</strong> Virtual Memory & Paging</a> — Page tables, TLB, demand paging</li>
                                <li><a href="comp-arch-file-systems.html"><strong>Part 17:</strong> File Systems & Storage</a> — Inodes, journaling, ext4, NTFS</li>
                                <li><a href="comp-arch-io-devices.html"><strong>Part 18:</strong> I/O Systems & Device Drivers</a> — Interrupts, DMA, disk scheduling</li>
                                <li><a href="comp-arch-multiprocessor.html"><strong>Part 19:</strong> Multiprocessor Systems</a> — SMP, NUMA, cache coherence</li>
                                <li><a href="comp-arch-security.html"><strong>Part 20:</strong> OS Security & Protection</a> — Privilege levels, ASLR, sandboxing</li>
                                <li><a href="comp-arch-virtualization.html"><strong>Part 21:</strong> Virtualization & Containers</a> — Hypervisors, namespaces, cgroups</li>
                                <li><a href="comp-arch-kernel-internals.html"><strong>Part 22:</strong> Advanced Kernel Internals</a> — Linux subsystems, kernel debugging</li>
                                <li><a href="comp-arch-case-studies.html"><strong>Part 23:</strong> Case Studies</a> — Linux vs Windows vs macOS</li>
                                <li><a href="comp-arch-capstone-projects.html"><strong>Part 24:</strong> Capstone Projects</a> — Shell, thread pool, paging simulator</li>
                            </ol>
                        </div>
                    </div>

                    <!-- CONTENT PLACEHOLDER -->
                    <h3>What is a Process?</h3>
                    <p>A <strong>process</strong> is a program in execution—a running instance of a program with its own resources, memory space, and execution context. While a program is static code on disk, a process is dynamic and active.</p>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Analogy:</strong> A program is like a recipe (instructions written down). A process is like actually cooking that recipe—with ingredients (data), a chef (CPU), pots and pans (resources), and the current step you're on (program counter).
                    </div>

                </div>

                <!-- Process Concept Section -->
                <div id="process-concept" class="blog-content mt-5">
                    <h2><i class="fas fa-cube me-2 text-teal"></i>Process Concept</h2>
                    
                    <h3 id="process-vs-program">Process vs Program</h3>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-file-code me-2"></i>Program vs Process</h4>
                        <div class="content">
<pre class="language-text"><code>Program vs Process:
══════════════════════════════════════════════════════════════

PROGRAM (Static)                    PROCESS (Dynamic)
────────────────────────────────    ────────────────────────────────
• Code stored on disk              • Program loaded in memory
• Passive entity                   • Active entity
• No state                         • Has execution state
• Can exist without executing      • Exists only while running
• One program file                 • Multiple processes possible

Example:
┌─────────────────┐                ┌─────────────────┐
│   /bin/bash     │                │  Process 1234   │
│   (executable)  │  ───────────→  │  bash (user A)  │
│                 │  fork + exec   │                 │
└─────────────────┘                └─────────────────┘
        │
        │                          ┌─────────────────┐
        └───────────────────────→  │  Process 5678   │
                      fork + exec  │  bash (user B)  │
                                   └─────────────────┘

Same program, multiple processes, each with own:
• Memory space (isolated)
• File descriptors
• Environment variables
• Current working directory</code></pre>
                        </div>
                    </div>

                    <h3 id="process-memory">Process Memory Layout</h3>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-memory me-2"></i>Process Address Space</h4>
                        <div class="content">
<pre class="language-text"><code>Process Memory Layout (Linux/x86-64):
══════════════════════════════════════════════════════════════
High Addresses
┌─────────────────────────────────────────┐ 0x7FFFFFFFFFFF
│              Kernel Space               │ (inaccessible to user)
│         (mapped but protected)          │
├─────────────────────────────────────────┤ 
│                                         │
│              Stack ↓                    │ Grows downward
│         (local variables, return        │ 
│          addresses, function params)    │
│                                         │
├─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┤ ← Stack limit
│                                         │
│         (unmapped - guard region)       │
│                                         │
├─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┤
│                                         │
│      Memory-Mapped Region               │
│    (shared libraries, mmap files)       │
│                                         │
├─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┤
│                                         │
│              Heap ↑                     │ Grows upward
│    (dynamic allocation: malloc/new)     │
│                                         │
├─────────────────────────────────────────┤ ← Program break (brk)
│              BSS                        │ Uninitialized globals
│    (zero-initialized by OS)             │ int global_array[1000];
├─────────────────────────────────────────┤
│             Data                        │ Initialized globals
│    (initialized global variables)       │ int count = 42;
├─────────────────────────────────────────┤
│             Text (Code)                 │ Machine instructions
│    (read-only, executable)              │ main(), printf(), etc.
└─────────────────────────────────────────┘ 0x400000
Low Addresses</code></pre>
                        </div>
                    </div>

<pre class="language-bash"><code># Examine a process's memory map on Linux
$ cat /proc/self/maps
00400000-00401000 r--p 00000000 fd:00 123456  /usr/bin/cat     # Text (code)
00401000-00408000 r-xp 00001000 fd:00 123456  /usr/bin/cat     # Text (code)
00608000-00609000 r--p 00008000 fd:00 123456  /usr/bin/cat     # Read-only data
00609000-0060a000 rw-p 00009000 fd:00 123456  /usr/bin/cat     # Data (r/w)
0060a000-0062b000 rw-p 00000000 00:00 0       [heap]           # Heap
7f9a00000000-7f9a00021000 rw-p 00000000 00:00 0                # mmap region
7ffc12345000-7ffc12366000 rw-p 00000000 00:00 0  [stack]       # Stack</code></pre>

                    <h3 id="process-states">Process States</h3>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-project-diagram me-2"></i>Process State Diagram</h4>
                        <div class="content">
<pre class="language-text"><code>Process State Transitions:
══════════════════════════════════════════════════════════════

                    ┌─────────────┐
                    │    New      │
                    │  (created)  │
                    └──────┬──────┘
                           │ admitted
                           ▼
           ┌───────────────────────────────┐
           │                               │
           │    ┌─────────────────┐        │
interrupt  │    │      Ready      │◄───────┘
    │      │    │ (waiting for    │    I/O or event
    │      │    │  CPU)           │◄────completion
    │      │    └────────┬────────┘        │
    │      │             │                  │
    │      │   scheduler │ dispatch         │
    │      │             ▼                  │
    │      └──►┌─────────────────┐          │
    │          │    Running      │          │
    └──────────│ (executing on   │──────────┘
               │  CPU)           │   I/O or event wait
               └────────┬────────┘
                        │ exit
                        ▼
               ┌─────────────────┐
               │   Terminated    │
               │   (zombie)      │
               └─────────────────┘

Linux Process States (ps output):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
State   Code    Description
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
R       Running Currently executing or runnable (in run queue)
S       Sleep   Interruptible sleep (waiting for event)
D       Disk    Uninterruptible sleep (usually I/O)
T       Stopped Stopped by signal (e.g., SIGSTOP)
Z       Zombie  Terminated but parent hasn't read exit status
I       Idle    Kernel thread, idle</code></pre>
                        </div>
                    </div>

                </div>

                <!-- PCB Section -->
                <div id="pcb" class="blog-content mt-5">
                    <h2><i class="fas fa-id-card me-2 text-teal"></i>Process Control Block</h2>
                    
                    <p>The <strong>Process Control Block (PCB)</strong> is a data structure the kernel maintains for each process. It contains all information needed to manage and schedule the process.</p>

                    <h3 id="pcb-contents">PCB Contents</h3>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-clipboard-list me-2"></i>PCB Structure</h4>
                        <div class="content">
<pre class="language-text"><code>Process Control Block (task_struct in Linux):
══════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────┐
│                    Process Control Block                     │
├─────────────────────────────────────────────────────────────┤
│ IDENTIFICATION                                              │
│   • PID (Process ID): 1234                                 │
│   • PPID (Parent PID): 1                                   │
│   • UID/GID (User/Group): 1000/1000                        │
│   • Process name: "firefox"                                │
├─────────────────────────────────────────────────────────────┤
│ STATE INFORMATION                                           │
│   • Current state: Running / Ready / Blocked               │
│   • Priority: 20 (nice value)                              │
│   • CPU time used: 45.23 seconds                           │
│   • Scheduling class: SCHED_NORMAL                         │
├─────────────────────────────────────────────────────────────┤
│ CPU CONTEXT (saved on context switch)                       │
│   • Program Counter (RIP): 0x401234                        │
│   • Stack Pointer (RSP): 0x7ffc12345678                    │
│   • General registers: RAX, RBX, RCX, ...                  │
│   • Flags register (RFLAGS)                                │
│   • Floating-point state (FPU/SSE/AVX)                     │
├─────────────────────────────────────────────────────────────┤
│ MEMORY MANAGEMENT                                           │
│   • Page table pointer (CR3): 0x12345000                   │
│   • Memory limits: stack, heap boundaries                  │
│   • Memory map (VMAs): code, data, stack, mmap            │
├─────────────────────────────────────────────────────────────┤
│ FILE DESCRIPTORS                                            │
│   • Open file table pointer                                │
│   • stdin (0), stdout (1), stderr (2)                      │
│   • Network sockets, pipes, etc.                           │
├─────────────────────────────────────────────────────────────┤
│ SIGNAL HANDLING                                             │
│   • Pending signals bitmap                                 │
│   • Signal handlers: signal → handler function             │
│   • Blocked signals mask                                   │
├─────────────────────────────────────────────────────────────┤
│ ACCOUNTING                                                  │
│   • Start time: 2024-01-15 10:30:45                        │
│   • CPU time (user/system): 12.5s / 3.2s                   │
│   • I/O statistics: bytes read/written                     │
└─────────────────────────────────────────────────────────────┘</code></pre>
                        </div>
                    </div>

                    <h3 id="context-switching">Context Switching</h3>
                    
                    <p>A <strong>context switch</strong> saves one process's state and restores another's, allowing the CPU to run multiple processes "simultaneously."</p>

<pre class="language-text"><code>Context Switch Sequence:
══════════════════════════════════════════════════════════════

Process A running                   Process B waiting
     │                                    │
     ▼                                    │
┌─────────────────┐                       │
│ Timer interrupt │                       │
│ or syscall      │                       │
└────────┬────────┘                       │
         │                                │
         ▼                                │
┌─────────────────────────────────────────┼─────────────────┐
│                    KERNEL                │                 │
│                                          │                 │
│  1. Save Process A's context:           │                 │
│     • Push registers to A's kernel stack│                 │
│     • Save stack pointer in A's PCB     │                 │
│                                          │                 │
│  2. Scheduler selects Process B         │                 │
│                                          │                 │
│  3. Restore Process B's context:        │                 │
│     • Load B's page table (CR3)         │                 │
│     • Load B's stack pointer            │                 │
│     • Pop registers from B's kernel stack                 │
│                                          │                 │
└──────────────────────────────────────────┴─────────────────┘
                                                    │
                                                    ▼
                              ┌─────────────────────────────┐
                              │     Process B now running   │
                              │     (A is now "Ready")      │
                              └─────────────────────────────┘

Context Switch Cost:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Operation                              Time
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Save/restore registers                 ~1-2 μs
TLB flush (address space switch)       ~0-10 μs (ASID helps)
Cache pollution                        10-1000+ μs (indirect)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Direct cost: ~2-5 μs
Indirect cost (cache misses): Much higher!</code></pre>

                </div>

                <!-- Process Creation Section -->
                <div id="process-creation" class="blog-content mt-5">
                    <h2><i class="fas fa-plus-circle me-2 text-teal"></i>Process Creation</h2>
                    
                    <p>On Unix/Linux, processes are created using the <strong>fork-exec</strong> model: fork() creates a copy of the parent, then exec() replaces it with a new program.</p>

                    <h3 id="fork-syscall">fork() System Call</h3>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-code-branch me-2"></i>fork() Creates a Clone</h4>
                        <div class="content">
<pre class="language-c"><code>// fork() example - creates child process
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int main() {
    printf("Before fork: PID = %d\n", getpid());
    
    pid_t pid = fork();  // Creates child process
    
    if (pid &lt; 0) {
        // fork() failed
        perror("fork failed");
        return 1;
    }
    else if (pid == 0) {
        // CHILD process (fork returns 0 to child)
        printf("Child: PID = %d, Parent PID = %d\n", 
               getpid(), getppid());
        // Child does its work...
    }
    else {
        // PARENT process (fork returns child's PID)
        printf("Parent: PID = %d, Child PID = %d\n", 
               getpid(), pid);
        wait(NULL);  // Wait for child to exit
        printf("Parent: Child finished\n");
    }
    
    return 0;
}</code></pre>
<pre class="language-text"><code>Output:
Before fork: PID = 1234
Parent: PID = 1234, Child PID = 1235
Child: PID = 1235, Parent PID = 1234
Parent: Child finished</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-clone me-2"></i>
                        <strong>Copy-on-Write (COW):</strong> Modern systems don't actually copy all memory on fork(). Instead, parent and child share memory pages marked read-only. Only when either writes does the kernel copy that specific page. This makes fork() very fast!
                    </div>

                    <h3 id="exec-syscall">exec() System Call</h3>
                    
<pre class="language-c"><code>// exec() replaces process image with new program
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    printf("About to exec ls...\n");
    
    // Replace this process with /bin/ls
    // execl(path, arg0, arg1, ..., NULL)
    execl("/bin/ls", "ls", "-la", "/tmp", NULL);
    
    // If exec succeeds, this line NEVER executes!
    // The process is now running /bin/ls
    printf("This won't print unless exec failed\n");
    perror("exec failed");
    return 1;
}

// exec family variants:
// execl  - list of args  : execl("/bin/ls", "ls", "-l", NULL)
// execv  - array of args : execv("/bin/ls", argv)
// execlp - search PATH   : execlp("ls", "ls", "-l", NULL)
// execvp - search PATH   : execvp("ls", argv)
// execle - with env      : execle("/bin/ls", "ls", NULL, envp)
// execve - array + env   : execve("/bin/ls", argv, envp)</code></pre>

                    <h3 id="fork-exec-pattern">Fork-Exec Pattern</h3>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-project-diagram me-2"></i>How Shells Launch Programs</h4>
                        <div class="content">
<pre class="language-c"><code>// Shell-like process creation
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int main() {
    char *command = "/bin/ls";
    char *args[] = {"ls", "-la", "/tmp", NULL};
    
    pid_t pid = fork();
    
    if (pid == 0) {
        // CHILD: Replace with new program
        execv(command, args);
        perror("exec failed");  // Only reached if exec fails
        _exit(127);
    }
    else if (pid &gt; 0) {
        // PARENT: Wait for child
        int status;
        waitpid(pid, &amp;status, 0);
        
        if (WIFEXITED(status)) {
            printf("Child exited with code %d\n", 
                   WEXITSTATUS(status));
        }
    }
    
    return 0;
}</code></pre>
<pre class="language-text"><code>Fork-Exec Timeline:
══════════════════════════════════════════════════════════════

Shell (bash)                    fork()
PID 1000                          │
    │                             ▼
    │                    ┌────────────────┐
    │                    │ Child (PID 1001)│
    │                    │ Running bash   │
    │                    │ code (copy)    │
    │                    └───────┬────────┘
    │                            │ exec("/bin/ls")
    │                            ▼
    │                    ┌────────────────┐
    │  waitpid()         │ Child (PID 1001)│
    │  (waiting)         │ Now running ls │
    │       │            │ (new program!) │
    │       │            └───────┬────────┘
    │       │                    │ exit(0)
    │       │                    ▼
    │       │            (Child terminated)
    │       │                    │
    │◄──────┴────────────────────┘
    │   wait returns
    ▼
(Shell continues)</code></pre>
                        </div>
                    </div>

                </div>

                <!-- Process Termination Section -->
                <div id="process-termination" class="blog-content mt-5">
                    <h2><i class="fas fa-stop-circle me-2 text-teal"></i>Process Termination</h2>
                    
                    <h3 id="exit-codes">Exit Codes</h3>
                    
<pre class="language-text"><code>Process Termination:
══════════════════════════════════════════════════════════════

Normal Termination:
• exit(status)   - Terminate with exit code
• return from main() - Same as exit(return_value)
• _exit(status)  - Immediate termination (no cleanup)

Abnormal Termination:
• Killed by signal (SIGKILL, SIGTERM, SIGSEGV, etc.)
• Uncaught exception
• abort() - Sends SIGABRT to self

Exit Code Conventions:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Code    Meaning
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
0       Success
1       General error
2       Misuse of shell command
126     Command found but not executable
127     Command not found
128+N   Killed by signal N (e.g., 137 = 128 + 9 = SIGKILL)

$ ls /nonexistent
ls: cannot access '/nonexistent': No such file or directory
$ echo $?
2

$ sleep 100 &amp;
$ kill -9 $!
$ wait $!
$ echo $?
137   # 128 + 9 (SIGKILL)</code></pre>

                    <h3 id="zombie-orphan">Zombies & Orphans</h3>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-skull me-2"></i>Zombie and Orphan Processes</h4>
                        <div class="content">
<pre class="language-text"><code>Zombie Process:
══════════════════════════════════════════════════════════════
A process that has terminated but whose parent hasn't called
wait() yet. The PCB remains so the parent can retrieve the
exit status.

Parent                          Child
   │                              │
   │                              │ exit(0)
   │                              ▼
   │                    ┌─────────────────┐
   │  (doesn't wait)    │ ZOMBIE (Z state)│
   │                    │ PID exists      │
   │                    │ Takes no resources│
   │                    │ Waiting for     │
   │                    │ parent's wait() │
   │                    └─────────────────┘

$ ps aux | grep Z
user   12345  0.0  0.0   0   0 ?  Z  10:30  0:00 [defunct]

Problem: Too many zombies can exhaust PID space.
Solution: Parent should always wait() for children.


Orphan Process:
══════════════════════════════════════════════════════════════
A process whose parent has terminated. The orphan is "adopted"
by init (PID 1) or a subreaper process, which will wait() for it.

Parent (PID 1000)              Child (PID 1001)
   │                              │
   │ exit(0)                      │
   ▼                              │
(Parent terminates)               │
                                  │
init (PID 1)                      │
   │                              │
   │◄───── reparented ────────────┤
   │                              │
   │                              │ exit(0)
   │                              ▼
   │◄─── wait() ────── (Orphan terminates cleanly)

Orphans are NOT zombies - they continue running normally,
just with a new parent (usually init).</code></pre>
                        </div>
                    </div>

                </div>

                <!-- IPC Section -->
                <div id="ipc" class="blog-content mt-5">
                    <h2><i class="fas fa-exchange-alt me-2 text-teal"></i>Inter-Process Communication</h2>
                    
                    <p>Processes are isolated by design, but sometimes they need to communicate. The OS provides several <strong>IPC (Inter-Process Communication)</strong> mechanisms:</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-project-diagram me-2"></i>IPC Mechanisms</h4>
                        <div class="content">
                            <table class="table table-striped">
                                <thead>
                                    <tr><th>Mechanism</th><th>Description</th><th>Use Case</th></tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Pipes</strong></td>
                                        <td>Unidirectional byte stream between related processes</td>
                                        <td><code>ls | grep foo</code></td>
                                    </tr>
                                    <tr>
                                        <td><strong>Named Pipes (FIFOs)</strong></td>
                                        <td>Pipes with filesystem name, any process can connect</td>
                                        <td>Simple client-server</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Shared Memory</strong></td>
                                        <td>Memory region mapped into multiple processes</td>
                                        <td>High-speed data sharing</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Message Queues</strong></td>
                                        <td>Kernel-managed message passing</td>
                                        <td>Structured communication</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Semaphores</strong></td>
                                        <td>Synchronization primitive (not data transfer)</td>
                                        <td>Coordinate access</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Sockets</strong></td>
                                        <td>Network-style communication (local or remote)</td>
                                        <td>Client-server apps</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Signals</strong></td>
                                        <td>Asynchronous notifications</td>
                                        <td>SIGTERM, SIGINT, etc.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

<pre class="language-c"><code>// Pipe example - parent writes, child reads
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main() {
    int pipefd[2];  // pipefd[0] = read end, pipefd[1] = write end
    char buf[100];
    
    pipe(pipefd);   // Create pipe before fork!
    
    if (fork() == 0) {
        // CHILD: Read from pipe
        close(pipefd[1]);  // Close unused write end
        read(pipefd[0], buf, sizeof(buf));
        printf("Child received: %s\n", buf);
        close(pipefd[0]);
    } else {
        // PARENT: Write to pipe
        close(pipefd[0]);  // Close unused read end
        char *msg = "Hello from parent!";
        write(pipefd[1], msg, strlen(msg) + 1);
        close(pipefd[1]);
        wait(NULL);
    }
    return 0;
}
// Output: Child received: Hello from parent!</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>IPC Choice Matters:</strong> Shared memory is fastest (no kernel involvement for data transfer) but requires manual synchronization. Pipes/sockets are simpler but involve kernel copies. Choose based on your needs!
                    </div>

                </div>

                <!-- Conclusion -->
                <div id="conclusion" class="blog-content mt-5">
                    <h2><i class="fas fa-flag-checkered me-2 text-teal"></i>Conclusion & Next Steps</h2>
                    
                    <p>Processes are the fundamental abstraction for running programs. We've covered:</p>

                    <ul>
                        <li><strong>Process Concept:</strong> Programs in execution with their own memory space and resources</li>
                        <li><strong>Memory Layout:</strong> Text, data, BSS, heap, and stack segments</li>
                        <li><strong>Process States:</strong> Running, ready, blocked, zombie, and the transitions between them</li>
                        <li><strong>PCB:</strong> The kernel's data structure containing all process information</li>
                        <li><strong>Fork-Exec:</strong> Unix model for process creation via clone + replace</li>
                        <li><strong>Termination:</strong> Exit codes, zombies, and orphan handling</li>
                        <li><strong>IPC:</strong> Pipes, shared memory, sockets for inter-process communication</li>
                    </ul>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Key Insight:</strong> Processes provide isolation—one process crashing doesn't affect others. This isolation comes at a cost (context switch overhead, IPC complexity), which is why threads (next topic) share an address space for faster communication.
                    </div>

                    <div class="series-next">
                        <h4><i class="fas fa-arrow-right me-2"></i>Next in the Series</h4>
                        <p>In <a href="comp-arch-threads-concurrency.html"><strong>Part 10: Threads & Concurrency</strong></a>, we'll explore how threads enable parallelism within a single process, threading models, pthreads API, and the challenges of race conditions and synchronization.</p>
                    </div>
                </div>

                <!-- Related Posts -->
                <div class="related-posts">
                    <h3><i class="fas fa-book me-2"></i>Continue the Computer Architecture & OS Series</h3>
                    <div class="related-post-item">
                        <h5>Part 8: OS Architecture & Kernel Design</h5>
                        <p>Monolithic vs microkernel, system calls, and interrupt handling.</p>
                        <a href="comp-arch-os-kernel.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 10: Threads & Concurrency</h5>
                        <p>Threading models, pthreads, and race conditions.</p>
                        <a href="comp-arch-threads-concurrency.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 11: CPU Scheduling Algorithms</h5>
                        <p>FCFS, Round Robin, CFS, and real-time scheduling.</p>
                        <a href="comp-arch-cpu-scheduling.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Scroll-to-Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>

    <!-- Category Indicator -->
    <div id="categoryIndicator" class="category-indicator"></div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Custom JS -->
    <script src="../../../js/main.js"></script>
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    <!-- Prism Theme Switcher -->
    <script>
        const themes = {
            'prism-theme': 'Tomorrow Night',
            'prism-default': 'Default',
            'prism-dark': 'Dark',
            'prism-twilight': 'Twilight',
            'prism-okaidia': 'Okaidia',
            'prism-solarizedlight': 'Solarized Light'
        };
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        function switchTheme(themeId) {
            Object.keys(themes).forEach(id => {
                const link = document.getElementById(id);
                if (link) link.disabled = true;
            });
            const selectedLink = document.getElementById(themeId);
            if (selectedLink) {
                selectedLink.disabled = false;
                localStorage.setItem('prism-theme', themeId);
            }
            document.querySelectorAll('div.code-toolbar select').forEach(dropdown => {
                dropdown.value = themeId;
            });
            setTimeout(() => Prism.highlightAll(), 10);
        }
        document.addEventListener('DOMContentLoaded', function() { switchTheme(savedTheme); });
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) {
            const select = document.createElement('select');
            select.setAttribute('aria-label', 'Select code theme');
            Object.keys(themes).forEach(themeId => {
                const option = document.createElement('option');
                option.value = themeId;
                option.textContent = themes[themeId];
                if (themeId === savedTheme) option.selected = true;
                select.appendChild(option);
            });
            select.addEventListener('change', function(e) { switchTheme(e.target.value); });
            return select;
        });
    </script>
</body>
</html>
