<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 18: I/O Systems & Device Drivers - Learn about interrupts, DMA, device drivers, disk scheduling algorithms, and I/O architecture." />
    <meta name="keywords" content="I/O systems, device drivers, interrupts, DMA, disk scheduling, SSTF, SCAN, device controllers, block devices, character devices" />
    
    <meta property="og:title" content="Part 18: I/O Systems & Device Drivers | Computer Architecture & OS Mastery" />
    <meta property="og:description" content="Master I/O systems: interrupts, DMA, device drivers, and disk scheduling algorithms." />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://wasilzafar.com/pages/series/computer-architecture/comp-arch-io-devices.html" />
    <meta property="article:published_time" content="2026-01-31" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />

    <title>Part 18: I/O Systems & Device Drivers | Computer Architecture & OS Mastery - Wasil Zafar</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', { 'ad_storage': 'denied', 'ad_user_data': 'denied', 'ad_personalization': 'denied', 'analytics_storage': 'denied', 'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE'] });
        gtag('consent', 'default', { 'ad_storage': 'granted', 'ad_user_data': 'granted', 'ad_personalization': 'granted', 'analytics_storage': 'granted' });
        gtag('set', 'url_passthrough', true);
    </script>
    <script>
        (function(w, d, s, l, i) { w[l] = w[l] || []; w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'}); var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f); })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>
</head>
<body>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <section class="blog-hero">
        <div class="container py-5">
            <a href="../../categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
            <h1 class="display-4 fw-bold mt-4">Part 18: I/O Systems & Device Drivers</h1>
            <div class="blog-meta">
                <span><i class="fas fa-calendar me-2"></i>January 31, 2026</span>
                <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                <span class="reading-time"><i class="fas fa-clock me-1"></i>28 min read</span>
                <button onclick="window.print()" class="print-btn" title="Print this article"><i class="fas fa-print"></i> Print</button>
            </div>
            <p class="lead mt-3">Understand how operating systems communicate with hardware—from interrupts and DMA to device drivers and disk scheduling.</p>
        </div>
    </section>

    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents"><i class="fas fa-list"></i></button>

    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li><a href="#introduction" onclick="closeNav()">Introduction</a></li>
            <li><a href="#io-hardware" onclick="closeNav()">I/O Hardware</a></li>
            <li><a href="#interrupts" onclick="closeNav()">Interrupts</a></li>
            <li><a href="#dma" onclick="closeNav()">Direct Memory Access</a></li>
            <li><a href="#device-drivers" onclick="closeNav()">Device Drivers</a></li>
            <li><a href="#block-character" onclick="closeNav()">Block vs Character Devices</a></li>
            <li><a href="#disk-structure" onclick="closeNav()">Disk Structure</a></li>
            <li><a href="#disk-scheduling" onclick="closeNav()">Disk Scheduling Algorithms</a></li>
            <li><a href="#conclusion" onclick="closeNav()">Conclusion & Next Steps</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-plug me-2 text-teal"></i>Introduction</h2>
                    <p>I/O systems form the bridge between software and hardware. Understanding how the OS manages devices is crucial for system programming and performance optimization.</p>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-sitemap me-2"></i>
                        <strong>Series Context:</strong> This is <strong>Part 18 of 24</strong> in the Computer Architecture & Operating Systems Mastery series. Building on file systems, we explore hardware communication.
                    </div>

                    <div class="experiment-card" id="series-nav">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">24-Part Series</span>
                            <span class="badge bg-crimson">Computer Architecture & OS Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="comp-arch-foundations.html"><strong>Part 1:</strong> Foundations of Computer Systems</a> — System overview, architectures, OS role</li>
                                <li><a href="comp-arch-digital-logic.html"><strong>Part 2:</strong> Digital Logic & CPU Building Blocks</a> — Gates, registers, datapath, microarchitecture</li>
                                <li><a href="comp-arch-isa.html"><strong>Part 3:</strong> Instruction Set Architecture (ISA)</a> — RISC vs CISC, instruction formats, addressing</li>
                                <li><a href="comp-arch-assembly.html"><strong>Part 4:</strong> Assembly Language & Machine Code</a> — Registers, stack, calling conventions</li>
                                <li><a href="comp-arch-linkers-loaders.html"><strong>Part 5:</strong> Assemblers, Linkers & Loaders</a> — Object files, ELF, dynamic linking</li>
                                <li><a href="comp-arch-compilers.html"><strong>Part 6:</strong> Compilers & Program Translation</a> — Lexing, parsing, code generation</li>
                                <li><a href="comp-arch-cpu-pipelining.html"><strong>Part 7:</strong> CPU Execution & Pipelining</a> — Fetch-decode-execute, hazards, prediction</li>
                                <li><a href="comp-arch-os-kernel.html"><strong>Part 8:</strong> OS Architecture & Kernel Design</a> — Monolithic, microkernel, system calls</li>
                                <li><a href="comp-arch-processes.html"><strong>Part 9:</strong> Processes & Program Execution</a> — Process lifecycle, PCB, fork/exec</li>
                                <li><a href="comp-arch-threads-concurrency.html"><strong>Part 10:</strong> Threads & Concurrency</a> — Threading models, pthreads, race conditions</li>
                                <li><a href="comp-arch-cpu-scheduling.html"><strong>Part 11:</strong> CPU Scheduling Algorithms</a> — FCFS, RR, CFS, real-time scheduling</li>
                                <li><a href="comp-arch-synchronization.html"><strong>Part 12:</strong> Synchronization & Coordination</a> — Locks, semaphores, classic problems</li>
                                <li><a href="comp-arch-deadlocks.html"><strong>Part 13:</strong> Deadlocks & Prevention</a> — Coffman conditions, Banker's algorithm</li>
                                <li><a href="comp-arch-cache-memory-hierarchy.html"><strong>Part 14:</strong> Memory Hierarchy & Cache</a> — L1/L2/L3, cache coherence, NUMA</li>
                                <li><a href="comp-arch-memory-management.html"><strong>Part 15:</strong> Memory Management Fundamentals</a> — Address spaces, fragmentation, allocation</li>
                                <li><a href="comp-arch-virtual-memory.html"><strong>Part 16:</strong> Virtual Memory & Paging</a> — Page tables, TLB, demand paging</li>
                                <li><a href="comp-arch-file-systems.html"><strong>Part 17:</strong> File Systems & Storage</a> — Inodes, journaling, ext4, NTFS</li>
                                <li><strong>Part 18: I/O Systems & Device Drivers (This Guide)</strong> — Interrupts, DMA, disk scheduling</li>
                                <li><a href="comp-arch-multiprocessor.html"><strong>Part 19:</strong> Multiprocessor Systems</a> — SMP, NUMA, cache coherence</li>
                                <li><a href="comp-arch-security.html"><strong>Part 20:</strong> OS Security & Protection</a> — Privilege levels, ASLR, sandboxing</li>
                                <li><a href="comp-arch-virtualization.html"><strong>Part 21:</strong> Virtualization & Containers</a> — Hypervisors, namespaces, cgroups</li>
                                <li><a href="comp-arch-kernel-internals.html"><strong>Part 22:</strong> Advanced Kernel Internals</a> — Linux subsystems, kernel debugging</li>
                                <li><a href="comp-arch-case-studies.html"><strong>Part 23:</strong> Case Studies</a> — Linux vs Windows vs macOS</li>
                                <li><a href="comp-arch-capstone-projects.html"><strong>Part 24:</strong> Capstone Projects</a> — Shell, thread pool, paging simulator</li>
                            </ol>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-question-circle me-2"></i>
                        <strong>The Speed Gap Problem:</strong> CPUs operate at GHz speeds, but I/O devices range from slow keyboards to fast NVMe SSDs. How does the OS bridge this massive speed difference efficiently?
                    </div>
                </div>

                <div id="io-hardware" class="blog-content mt-5">
                    <h2><i class="fas fa-microchip me-2 text-teal"></i>I/O Hardware</h2>
                    
                    <p>I/O devices communicate with the CPU through <strong>controllers</strong>, <strong>buses</strong>, and <strong>ports</strong>.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-network-wired me-2"></i>I/O System Architecture</h4>
                        <div class="content">
<pre class="language-text"><code>I/O Hardware Stack:
══════════════════════════════════════════════════════════════

┌─────────┐
│   CPU   │
└────┬────┘
     │
     ▼
┌────────────────────────────────────────────────┐
│              Memory Bus (FSB/QPI)              │
└──────────────────┬─────────────────────────────┘
                   │
     ┌─────────────┴─────────────┐
     ▼                           ▼
┌─────────┐               ┌───────────────┐
│   RAM   │               │  Chipset/PCH  │
└─────────┘               └───────┬───────┘
                                │
          ┌──────────────────┼──────────────────┐
          │                  │                  │
          ▼                  ▼                  ▼
    ┌─────────┐        ┌─────────┐        ┌─────────┐
    │PCIe x16 │        │  SATA   │        │   USB   │
    │ (GPU)   │        │         │        │         │
    └─────────┘        └─────────┘        └─────────┘

Device Communication:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. PORT-MAPPED I/O (x86)
   • Separate I/O address space
   • Special instructions: IN, OUT
   • Example: in al, 0x60  ; read keyboard

2. MEMORY-MAPPED I/O (modern)
   • Device registers mapped to memory addresses
   • Use regular MOV instructions
   • Example: GPU framebuffer at 0xA0000</code></pre>
                        </div>
                    </div>
                </div>

                <div id="interrupts" class="blog-content mt-5">
                    <h2><i class="fas fa-bolt me-2 text-teal"></i>Interrupts</h2>
                    
                    <p><strong>Interrupts</strong> allow devices to signal the CPU asynchronously, avoiding wasteful polling.</p>

<pre class="language-text"><code>Polling vs Interrupts:
══════════════════════════════════════════════════════════════

POLLING (Busy Waiting):
while (device_status != READY) {
    // CPU spinning, wasting cycles!
}
read_data();

✗ Wastes CPU time
✗ Can't do other work while waiting
✓ Low latency for high-speed devices


INTERRUPTS:
1. CPU executes other work
2. Device raises interrupt signal (IRQ)
3. CPU saves state, jumps to handler
4. Handler processes device, returns
5. CPU resumes previous work

✓ CPU free to do other work
✓ Efficient for slow devices
✗ Context switch overhead


Interrupt Handling Steps:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Device asserts interrupt line
2. Interrupt controller (APIC) signals CPU
3. CPU finishes current instruction
4. CPU pushes flags, CS, IP to stack
5. CPU looks up handler in IDT (Interrupt Descriptor Table)
6. Jump to interrupt handler
7. Handler:
   a. Save registers
   b. Service the device
   c. Acknowledge interrupt to controller
   d. Restore registers
8. IRET - return from interrupt</code></pre>

<pre class="language-bash"><code># View interrupts on Linux
$ cat /proc/interrupts
           CPU0       CPU1
  0:         45          0   IO-APIC   2-edge      timer
  1:       1234          0   IO-APIC   1-edge      i8042 (keyboard)
  8:          1          0   IO-APIC   8-edge      rtc0
 12:      56789          0   IO-APIC  12-edge      i8042 (mouse)
 16:     123456     123456   IO-APIC  16-fasteoi   ehci_hcd (USB)

# Monitor interrupt rate
$ watch -n1 'cat /proc/interrupts'</code></pre>
                </div>

                <div id="dma" class="blog-content mt-5">
                    <h2><i class="fas fa-exchange-alt me-2 text-teal"></i>Direct Memory Access (DMA)</h2>
                    
                    <p><strong>DMA</strong> allows devices to transfer data directly to/from memory without CPU involvement.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-stream me-2"></i>DMA Operation</h4>
                        <div class="content">
<pre class="language-text"><code>Without DMA (Programmed I/O):
══════════════════════════════════════════════════════════════

for each byte:
    1. CPU reads byte from device
    2. CPU writes byte to memory

4KB transfer = 4096 CPU read/write cycles!


With DMA:
══════════════════════════════════════════════════════════════

1. CPU programs DMA controller:
   - Source address
   - Destination address (memory buffer)
   - Transfer count
   - Direction (read/write)

2. DMA controller takes over bus:
   - Device ↔ DMA ↔ Memory
   - CPU is FREE during transfer!

3. DMA raises interrupt when complete

4. CPU processes data


┌─────────┐                              ┌─────────┐
│   CPU   │     (CPU does other work)   │   RAM   │
└─────────┘                              └────┬────┘
                                              │
               ┌──────────────┐             │
               │     DMA      │ ────────────┘
               │  Controller  │  (direct transfer)
               └──────┬───────┘
                      │
               ┌──────┴───────┐
               │    Device    │
               └──────────────┘</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-memory me-2"></i>
                        <strong>DMA Buffers:</strong> Memory for DMA must be physically contiguous and "pinned" (not swappable). The kernel provides special allocation functions like <code>dma_alloc_coherent()</code>.
                    </div>
                </div>

                <div id="device-drivers" class="blog-content mt-5">
                    <h2><i class="fas fa-cogs me-2 text-teal"></i>Device Drivers</h2>
                    
                    <p><strong>Device drivers</strong> are kernel modules that know how to communicate with specific hardware.</p>

<pre class="language-text"><code>Driver Architecture:
══════════════════════════════════════════════════════════════

              User Application
                    │
              System Calls
                    │
         ┌─────────┴─────────┐
         │  Kernel Core    │
         │ (VFS, block     │
         │  layer, etc.)   │
         └─────────┬─────────┘
                   │
         Driver Interface
                   │
    ┌─────────────┼─────────────┐
    │             │             │
┌───┴───┐   ┌────┴────┐   ┌───┴────┐
│ AHCI  │   │  NVMe   │   │  USB    │
│driver│   │ driver  │   │ driver  │
└───┬───┘   └────┬────┘   └───┬────┘
    │             │             │
    ▼             ▼             ▼
  SATA          NVMe          USB
  disk          SSD           HID</code></pre>

<pre class="language-bash"><code># List loaded kernel modules (drivers)
$ lsmod
Module                  Size  Used by
nvme                   45056  3
nvme_core             114688  5 nvme
ahci                   40960  5
libahci                36864  1 ahci
usb_storage            77824  1

# Load/unload driver
$ sudo modprobe nvme      # Load
$ sudo modprobe -r nvme   # Unload

# View driver messages
$ dmesg | tail -20</code></pre>
                </div>

                <div id="block-character" class="blog-content mt-5">
                    <h2><i class="fas fa-th me-2 text-teal"></i>Block vs Character Devices</h2>
                    
                    <p>Unix categorizes devices into <strong>block</strong> and <strong>character</strong> devices based on data access patterns.</p>

<pre class="language-text"><code>Device Types:
══════════════════════════════════════════════════════════════

BLOCK DEVICES:
• Data accessed in fixed-size blocks (512B, 4KB)
• Random access supported (seek)
• Usually buffered through block layer
• Examples: hard drives, SSDs, USB drives

$ ls -l /dev/sda
brw-rw---- 1 root disk 8, 0 Jan 15 10:00 /dev/sda
↑
b = block device


CHARACTER DEVICES:
• Data accessed as stream of bytes
• Usually sequential access only
• No buffering (direct to/from device)
• Examples: terminals, keyboards, serial ports

$ ls -l /dev/tty
crw-rw-rw- 1 root tty 5, 0 Jan 15 10:00 /dev/tty
↑
c = character device


Special Devices:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
/dev/null   - Discards all writes, EOF on read
/dev/zero   - Infinite stream of zeros
/dev/random - Random bytes (may block)
/dev/urandom- Random bytes (never blocks)</code></pre>
                </div>

                <div id="disk-structure" class="blog-content mt-5">
                    <h2><i class="fas fa-hdd me-2 text-teal"></i>Disk Structure</h2>
                    
                    <p>Understanding disk geometry is essential for disk scheduling algorithms.</p>

<pre class="language-text"><code>Hard Disk Drive (HDD) Structure:
══════════════════════════════════════════════════════════════

              Spindle
                │
    ┌───────────┴───────────┐
    │   ┌─────────────────┐   │
    │   │  ┌───────────┐  │   │  ← Platters
    │   │  │  Track   │  │   │     (spinning disks)
    │   │  │  [████]  │  │   │  ← Sector
    │   │  └───────────┘  │   │
    │   └─────────────────┘   │
    └───────────────────────┘
           \_______________/
            Actuator arm
            with read/write
            heads

Terminology:
• Platter: Spinning magnetic disk
• Track: Concentric circle on platter
• Sector: Smallest addressable unit (512B or 4KB)
• Cylinder: All tracks at same radius across platters

Access Time Components:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Seek time: Move arm to correct track (~5-10 ms)
2. Rotational latency: Wait for sector (~4 ms @ 7200 RPM)
3. Transfer time: Read data (~0.01 ms per sector)

Total: ~10 ms per random access!
SSD: ~0.1 ms (no mechanical parts)</code></pre>
                </div>

                <div id="disk-scheduling" class="blog-content mt-5">
                    <h2><i class="fas fa-sort-amount-up me-2 text-teal"></i>Disk Scheduling Algorithms</h2>
                    
                    <p><strong>Disk scheduling</strong> reorders I/O requests to minimize seek time. Critical for HDD performance.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-chart-bar me-2"></i>Scheduling Algorithms Comparison</h4>
                        <div class="content">
<pre class="language-text"><code>Example: Head at track 50, Queue: [98, 37, 14, 122, 65, 67]
Disk tracks 0-199


1. FCFS (First-Come First-Served):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Service in arrival order.
50→98→37→14→122→65→67
   48 + 61 + 23 + 108 + 57 + 2 = 299 tracks

✓ Fair, no starvation
✗ Poor performance (wild arm movement)


2. SSTF (Shortest Seek Time First):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Always go to nearest request.
50→65→67→37→14→98→122
   15 + 2 + 30 + 23 + 84 + 24 = 178 tracks

✓ Better than FCFS
✗ Starvation possible (distant requests)


3. SCAN (Elevator):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Move in one direction, service all, reverse.
50→65→67→98→122→(end)→37→14
   15 + 2 + 31 + 24 + 77 + 85 + 23 = 157 tracks

✓ No starvation, fair
✓ Good throughput


4. C-SCAN (Circular SCAN):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Only service in one direction, jump back.
50→65→67→98→122→(end)─jump→0→14→37

✓ More uniform wait time than SCAN
✓ No requests wait too long</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>SSDs Don't Need This!</strong> SSDs have no seek time (no mechanical parts), so disk scheduling is irrelevant. Modern Linux uses deadline or noop scheduler for SSDs.
                    </div>

<pre class="language-bash"><code># View current I/O scheduler
$ cat /sys/block/sda/queue/scheduler
noop deadline [cfq]

# Change scheduler
$ echo deadline | sudo tee /sys/block/sda/queue/scheduler

# For NVMe (usually uses none/noop)
$ cat /sys/block/nvme0n1/queue/scheduler
[none] mq-deadline</code></pre>
                </div>

                <div id="conclusion" class="blog-content mt-5">
                    <h2><i class="fas fa-flag-checkered me-2 text-teal"></i>Conclusion & Next Steps</h2>
                    
                    <p>I/O systems are the critical bridge between software and hardware. We've covered:</p>
                    
                    <ul>
                        <li><strong>I/O Hardware:</strong> Controllers, buses, and port/memory-mapped I/O</li>
                        <li><strong>Interrupts:</strong> Asynchronous device signaling</li>
                        <li><strong>DMA:</strong> Direct memory transfers without CPU</li>
                        <li><strong>Device Drivers:</strong> Kernel modules for hardware abstraction</li>
                        <li><strong>Block vs Character:</strong> Two fundamental device types</li>
                        <li><strong>Disk Structure:</strong> Platters, tracks, sectors, and access time</li>
                        <li><strong>Disk Scheduling:</strong> FCFS, SSTF, SCAN, C-SCAN algorithms</li>
                    </ul>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Key Insight:</strong> The massive speed gap between CPUs and I/O devices drives all I/O system design—interrupts let CPUs do useful work, DMA offloads transfers, and scheduling minimizes mechanical delays.
                    </div>

                    <div class="series-next">
                        <h4><i class="fas fa-arrow-right me-2"></i>Next in the Series</h4>
                        <p>In <a href="comp-arch-multiprocessor.html"><strong>Part 19: Multiprocessor Systems</strong></a>, we'll explore how operating systems manage multiple CPUs—SMP, NUMA architectures, and multiprocessor scheduling challenges.</p>
                    </div>
                </div>

                <div class="related-posts">
                    <h3><i class="fas fa-book me-2"></i>Continue the Computer Architecture & OS Series</h3>
                    <div class="related-post-item">
                        <h5>Part 17: File Systems & Storage</h5>
                        <p>Inodes, journaling, ext4, and NTFS.</p>
                        <a href="comp-arch-file-systems.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 19: Multiprocessor Systems</h5>
                        <p>SMP, NUMA, and multiprocessor scheduling.</p>
                        <a href="comp-arch-multiprocessor.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 22: Advanced Kernel Internals</h5>
                        <p>Linux I/O subsystem in depth.</p>
                        <a href="comp-arch-kernel-internals.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    <div id="categoryIndicator" class="category-indicator"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="../../../js/main.js"></script>
    <script src="../../../js/cookie-consent.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    <script>
        const themes = { 'prism-theme': 'Tomorrow Night', 'prism-default': 'Default', 'prism-dark': 'Dark', 'prism-twilight': 'Twilight', 'prism-okaidia': 'Okaidia', 'prism-solarizedlight': 'Solarized Light' };
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        function switchTheme(themeId) { Object.keys(themes).forEach(id => { const link = document.getElementById(id); if (link) link.disabled = true; }); const selectedLink = document.getElementById(themeId); if (selectedLink) { selectedLink.disabled = false; localStorage.setItem('prism-theme', themeId); } document.querySelectorAll('div.code-toolbar select').forEach(dropdown => { dropdown.value = themeId; }); setTimeout(() => Prism.highlightAll(), 10); }
        document.addEventListener('DOMContentLoaded', function() { switchTheme(savedTheme); });
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) { const select = document.createElement('select'); select.setAttribute('aria-label', 'Select code theme'); Object.keys(themes).forEach(themeId => { const option = document.createElement('option'); option.value = themeId; option.textContent = themes[themeId]; if (themeId === savedTheme) option.selected = true; select.appendChild(option); }); select.addEventListener('change', function(e) { switchTheme(e.target.value); }); return select; });
    </script>
</body>
</html>
