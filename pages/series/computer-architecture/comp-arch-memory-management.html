<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 15: Memory Management Fundamentals - Learn about address spaces, memory allocation, fragmentation, and OS memory management strategies." />
    <meta name="keywords" content="memory management, address space, memory allocation, fragmentation, contiguous allocation, paging, segmentation, buddy system, slab allocator" />
    
    <meta property="og:title" content="Part 15: Memory Management Fundamentals | Computer Architecture & OS Mastery" />
    <meta property="og:description" content="Master memory management: address spaces, allocation strategies, and fragmentation handling." />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://wasilzafar.com/pages/series/computer-architecture/comp-arch-memory-management.html" />
    <meta property="article:published_time" content="2026-01-31" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />

    <title>Part 15: Memory Management Fundamentals | Computer Architecture & OS Mastery - Wasil Zafar</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', { 'ad_storage': 'denied', 'ad_user_data': 'denied', 'ad_personalization': 'denied', 'analytics_storage': 'denied', 'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE'] });
        gtag('consent', 'default', { 'ad_storage': 'granted', 'ad_user_data': 'granted', 'ad_personalization': 'granted', 'analytics_storage': 'granted' });
        gtag('set', 'url_passthrough', true);
    </script>
    <script>
        (function(w, d, s, l, i) { w[l] = w[l] || []; w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'}); var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f); })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>
</head>
<body>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <section class="blog-hero">
        <div class="container py-5">
            <a href="../../categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
            <h1 class="display-4 fw-bold mt-4">Part 15: Memory Management Fundamentals</h1>
            <div class="blog-meta">
                <span><i class="fas fa-calendar me-2"></i>January 31, 2026</span>
                <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                <span class="reading-time"><i class="fas fa-clock me-1"></i>28 min read</span>
                <button onclick="window.print()" class="print-btn" title="Print this article"><i class="fas fa-print"></i> Print</button>
            </div>
            <p class="lead mt-3">Understand how operating systems manage physical memory—from allocation strategies to fragmentation handling.</p>
        </div>
    </section>

    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents"><i class="fas fa-list"></i></button>

    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li><a href="#introduction" onclick="closeNav()">Introduction</a></li>
            <li><a href="#address-spaces" onclick="closeNav()">Address Spaces</a></li>
            <li><a href="#contiguous-allocation" onclick="closeNav()">Contiguous Allocation</a></li>
            <li><a href="#fragmentation" onclick="closeNav()">Fragmentation</a></li>
            <li><a href="#segmentation" onclick="closeNav()">Segmentation</a></li>
            <li><a href="#paging-intro" onclick="closeNav()">Introduction to Paging</a></li>
            <li><a href="#buddy-system" onclick="closeNav()">Buddy System</a></li>
            <li><a href="#slab-allocator" onclick="closeNav()">Slab Allocator</a></li>
            <li><a href="#conclusion" onclick="closeNav()">Conclusion & Next Steps</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-memory me-2 text-teal"></i>Introduction</h2>
                    <p>Memory management is a core OS responsibility. The operating system must efficiently allocate memory to processes while minimizing waste and ensuring isolation.</p>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-sitemap me-2"></i>
                        <strong>Series Context:</strong> This is <strong>Part 15 of 24</strong> in the Computer Architecture & Operating Systems Mastery series. Building on cache and memory hierarchy, we explore OS-level memory management.
                    </div>

                    <div class="experiment-card" id="series-nav">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">24-Part Series</span>
                            <span class="badge bg-crimson">Computer Architecture & OS Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="comp-arch-foundations.html"><strong>Part 1:</strong> Foundations of Computer Systems</a> — System overview, architectures, OS role</li>
                                <li><a href="comp-arch-digital-logic.html"><strong>Part 2:</strong> Digital Logic & CPU Building Blocks</a> — Gates, registers, datapath, microarchitecture</li>
                                <li><a href="comp-arch-isa.html"><strong>Part 3:</strong> Instruction Set Architecture (ISA)</a> — RISC vs CISC, instruction formats, addressing</li>
                                <li><a href="comp-arch-assembly.html"><strong>Part 4:</strong> Assembly Language & Machine Code</a> — Registers, stack, calling conventions</li>
                                <li><a href="comp-arch-linkers-loaders.html"><strong>Part 5:</strong> Assemblers, Linkers & Loaders</a> — Object files, ELF, dynamic linking</li>
                                <li><a href="comp-arch-compilers.html"><strong>Part 6:</strong> Compilers & Program Translation</a> — Lexing, parsing, code generation</li>
                                <li><a href="comp-arch-cpu-pipelining.html"><strong>Part 7:</strong> CPU Execution & Pipelining</a> — Fetch-decode-execute, hazards, prediction</li>
                                <li><a href="comp-arch-os-kernel.html"><strong>Part 8:</strong> OS Architecture & Kernel Design</a> — Monolithic, microkernel, system calls</li>
                                <li><a href="comp-arch-processes.html"><strong>Part 9:</strong> Processes & Program Execution</a> — Process lifecycle, PCB, fork/exec</li>
                                <li><a href="comp-arch-threads-concurrency.html"><strong>Part 10:</strong> Threads & Concurrency</a> — Threading models, pthreads, race conditions</li>
                                <li><a href="comp-arch-cpu-scheduling.html"><strong>Part 11:</strong> CPU Scheduling Algorithms</a> — FCFS, RR, CFS, real-time scheduling</li>
                                <li><a href="comp-arch-synchronization.html"><strong>Part 12:</strong> Synchronization & Coordination</a> — Locks, semaphores, classic problems</li>
                                <li><a href="comp-arch-deadlocks.html"><strong>Part 13:</strong> Deadlocks & Prevention</a> — Coffman conditions, Banker's algorithm</li>
                                <li><a href="comp-arch-cache-memory-hierarchy.html"><strong>Part 14:</strong> Memory Hierarchy & Cache</a> — L1/L2/L3, cache coherence, NUMA</li>
                                <li><strong>Part 15: Memory Management Fundamentals (This Guide)</strong> — Address spaces, fragmentation, allocation</li>
                                <li><a href="comp-arch-virtual-memory.html"><strong>Part 16:</strong> Virtual Memory & Paging</a> — Page tables, TLB, demand paging</li>
                                <li><a href="comp-arch-file-systems.html"><strong>Part 17:</strong> File Systems & Storage</a> — Inodes, journaling, ext4, NTFS</li>
                                <li><a href="comp-arch-io-devices.html"><strong>Part 18:</strong> I/O Systems & Device Drivers</a> — Interrupts, DMA, disk scheduling</li>
                                <li><a href="comp-arch-multiprocessor.html"><strong>Part 19:</strong> Multiprocessor Systems</a> — SMP, NUMA, cache coherence</li>
                                <li><a href="comp-arch-security.html"><strong>Part 20:</strong> OS Security & Protection</a> — Privilege levels, ASLR, sandboxing</li>
                                <li><a href="comp-arch-virtualization.html"><strong>Part 21:</strong> Virtualization & Containers</a> — Hypervisors, namespaces, cgroups</li>
                                <li><a href="comp-arch-kernel-internals.html"><strong>Part 22:</strong> Advanced Kernel Internals</a> — Linux subsystems, kernel debugging</li>
                                <li><a href="comp-arch-case-studies.html"><strong>Part 23:</strong> Case Studies</a> — Linux vs Windows vs macOS</li>
                                <li><a href="comp-arch-capstone-projects.html"><strong>Part 24:</strong> Capstone Projects</a> — Shell, thread pool, paging simulator</li>
                            </ol>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-question-circle me-2"></i>
                        <strong>The Core Challenge:</strong> Every process needs memory, but physical RAM is limited. How does the OS allocate memory efficiently, prevent processes from interfering with each other, and handle memory that runs out?
                    </div>
                </div>

                <div id="address-spaces" class="blog-content mt-5">
                    <h2><i class="fas fa-map me-2 text-teal"></i>Address Spaces</h2>
                    
                    <p>An <strong>address space</strong> is the range of addresses a program can use. Modern systems use separate address spaces for each process.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-eye me-2"></i>Physical vs Logical Addresses</h4>
                        <div class="content">
<pre class="language-text"><code>Address Types:
══════════════════════════════════════════════════════════════

PHYSICAL ADDRESS:
• Actual location in hardware RAM chips
• What memory controller sees on the bus
• Range: 0 to (RAM size - 1)
• Example: 0x0000_7FFF_ABCD_1234 (physical location)

LOGICAL (VIRTUAL) ADDRESS:
• Address used by program/process
• What CPU generates during execution
• Each process has its own address space
• Example: 0x0040_0000 (process's view)


Address Translation:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────┐   Logical    ┌─────────────┐  Physical   ┌────────┐
│   CPU   │ ───────────→ │     MMU     │ ──────────→ │  RAM   │
│         │   Address    │ (Memory     │   Address   │        │
└─────────┘              │  Mgmt Unit) │             └────────┘
                         └─────────────┘

Process A: 0x1000 → MMU → Physical 0x50000
Process B: 0x1000 → MMU → Physical 0x80000

Same virtual address → Different physical locations!
This enables ISOLATION between processes.</code></pre>
                        </div>
                    </div>

<pre class="language-bash"><code># View process memory map on Linux
$ cat /proc/self/maps
00400000-00401000 r-xp 00000000 08:01 1234  /bin/cat  # Code
00600000-00601000 r--p 00000000 08:01 1234  /bin/cat  # Read-only data
00601000-00602000 rw-p 00001000 08:01 1234  /bin/cat  # Data
7f8a12340000-7f8a12500000 r-xp ...         /lib/libc.so
7ffd45670000-7ffd45691000 rw-p ...         [stack]
7ffd456fe000-7ffd45700000 r-xp ...         [vdso]

# Permissions: r=read, w=write, x=execute, p=private, s=shared</code></pre>
                </div>

                <div id="contiguous-allocation" class="blog-content mt-5">
                    <h2><i class="fas fa-bars me-2 text-teal"></i>Contiguous Allocation</h2>
                    
                    <p>Early systems allocated each process a <strong>single contiguous block</strong> of memory. Simple but problematic.</p>

<pre class="language-text"><code>Contiguous Memory Allocation:
══════════════════════════════════════════════════════════════

Memory State After Loading Processes:
┌─────────────────────────────────────┐ 0x00000000
│           OS Kernel                 │
├─────────────────────────────────────┤ 0x00100000
│         Process A (2 MB)            │
├─────────────────────────────────────┤ 0x00300000
│         Process B (4 MB)            │
├─────────────────────────────────────┤ 0x00700000
│         Process C (1 MB)            │
├─────────────────────────────────────┤ 0x00800000
│              FREE                   │
│           (8 MB hole)               │
└─────────────────────────────────────┘ 0x01000000


Allocation Strategies (for choosing which hole):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. FIRST FIT
   • Allocate first hole big enough
   • Fast - stop searching once found
   • Tends to leave small holes at start

2. BEST FIT
   • Allocate smallest hole that fits
   • Leaves smallest leftover fragments
   • Must search entire list (slow)
   • Creates many tiny unusable holes

3. WORST FIT
   • Allocate largest hole
   • Leaves largest leftover (may be useful)
   • Must search entire list (slow)
   • Poor in practice

Empirical results: First Fit ≈ Best Fit &gt; Worst Fit</code></pre>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Hardware Support:</strong> Contiguous allocation uses base and limit registers. Base = start address, Limit = size. CPU checks: base ≤ address &lt; base + limit. Violation = segmentation fault!
                    </div>
                </div>

                <div id="fragmentation" class="blog-content mt-5">
                    <h2><i class="fas fa-puzzle-piece me-2 text-teal"></i>Fragmentation</h2>
                    
                    <p><strong>Fragmentation</strong> is wasted memory that can't be used. Two types plague memory managers.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-cut me-2"></i>External vs Internal Fragmentation</h4>
                        <div class="content">
<pre class="language-text"><code>EXTERNAL FRAGMENTATION:
══════════════════════════════════════════════════════════════
Free memory exists but is scattered in small non-contiguous holes.

After Process B exits:
┌─────────────────┐
│    OS Kernel    │
├─────────────────┤
│   Process A     │ 2 MB
├─────────────────┤
│    FREE HOLE    │ 4 MB  ←─┐
├─────────────────┤         │ Total free: 12 MB
│   Process C     │ 1 MB    │ But can't fit 8 MB process!
├─────────────────┤         │
│    FREE HOLE    │ 8 MB ←──┘
└─────────────────┘

Solution: COMPACTION
• Move processes to create one large free block
• Expensive - must copy all process memory
• Only possible if relocation is dynamic


INTERNAL FRAGMENTATION:
══════════════════════════════════════════════════════════════
Allocated memory is larger than requested (wasted inside block).

Process requests 1000 bytes, system allocates 4096 (one page):
┌─────────────────────────────────────┐
│ Used: 1000 bytes │ Wasted: 3096    │
│ ████████████████ │                 │
└─────────────────────────────────────┘
                     ↑
           Internal fragmentation

Causes:
• Fixed-size allocation units (pages, blocks)
• Alignment requirements (8-byte, cache-line)
• Power-of-2 allocators</code></pre>
                        </div>
                    </div>
                </div>

                <div id="segmentation" class="blog-content mt-5">
                    <h2><i class="fas fa-th-large me-2 text-teal"></i>Segmentation</h2>
                    
                    <p><strong>Segmentation</strong> divides a process into logical segments (code, data, stack, heap). Each segment can be placed anywhere in memory.</p>

<pre class="language-text"><code>Segmentation Model:
══════════════════════════════════════════════════════════════

Logical View (Process):           Physical Memory:
┌─────────────────────┐           ┌─────────────────────┐
│ Segment 0: Code     │ ─────────→│                     │
├─────────────────────┤           │  Segment 2 (Stack)  │
│ Segment 1: Data     │ ───┐      ├─────────────────────┤
├─────────────────────┤    │      │  Process B code     │
│ Segment 2: Stack    │ ─┐ │      ├─────────────────────┤
├─────────────────────┤  │ └─────→│  Segment 1 (Data)   │
│ Segment 3: Heap     │  │        ├─────────────────────┤
└─────────────────────┘  │        │  Segment 0 (Code)   │
                         │        ├─────────────────────┤
                         └───────→│                     │
                                  └─────────────────────┘

Segments don't need to be contiguous!


Segment Table:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Segment#   Base          Limit      Permissions
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   0       0x00400000    0x10000    R-X (code)
   1       0x00600000    0x05000    RW- (data)
   2       0x7FFF0000    0x10000    RW- (stack)
   3       0x00800000    0x20000    RW- (heap)

Address Translation:
Logical: (segment#, offset) → Physical: base[segment#] + offset

Example: (1, 0x1234) → 0x00600000 + 0x1234 = 0x00601234</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Segmentation Problems:</strong> Still suffers from external fragmentation (segments vary in size). Modern systems use paging instead, though x86 supports both (segmentation mostly disabled in 64-bit mode).
                    </div>
                </div>

                <div id="paging-intro" class="blog-content mt-5">
                    <h2><i class="fas fa-th me-2 text-teal"></i>Introduction to Paging</h2>
                    
                    <p><strong>Paging</strong> divides memory into fixed-size blocks. Virtual memory uses pages; physical memory uses frames. No external fragmentation!</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-grid me-2"></i>Paging Concept</h4>
                        <div class="content">
<pre class="language-text"><code>Paging Basics:
══════════════════════════════════════════════════════════════

Page: Fixed-size block of virtual memory (typically 4 KB)
Frame: Fixed-size block of physical memory (same size as page)

Virtual Address Space:        Physical Memory (Frames):
┌─────────┐ Page 0            ┌─────────┐ Frame 0
├─────────┤ Page 1            ├─────────┤ Frame 1  ←── Page 3
├─────────┤ Page 2            ├─────────┤ Frame 2  ←── Page 0
├─────────┤ Page 3            ├─────────┤ Frame 3  ←── Page 5
├─────────┤ Page 4            ├─────────┤ Frame 4
├─────────┤ Page 5            ├─────────┤ Frame 5  ←── Page 2
└─────────┘                   └─────────┘

Pages can map to ANY frame - no contiguity required!


Address Translation:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Virtual Address (32-bit, 4KB pages):

│◄────────── 32 bits ──────────►│
┌────────────────────┬──────────┐
│    Page Number     │  Offset  │
│      20 bits       │ 12 bits  │
└────────────────────┴──────────┘

• Offset: 12 bits = 4096 bytes = 4 KB page size
• Page Number: Index into page table
• Page table maps page# → frame#

Example: Virtual 0x00001234 with 4KB pages
  Page# = 0x00001 = 1
  Offset = 0x234
  If page 1 → frame 7: Physical = 0x00007234</code></pre>
                        </div>
                    </div>

<pre class="language-bash"><code># Check page size on Linux
$ getconf PAGE_SIZE
4096

# View huge page support
$ cat /proc/meminfo | grep Huge
HugePages_Total:       0
HugePages_Free:        0
Hugepagesize:       2048 kB   # 2 MB huge pages available</code></pre>
                </div>

                <div id="buddy-system" class="blog-content mt-5">
                    <h2><i class="fas fa-users me-2 text-teal"></i>Buddy System Allocator</h2>
                    
                    <p>The <strong>buddy system</strong> allocates memory in power-of-2 sizes. Used by Linux for page-level allocation.</p>

<pre class="language-text"><code>Buddy System Algorithm:
══════════════════════════════════════════════════════════════

Rules:
• Memory blocks are powers of 2 (1, 2, 4, 8... pages)
• Split larger blocks when needed
• Merge adjacent "buddies" when freed

Example: Allocate 3 pages from 16-page pool

1. Start: One 16-page block
   [████████████████] 16

2. Need 3 pages → round up to 4. Split 16 → 8+8
   [████████][████████] 8 | 8

3. Split one 8 → 4+4
   [████][████][████████] 4 | 4 | 8

4. Allocate one 4-page block
   [USED][████][████████] 4 | 4 | 8

Free lists by order:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Order 0 (1 page):   [empty]
Order 1 (2 pages):  [empty]
Order 2 (4 pages):  [0x1004000]
Order 3 (8 pages):  [0x1008000]
Order 4 (16 pages): [empty]


Buddy Address Calculation:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
For block at address A with size 2^k pages:
Buddy address = A XOR (2^k × page_size)

Example: Block at 0x1000, size 4KB (2^0 = 1 page)
Buddy = 0x1000 XOR 0x1000 = 0x0000 or 0x2000

If buddy is also free → MERGE into larger block</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Linux Usage:</strong> Check buddy allocator status with <code>cat /proc/buddyinfo</code>. Shows free blocks at each order (0-10) for each memory zone.
                    </div>
                </div>

                <div id="slab-allocator" class="blog-content mt-5">
                    <h2><i class="fas fa-cubes me-2 text-teal"></i>Slab Allocator</h2>
                    
                    <p>The <strong>slab allocator</strong> efficiently allocates small, frequently-used kernel objects. Built on top of the buddy system.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-layer-group me-2"></i>Slab Architecture</h4>
                        <div class="content">
<pre class="language-text"><code>Slab Allocator Hierarchy:
══════════════════════════════════════════════════════════════

                    ┌─────────────────┐
                    │  Kernel Object  │  e.g., task_struct
                    │    Request      │
                    └────────┬────────┘
                             ↓
┌─────────────────────────────────────────────────────────────┐
│                         CACHE                               │
│  (One per object type: task_struct cache, inode cache...)   │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                     │
│  │  SLAB   │  │  SLAB   │  │  SLAB   │  ...                │
│  │ (full)  │  │(partial)│  │ (empty) │                     │
│  └─────────┘  └─────────┘  └─────────┘                     │
└─────────────────────────────────────────────────────────────┘

Each SLAB contains:
┌─────────────────────────────────────────────────────────────┐
│ [obj][obj][obj][obj][obj][obj][obj][obj]                   │
│  ↑    ↑    ↑                                                │
│  Used Used Free (linked together in free list)             │
└─────────────────────────────────────────────────────────────┘


Benefits:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. No fragmentation - objects are same size within cache
2. Fast allocation - grab from free list, O(1)
3. Cache coloring - spread objects across cache lines
4. Object reuse - freed objects can be reused without init</code></pre>
                        </div>
                    </div>

<pre class="language-bash"><code># View slab caches on Linux
$ cat /proc/slabinfo | head -20
slabinfo - version: 2.1
# name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt;
task_struct          312        330      6784         4
inode_cache         1847       1890       768        21
dentry              4521       4830       192        21

# Better view with slabtop
$ sudo slabtop -o
 Active / Total Objects (% used)    : 89234 / 95420 (93.5%)
 Active / Total Slabs (% used)      : 3456 / 3456 (100.0%)

 OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME
12345  11234  91%    0.19K    588       21      2352K dentry
 8901   8500  95%    6.67K   2225        4      8900K task_struct</code></pre>
                </div>

                <div id="conclusion" class="blog-content mt-5">
                    <h2><i class="fas fa-flag-checkered me-2 text-teal"></i>Conclusion & Next Steps</h2>
                    
                    <p>Memory management is foundational to OS design. We've covered:</p>
                    
                    <ul>
                        <li><strong>Address Spaces:</strong> Physical vs logical addressing</li>
                        <li><strong>Contiguous Allocation:</strong> First fit, best fit, worst fit</li>
                        <li><strong>Fragmentation:</strong> External and internal waste</li>
                        <li><strong>Segmentation:</strong> Logical memory division</li>
                        <li><strong>Paging:</strong> Fixed-size pages eliminate external fragmentation</li>
                        <li><strong>Buddy System:</strong> Power-of-2 page allocation</li>
                        <li><strong>Slab Allocator:</strong> Efficient small object allocation</li>
                    </ul>

                    <div class="highlight-box">
                        <i class="fas fa-key me-2"></i>
                        <strong>Key Insight:</strong> Paging is the foundation of modern virtual memory. By using fixed-size pages, we eliminate external fragmentation and enable powerful features like demand paging and copy-on-write.
                    </div>

                    <div class="series-next">
                        <h4><i class="fas fa-arrow-right me-2"></i>Next in the Series</h4>
                        <p>In <a href="comp-arch-virtual-memory.html"><strong>Part 16: Virtual Memory & Paging</strong></a>, we'll dive deep into page tables, TLB, demand paging, and page replacement algorithms.</p>
                    </div>
                </div>

                <div class="related-posts">
                    <h3><i class="fas fa-book me-2"></i>Continue the Computer Architecture & OS Series</h3>
                    <div class="related-post-item">
                        <h5>Part 14: Memory Hierarchy & Cache</h5>
                        <p>L1/L2/L3 caches, cache coherence, and NUMA.</p>
                        <a href="comp-arch-cache-memory-hierarchy.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 16: Virtual Memory & Paging</h5>
                        <p>Page tables, TLB, and demand paging.</p>
                        <a href="comp-arch-virtual-memory.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 22: Advanced Kernel Internals</h5>
                        <p>Linux memory subsystems in depth.</p>
                        <a href="comp-arch-kernel-internals.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    <div id="categoryIndicator" class="category-indicator"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="../../../js/main.js"></script>
    <script src="../../../js/cookie-consent.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    <script>
        const themes = { 'prism-theme': 'Tomorrow Night', 'prism-default': 'Default', 'prism-dark': 'Dark', 'prism-twilight': 'Twilight', 'prism-okaidia': 'Okaidia', 'prism-solarizedlight': 'Solarized Light' };
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        function switchTheme(themeId) { Object.keys(themes).forEach(id => { const link = document.getElementById(id); if (link) link.disabled = true; }); const selectedLink = document.getElementById(themeId); if (selectedLink) { selectedLink.disabled = false; localStorage.setItem('prism-theme', themeId); } document.querySelectorAll('div.code-toolbar select').forEach(dropdown => { dropdown.value = themeId; }); setTimeout(() => Prism.highlightAll(), 10); }
        document.addEventListener('DOMContentLoaded', function() { switchTheme(savedTheme); });
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) { const select = document.createElement('select'); select.setAttribute('aria-label', 'Select code theme'); Object.keys(themes).forEach(themeId => { const option = document.createElement('option'); option.value = themeId; option.textContent = themes[themeId]; if (themeId === savedTheme) option.selected = true; select.appendChild(option); }); select.addEventListener('change', function(e) { switchTheme(e.target.value); }); return select; });
    </script>
</body>
</html>
