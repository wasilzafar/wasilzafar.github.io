<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kernel Development Series - Phase 6: Memory Management | Wasil Zafar</title>
    <meta name="description" content="Implement paging, virtual memory, and a heap allocator for dynamic memory management in your operating system kernel.">
    <meta name="keywords" content="kernel development, memory management, paging, virtual memory, heap allocator, malloc, page tables, OS development">
    <meta name="author" content="Wasil Zafar">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Kernel Development Series - Phase 6: Memory Management">
    <meta property="og:description" content="Implement paging, virtual memory, and a heap allocator for dynamic memory management in your operating system kernel.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://wasilzafar.com/pages/series/kernel-development/kernel-dev-phase-06-memory.html">
    <meta property="og:image" content="https://wasilzafar.com/images/og-kernel-dev.png">
    <meta property="article:published_time" content="2026-02-06">
    <meta property="article:author" content="Wasil Zafar">
    <meta property="article:section" content="Technology">

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-PBS8M2JR');</script>
    
    <!-- Google Consent Mode v2 -->
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('consent', 'default', {
        'ad_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied',
        'analytics_storage': 'denied',
        'wait_for_update': 500
      });
    </script>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../../../images/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Poppins:wght@400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Prism.js Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />
    
    <!-- Main CSS -->
    <link rel="stylesheet" href="../../../css/main.css">
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript>
        <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>

    <!-- GDPR Cookie Consent Banner -->
    <div id="cookieBanner" class="light display-bottom" style="display: none;">
        <div id="closeIcon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                <path fill="currentColor" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"></path>
            </svg>
        </div>
        
        <div class="content-wrap">
            <div class="msg-wrap">
                <div class="title-wrap">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="20" height="20">
                        <path fill="#3B9797" d="M510.52 255.82c-69.97-.85-126.47-57.69-126.47-127.86-70.17 0-127-56.49-127.86-126.45-27.26-4.14-55.13.3-79.72 12.82l-69.13 35.22a132.221 132.221 0 0 0-57.79 57.81l-35.1 68.88a132.645 132.645 0 0 0-12.82 80.95l12.08 76.27a132.521 132.521 0 0 0 37.16 70.37l54.64 54.64a132.036 132.036 0 0 0 70.37 37.16l76.27 12.15c27.51 4.36 55.7-.11 80.95-12.8l68.88-35.08a132.166 132.166 0 0 0 57.79-57.81l35.1-68.88c12.56-24.64 17.01-52.58 12.91-79.91zM176 368c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32zm32-160c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32zm160 128c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32z"></path>
                    </svg>
                    <h4 style="margin: 0; font-size: 18px; color: var(--color-navy); font-weight: 700;">Cookie Consent</h4>
                </div>
                <p style="font-size: 14px; line-height: 1.6; color: var(--color-navy); margin-bottom: 15px;">
                    We use cookies to enhance your browsing experience, serve personalized content, and analyze our traffic. 
                    By clicking "Accept All", you consent to our use of cookies. See our 
                    <a href="/privacy-policy.html" style="color: var(--color-teal); border-bottom: 1px dotted var(--color-teal);">Privacy Policy</a> 
                    for more information.
                </p>
                
                <div id="cookieSettings" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="14" height="14">
                        <path fill="currentColor" d="M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z"></path>
                    </svg>
                    <span style="margin-left: 5px; font-size: 12px; font-weight: 600; color: var(--color-navy);">Customize Settings</span>
                </div>
                
                <div id="cookieTypes" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(59, 151, 151, 0.2);">
                    <h5 style="font-size: 12px; font-weight: 700; color: var(--color-navy); margin-bottom: 10px; text-transform: uppercase;">Cookie Preferences</h5>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" checked disabled style="margin-top: 2px; margin-right: 8px; cursor: not-allowed;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Essential Cookies (Required)</strong>
                                <span style="font-size: 12px; color: #666;">Necessary for the website to function properly.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" id="analyticsCookies" checked style="margin-top: 2px; margin-right: 8px;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Analytics Cookies</strong>
                                <span style="font-size: 12px; color: #666;">Help us understand how you interact with the website.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" id="marketingCookies" style="margin-top: 2px; margin-right: 8px;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Marketing Cookies</strong>
                                <span style="font-size: 12px; color: #666;">Used to deliver relevant advertisements.</span>
                            </div>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="btn-wrap">
                <button id="cookieAccept" style="background: var(--color-teal); color: white; font-weight: 600;">Accept All</button>
                <button id="cookieReject" style="background: transparent; color: var(--color-navy); border: 2px solid var(--color-teal); font-weight: 600;">Reject All</button>
                <button id="cookieSave" style="background: var(--color-blue); color: white; font-weight: 600; display: none;">Save Preferences</button>
            </div>
        </div>
    </div>

    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/">
                <span class="gradient-text">Wasil Zafar</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#about">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#skills">Skills</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#certifications">Certifications</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#interests">Interests</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link">
                    <i class="fas fa-arrow-left me-2"></i>Back to Technology
                </a>
                <h1 class="display-4 fw-bold mb-3">Phase 6: Memory Management</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>February 6, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>30 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
                <p class="lead">Implement paging for virtual memory, build a physical frame allocator, and create a heap allocator so your kernel can dynamically allocate memory with malloc/free.</p>
            </div>
        </div>
    </section>

    <!-- Table of Contents Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation Overlay -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li>
                <a href="#introduction" onclick="closeNav()">Introduction</a>
                <ul>
                    <li><a href="#why-virtual-memory" onclick="closeNav()">Why Virtual Memory?</a></li>
                    <li><a href="#memory-overview" onclick="closeNav()">Memory Architecture Overview</a></li>
                </ul>
            </li>
            <li>
                <a href="#physical-memory" onclick="closeNav()">Physical Memory</a>
                <ul>
                    <li><a href="#memory-map" onclick="closeNav()">Memory Map</a></li>
                    <li><a href="#frame-allocator" onclick="closeNav()">Frame Allocator</a></li>
                    <li><a href="#bitmap-allocator" onclick="closeNav()">Bitmap Allocator</a></li>
                </ul>
            </li>
            <li>
                <a href="#paging" onclick="closeNav()">Paging</a>
                <ul>
                    <li><a href="#page-tables" onclick="closeNav()">Page Tables</a></li>
                    <li><a href="#page-directory" onclick="closeNav()">Page Directory</a></li>
                    <li><a href="#address-translation" onclick="closeNav()">Address Translation</a></li>
                    <li><a href="#enabling-paging" onclick="closeNav()">Enabling Paging</a></li>
                </ul>
            </li>
            <li>
                <a href="#virtual-memory" onclick="closeNav()">Virtual Memory</a>
                <ul>
                    <li><a href="#address-space" onclick="closeNav()">Address Space Layout</a></li>
                    <li><a href="#page-faults" onclick="closeNav()">Page Faults</a></li>
                    <li><a href="#demand-paging" onclick="closeNav()">Demand Paging</a></li>
                </ul>
            </li>
            <li>
                <a href="#heap" onclick="closeNav()">Heap Allocator</a>
                <ul>
                    <li><a href="#heap-design" onclick="closeNav()">Heap Design</a></li>
                    <li><a href="#malloc" onclick="closeNav()">malloc Implementation</a></li>
                    <li><a href="#free" onclick="closeNav()">free Implementation</a></li>
                    <li><a href="#fragmentation" onclick="closeNav()">Fragmentation</a></li>
                </ul>
            </li>
            <li><a href="#build" onclick="closeNav()">What You Can Build</a></li>
            <li><a href="#next-steps" onclick="closeNav()">Next Steps</a></li>
        </ol>
    </div>

    <!-- Overlay Backdrop -->
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Main Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <!-- Introduction -->
                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-memory me-2 text-teal"></i>Introduction: The Memory Problem</h2>
                    
                    <div class="highlight-box crimson">
                        <i class="fas fa-flag me-2"></i>
                        <strong>Phase 6 Goals:</strong> By the end of this phase, your kernel will have virtual memory via paging, a physical frame allocator, and a working heap with malloc() and free(). Your kernel can now dynamically allocate memory at runtime.
                    </div>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">18-Part Series</span>
                            <span class="badge bg-crimson">OS Development Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="kernel-dev-phase-00-orientation.html">Phase 0: Orientation & Big Picture</a> - OS fundamentals, kernel architectures, learning path</li>
                                <li><a href="kernel-dev-phase-01-boot-process.html">Phase 1: How a Computer Starts</a> - BIOS/UEFI, boot sequence, dev environment</li>
                                <li><a href="kernel-dev-phase-02-real-mode.html">Phase 2: Real Mode - First Steps</a> - Real mode, bootloader, BIOS interrupts</li>
                                <li><a href="kernel-dev-phase-03-protected-mode.html">Phase 3: Entering Protected Mode</a> - GDT, 32-bit mode, C code execution</li>
                                <li><a href="kernel-dev-phase-04-display-input.html">Phase 4: Display, Input & Output</a> - VGA text mode, keyboard handling</li>
                                <li><a href="kernel-dev-phase-05-interrupts.html">Phase 5: Interrupts & CPU Control</a> - IDT, ISRs, PIC programming</li>
                                <li><strong>Phase 6: Memory Management (This Guide)</strong> - Paging, virtual memory, heap allocator</li>
                                <li><a href="kernel-dev-phase-07-filesystem.html">Phase 7: Disk Access & Filesystems</a> - Block devices, FAT, VFS layer</li>
                                <li><a href="kernel-dev-phase-08-processes.html">Phase 8: Processes & User Mode</a> - Task switching, system calls, user space</li>
                                <li><a href="kernel-dev-phase-09-elf.html">Phase 9: ELF Loading & Executables</a> - ELF format, program loading</li>
                                <li><a href="kernel-dev-phase-10-stdlib-shell.html">Phase 10: Standard Library & Shell</a> - C library, command-line shell</li>
                                <li><a href="kernel-dev-phase-11-long-mode.html">Phase 11: 64-Bit Long Mode</a> - x86-64, 64-bit paging, modern architecture</li>
                                <li><a href="kernel-dev-phase-12-uefi.html">Phase 12: Modern Booting with UEFI</a> - UEFI boot services, memory maps</li>
                                <li><a href="kernel-dev-phase-13-graphics.html">Phase 13: Graphics & GUI Systems</a> - Framebuffer, windowing, drawing</li>
                                <li><a href="kernel-dev-phase-14-input-timing.html">Phase 14: Advanced Input & Timing</a> - Mouse, high-precision timers</li>
                                <li><a href="kernel-dev-phase-15-hardware-drivers.html">Phase 15: Hardware Discovery & Drivers</a> - PCI, device drivers, NVMe</li>
                                <li><a href="kernel-dev-phase-16-performance.html">Phase 16: Performance & Optimization</a> - Caching, scheduler tuning</li>
                                <li><a href="kernel-dev-phase-17-security.html">Phase 17: Stability, Security & Finishing</a> - Debugging, hardening, completion</li>
                            </ol>
                        </div>
                    </div>
                    
                    <p>Until now, your kernel has been using memory in a simple way: hardcoded addresses, no protection, and no dynamic allocation. This approach doesn't scale—what happens when you want to run multiple programs, each thinking they own all of memory?</p>

<pre><code class="language-plaintext">THE MEMORY PROBLEM
═══════════════════════════════════════════════════════════════

Without Virtual Memory:
┌───────────────────────────────────────────────────────────────┐
│  0x00000000  ┌─────────────────────┐                         │
│              │    Your Kernel      │                         │
│  0x00100000  ├─────────────────────┤                         │
│              │    Program A        │ ← Hardcoded to 0x100000 │
│  0x00200000  ├─────────────────────┤                         │
│              │    Program B        │ ← Must avoid A's memory │
│              └─────────────────────┘                         │
│                                                               │
│  ❌ Programs must know physical addresses                     │
│  ❌ Programs can read/write each other's memory               │
│  ❌ What if A wants more memory? Must relocate B!             │
│  ❌ What if memory is fragmented?                             │
└───────────────────────────────────────────────────────────────┘

With Virtual Memory:
┌───────────────────────────────────────────────────────────────┐
│  Program A's View:          Program B's View:                 │
│  ┌─────────────────┐       ┌─────────────────┐               │
│  │ 0x00000000      │       │ 0x00000000      │               │
│  │   My Code       │       │   My Code       │               │
│  │ 0x00400000      │       │ 0x00400000      │               │
│  │   My Data       │       │   My Data       │               │
│  └─────────────────┘       └─────────────────┘               │
│  Both think they start     Both are ISOLATED                  │
│  at address 0!             from each other!                   │
│                                                               │
│  ✅ Programs use virtual addresses (they don't know physical) │
│  ✅ Each program has its own isolated address space           │
│  ✅ Memory can be allocated dynamically                       │
│  ✅ Physical memory can be scattered (no fragmentation issue) │
└───────────────────────────────────────────────────────────────┘</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb"></i>
                        <strong>Key Insight:</strong> Virtual memory creates the illusion that each process has its own private memory space, even though physical RAM is shared. This is the foundation of memory protection and modern multitasking.
                    </div>

                    <h3 id="why-virtual-memory">Why Virtual Memory?</h3>
                    
<pre><code class="language-plaintext">BENEFITS OF VIRTUAL MEMORY
═══════════════════════════════════════════════════════════════

1. ISOLATION & PROTECTION
   ┌────────────────────────────────────────────────────────────┐
   │  Process A   │   Kernel    │  Process B                   │
   │  (User Mode) │  (Ring 0)   │  (User Mode)                 │
   │    ┌───┐     │   ┌───┐     │    ┌───┐                     │
   │    │ P │     │   │ K │     │    │ P │                     │
   │    │ A │     │   │ E │     │    │ B │                     │
   │    │ G │     │   │ R │     │    │ G │                     │
   │    │ E │     │   │ N │     │    │ E │                     │
   │    │ S │     │   │ E │     │    │ S │                     │
   │    └───┘     │   │ L │     │    └───┘                     │
   │       ×      │   └───┘     │       ×                      │
   │   Can't      │    ✓       │   Can't                      │
   │   access B   │  Can access │   access A                   │
   │   or Kernel  │   everything│   or Kernel                   │
   └────────────────────────────────────────────────────────────┘

2. MEMORY OVERCOMMIT
   Physical RAM: 4 GB
   But you can run:
   - Chrome (2 GB virtual)
   - VS Code (1 GB virtual)
   - Your OS (1 GB virtual)
   - Several other apps...
   
   How? Most memory isn't actively used at once!
   Demand paging loads only what's needed.

3. SIMPLER PROGRAM LOADING
   Every program links to run at address 0x00400000
   Virtual memory maps it to whatever physical RAM is free!

4. MEMORY-MAPPED FILES
   File contents appear in memory without explicit read() calls
   Changes automatically write back to disk</code></pre>

                    <h3 id="memory-overview">Memory Architecture Overview</h3>
                    
                    <p>Here's the complete memory management stack we'll build:</p>

<pre><code class="language-plaintext">MEMORY MANAGEMENT LAYERS
═══════════════════════════════════════════════════════════════

Layer 4: User Applications
          └── malloc(), free(), new, delete
              ↓ system calls
Layer 3: Kernel Heap (kmalloc/kfree)
          └── Variable-sized allocations for kernel use
              ↓ uses
Layer 2: Virtual Memory Manager
          └── Map virtual pages to physical frames
          └── Handle page faults
          └── Manage address spaces per process
              ↓ uses
Layer 1: Paging Unit (MMU Hardware)
          └── Page Directory → Page Tables → Physical Frames
          └── Address translation (virtual → physical)
          └── Protection (R/W, User/Supervisor)
              ↓ allocates from
Layer 0: Physical Frame Allocator
          └── Track which 4KB frames are free/used
          └── Bitmap or linked list of free frames
              ↓ queries
Hardware: Physical RAM (detected via E820 or UEFI memory map)

═══════════════════════════════════════════════════════════════
In this phase, we build Layers 0, 1, 2, and 3!</code></pre>
                </div>

                <!-- Physical Memory Section -->
                <div id="physical-memory" class="blog-content mt-5">
                    <h2><i class="fas fa-microchip me-2 text-teal"></i>Physical Memory Management</h2>
                    
                    <p>Before we can implement virtual memory, we need to track <strong>physical memory</strong>: which 4KB chunks (frames) are free and which are used.</p>
                    
                    <h3 id="memory-map">Memory Map</h3>
                    
                    <p>The BIOS provides a memory map via INT 0x15, EAX=0xE820 (the "E820" map). This tells us which regions of physical memory are usable:</p>

<pre><code class="language-plaintext">TYPICAL PC MEMORY MAP (E820)
═══════════════════════════════════════════════════════════════

Address              Size         Type        Description
───────────────────────────────────────────────────────────────
0x00000000-0x0009FBFF  ~640 KB     Usable      Conventional memory
0x0009FC00-0x0009FFFF  ~1 KB       Reserved    EBDA (Extended BIOS Data)
0x000A0000-0x000BFFFF  128 KB      Reserved    VGA memory (0xB8000 text)
0x000C0000-0x000FFFFF  256 KB      Reserved    ROM area (BIOS, option ROMs)
0x00100000-0x????????  Varies      Usable      Extended memory (RAM!)
      ...              ...         ...         ...
0xFEC00000-0xFECFFFFF  64 KB       Reserved    IOAPIC
0xFEE00000-0xFEEFFFFF  64 KB       Reserved    Local APIC
0xFFFF0000-0xFFFFFFFF  64 KB       Reserved    ROM (mapped)

E820 Type Codes:
  1 = Usable RAM (we can use this!)
  2 = Reserved (don't touch)
  3 = ACPI reclaimable (can use after ACPI init)
  4 = ACPI NVS (never touch)
  5 = Bad memory</code></pre>

                    <pre><code class="language-c">/* e820.h - BIOS memory map structures */

#include &lt;stdint.h&gt;

/* E820 memory region types */
#define E820_USABLE     1
#define E820_RESERVED   2
#define E820_ACPI_RECL  3
#define E820_ACPI_NVS   4
#define E820_BAD        5

/* E820 memory region descriptor */
typedef struct {
    uint64_t base;      /* Start address */
    uint64_t length;    /* Size in bytes */
    uint32_t type;      /* Region type */
    uint32_t acpi_ext;  /* ACPI 3.0 extended attributes */
} __attribute__((packed)) e820_entry_t;

/* Stored by bootloader at known location */
#define E820_MAP_ADDR   0x8000      /* Where bootloader stores the map */
#define E820_COUNT_ADDR 0x7FFE      /* Number of entries */

/* Get memory map entries */
e820_entry_t* e820_get_map(void);
uint32_t e820_get_count(void);
uint64_t e820_total_memory(void);
</code></pre>
                    
                    <h3 id="frame-allocator">Frame Allocator</h3>
                    
                    <p>A <strong>frame</strong> is a 4KB chunk of physical memory. The frame allocator tracks which frames are free. There are two common approaches:</p>

<pre><code class="language-plaintext">FRAME ALLOCATOR DESIGNS
═══════════════════════════════════════════════════════════════

BITMAP ALLOCATOR:
└── One bit per frame: 0 = free, 1 = used
└── Memory overhead: 4GB RAM / 4KB / 8 = 128 KB bitmap
└── Allocation: O(n) scan for free bit
└── Free: O(1) clear bit

    Example: 128 MB RAM = 32,768 frames = 4,096 bytes bitmap
    
    Bitmap Index:   0   1   2   3   4   5   6   7  ...
    Frame Status: [ 1 | 1 | 1 | 0 | 0 | 1 | 0 | 0 ]
                    ^   ^   ^           ^
                  used used used       used
                          
    frame_first_free() returns frame 3 (0x3000)

STACK ALLOCATOR:
└── Push free frame addresses onto a stack
└── Pop to allocate, push to free
└── Allocation: O(1)
└── Free: O(1)
└── Memory overhead: 4 bytes per free frame

BUDDY ALLOCATOR:
└── Split/merge power-of-2 blocks
└── Better for large contiguous allocations
└── More complex, used by Linux</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>We'll use a bitmap allocator</strong> for simplicity. It's easy to understand and sufficient for a hobby OS. The bitmap approach clearly shows which regions are used.
                    </div>

                    <pre><code class="language-c">/* pmm.c - Physical Memory Manager using bitmap */

#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

#define PAGE_SIZE       4096
#define PAGES_PER_BYTE  8

/* Bitmap - each bit represents a 4KB frame */
static uint8_t* frame_bitmap;
static uint32_t total_frames;
static uint32_t used_frames;
static uint32_t bitmap_size;

/* Bitmap manipulation functions */
static inline void bitmap_set(uint32_t frame) {
    frame_bitmap[frame / 8] |= (1 << (frame % 8));
}

static inline void bitmap_clear(uint32_t frame) {
    frame_bitmap[frame / 8] &= ~(1 << (frame % 8));
}

static inline int bitmap_test(uint32_t frame) {
    return frame_bitmap[frame / 8] & (1 << (frame % 8));
}

/**
 * Initialize physical memory manager
 * @param mem_size Total physical memory in bytes
 * @param bitmap   Location to place bitmap (physical address)
 */
void pmm_init(uint32_t mem_size, uint32_t bitmap_addr) {
    total_frames = mem_size / PAGE_SIZE;
    bitmap_size = total_frames / PAGES_PER_BYTE;
    frame_bitmap = (uint8_t*)bitmap_addr;
    
    /* Mark all frames as used initially */
    memset(frame_bitmap, 0xFF, bitmap_size);
    used_frames = total_frames;
}

/**
 * Mark a region as free (from E820 map)
 */
void pmm_init_region(uint32_t base, uint32_t size) {
    uint32_t start_frame = base / PAGE_SIZE;
    uint32_t num_frames = size / PAGE_SIZE;
    
    for (uint32_t i = 0; i < num_frames; i++) {
        bitmap_clear(start_frame + i);
        used_frames--;
    }
    
    /* Always keep frame 0 reserved (null pointer detection) */
    bitmap_set(0);
}

/**
 * Mark a region as used
 */
void pmm_deinit_region(uint32_t base, uint32_t size) {
    uint32_t start_frame = base / PAGE_SIZE;
    uint32_t num_frames = size / PAGE_SIZE;
    
    for (uint32_t i = 0; i < num_frames; i++) {
        bitmap_set(start_frame + i);
        used_frames++;
    }
}

/**
 * Allocate a single physical frame
 * @return Physical address of frame, or 0 if out of memory
 */
uint32_t pmm_alloc_frame(void) {
    if (used_frames >= total_frames) {
        return 0;  /* Out of memory! */
    }
    
    /* Find first free frame */
    for (uint32_t i = 0; i < bitmap_size; i++) {
        if (frame_bitmap[i] != 0xFF) {  /* At least one free bit */
            for (uint32_t j = 0; j < 8; j++) {
                if (!(frame_bitmap[i] & (1 << j))) {
                    uint32_t frame = i * 8 + j;
                    bitmap_set(frame);
                    used_frames++;
                    return frame * PAGE_SIZE;
                }
            }
        }
    }
    
    return 0;  /* Should never reach here if used_frames is accurate */
}

/**
 * Free a physical frame
 */
void pmm_free_frame(uint32_t phys_addr) {
    uint32_t frame = phys_addr / PAGE_SIZE;
    
    if (!bitmap_test(frame)) {
        return;  /* Double free - frame already free */
    }
    
    bitmap_clear(frame);
    used_frames--;
}

/**
 * Get memory statistics
 */
uint32_t pmm_get_free_frames(void) {
    return total_frames - used_frames;
}

uint32_t pmm_get_total_frames(void) {
    return total_frames;
}
</code></pre>
                    
                    <h3 id="bitmap-allocator">Initializing From E820 Map</h3>
                    
                    <p>Here's how to initialize the PMM from the BIOS memory map:</p>

                    <pre><code class="language-c">/**
 * Initialize PMM from E820 memory map
 */
void pmm_init_from_e820(void) {
    e820_entry_t* mmap = e820_get_map();
    uint32_t count = e820_get_count();
    
    /* Find total memory and highest usable address */
    uint32_t total_mem = 0;
    for (uint32_t i = 0; i < count; i++) {
        if (mmap[i].type == E820_USABLE) {
            uint32_t end = mmap[i].base + mmap[i].length;
            if (end > total_mem) {
                total_mem = end;
            }
        }
    }
    
    /* Place bitmap right after kernel */
    extern uint32_t _kernel_end;  /* From linker script */
    uint32_t bitmap_addr = (uint32_t)&_kernel_end;
    bitmap_addr = (bitmap_addr + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1); /* Align */
    
    /* Initialize PMM (marks all as used) */
    pmm_init(total_mem, bitmap_addr);
    
    /* Mark usable regions as free */
    for (uint32_t i = 0; i < count; i++) {
        if (mmap[i].type == E820_USABLE) {
            pmm_init_region(mmap[i].base, mmap[i].length);
        }
    }
    
    /* Mark kernel + bitmap as used */
    extern uint32_t _kernel_start;
    uint32_t kernel_size = bitmap_addr + bitmap_size - (uint32_t)&_kernel_start;
    pmm_deinit_region((uint32_t)&_kernel_start, kernel_size);
    
    kprintf("PMM: %d MB total, %d MB free\n",
            total_mem / (1024*1024),
            pmm_get_free_frames() * PAGE_SIZE / (1024*1024));
}
</code></pre>

                    <div class="experiment-card">
                        <h4><i class="fas fa-lightbulb me-2"></i>Real-World Note: Linux's Physical Memory Management</h4>
                        <p>Linux uses a sophisticated <strong>buddy allocator</strong> for physical memory, which efficiently handles allocations of various sizes (not just single pages). For single-page allocations, it maintains per-CPU page pools for performance. The concepts here—tracking free frames with a data structure—are the same.</p>
                        <span class="bias-tag"><i class="fas fa-linux me-1"></i>Linux Kernel</span>
                    </div>
                </div>

                <!-- Paging Section -->
                <div id="paging" class="blog-content mt-5">
                    <h2><i class="fas fa-layer-group me-2 text-teal"></i>Paging</h2>
                    
                    <p><strong>Paging</strong> is the hardware mechanism that translates virtual addresses to physical addresses. On x86, the CPU's <strong>Memory Management Unit (MMU)</strong> does this automatically using data structures called page tables.</p>
                    
                    <h3 id="page-tables">Understanding Page Tables</h3>

<pre><code class="language-plaintext">x86 32-BIT PAGING (TWO-LEVEL)
═══════════════════════════════════════════════════════════════

Virtual Address (32 bits):
┌──────────┬──────────┬────────────┐
│  Dir Idx │ Table Idx│   Offset   │
│  10 bits │  10 bits │  12 bits   │
└────┬─────┴────┬─────┴─────┬──────┘
     │          │           │
     ▼          │           │
┌─────────────┐ │           │
│    Page     │ │           │
│  Directory  │ │           │  CR3 Register
│  (1024 PTEs)│◄────────────────────────────┐
│             │ │           │               │
├─────────────┤ │           │               │
│   Entry     │─┼──────┐    │               │
│  [Dir Idx]  │ │      │    │               │
└─────────────┘ │      ▼    │               │
                │ ┌─────────────┐           │
                │ │    Page     │           │
                │ │   Table     │           │
                │ │ (1024 PTEs) │           │
                │ ├─────────────┤           │
                └>│   Entry     │           │
                  │ [Table Idx] │───┐       │
                  └─────────────┘   │       │
                                    ▼       │
                              ┌─────────┐   │
                              │  4KB    │   │
                              │  Frame  │   │
                              │(physical)│  │
                              └────┬────┘   │
                                   │        │
                                   + Offset │
                                   │        │
                                   ▼        │
                              Physical      CPU loads from CR3
                              Address!      ─────────────────────</code></pre>

                    <pre><code class="language-c">/* paging.h - Page table structures for x86 */

#include &lt;stdint.h&gt;

#define PAGE_SIZE           4096
#define PAGES_PER_TABLE     1024
#define TABLES_PER_DIR      1024

/* Page table entry flags */
#define PTE_PRESENT         0x001   /* Page is present in memory */
#define PTE_WRITABLE        0x002   /* Page is writable */
#define PTE_USER            0x004   /* Page accessible from user mode */
#define PTE_WRITETHROUGH    0x008   /* Write-through caching */
#define PTE_CACHEDISABLE    0x010   /* Cache disabled */
#define PTE_ACCESSED        0x020   /* Page has been accessed */
#define PTE_DIRTY           0x040   /* Page has been written to */
#define PTE_PAT             0x080   /* Page Attribute Table */
#define PTE_GLOBAL          0x100   /* Don't flush from TLB on CR3 change */
#define PTE_FRAME           0xFFFFF000  /* Frame address mask (bits 12-31) */

/* Page table entry - 4 bytes */
typedef uint32_t page_entry_t;

/* Page table - 4KB, holds 1024 entries */
typedef struct {
    page_entry_t entries[PAGES_PER_TABLE];
} __attribute__((aligned(4096))) page_table_t;

/* Page directory - 4KB, holds 1024 table pointers */
typedef struct {
    page_entry_t entries[TABLES_PER_DIR];   /* Physical addresses of tables */
    page_table_t* tables[TABLES_PER_DIR];   /* Virtual addresses (for kernel use) */
    uint32_t physical_addr;                  /* Physical address of this directory */
} __attribute__((aligned(4096))) page_directory_t;

/* Current page directory */
extern page_directory_t* current_directory;

/* Function prototypes */
void paging_init(void);
void paging_switch_directory(page_directory_t* dir);
page_directory_t* paging_get_directory(void);
void paging_map_page(uint32_t virtual, uint32_t physical, uint32_t flags);
void paging_unmap_page(uint32_t virtual);
uint32_t paging_get_physical(uint32_t virtual);
</code></pre>
                    
                    <h3 id="page-directory">Page Directory Entry Format</h3>

<pre><code class="language-plaintext">PAGE DIRECTORY/TABLE ENTRY FORMAT
═══════════════════════════════════════════════════════════════

31           12 11   9 8 7 6 5 4   3   2   1   0
┌──────────────┬──────┬─┬─┬─┬─┬───┬───┬───┬───┬───┐
│   Frame/PT   │ Avail│G│S│0│A│PCD│PWT│U/S│R/W│ P │
│   Address    │      │ │ │ │ │   │   │   │   │   │
└──────────────┴──────┴─┴─┴─┴─┴───┴───┴───┴───┴───┘

Bit 0  (P):    Present - entry is valid
Bit 1  (R/W):  Read/Write - 0=read-only, 1=read-write
Bit 2  (U/S):  User/Supervisor - 0=kernel only, 1=user accessible
Bit 3  (PWT):  Page Write-Through
Bit 4  (PCD):  Page Cache Disable
Bit 5  (A):    Accessed - set by CPU when page is read
Bit 6  (D):    Dirty - set by CPU when page is written (PTE only)
Bit 7  (S):    Page Size - 1=4MB page (PDE only), 0=4KB
Bit 8  (G):    Global - don't invalidate TLB entry on CR3 switch
Bits 9-11:     Available for OS use
Bits 12-31:    Frame address (4KB aligned, so bits 0-11 are zero)</code></pre>
                    
                    <h3 id="address-translation">Address Translation</h3>
                    
                    <p>When the CPU accesses a virtual address, here's exactly what happens:</p>

<pre><code class="language-plaintext">ADDRESS TRANSLATION WALKTHROUGH
═══════════════════════════════════════════════════════════════

Example: Virtual address 0x00401234

Step 1: Split address into components
        0x00401234 = 0000 0000 0100 0000 0001 0010 0011 0100
        
        Directory Index: 0000 0000 01 = 1
        Table Index:     00 0000 0001 = 1
        Offset:          0010 0011 0100 = 0x234

Step 2: Read Page Directory entry [1]
        CR3 → Page Directory physical address
        PDE = PageDir[1]
        If PDE.Present == 0 → PAGE FAULT!
        
Step 3: Read Page Table entry [1]
        PTE = PageTable[1]  (PageTable address from PDE)
        If PTE.Present == 0 → PAGE FAULT!
        
Step 4: Calculate physical address
        Physical = (PTE.Frame << 12) | Offset
        Physical = (PTE.Frame << 12) | 0x234

Example with real values:
        CR3 = 0x00100000 (Page Directory at 1MB)
        PDE[1] = 0x00101003 (PT at 0x00101000, Present=1, RW=1)
        PTE[1] = 0x00500003 (Frame at 0x00500000, Present=1, RW=1)
        
        Physical = 0x00500000 | 0x234 = 0x00500234</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb me-2"></i>
                        <strong>TLB - Translation Lookaside Buffer:</strong> The CPU caches recent translations in the TLB. Without caching, every memory access would require 2 additional memory reads (directory + table). When you change page tables, you must invalidate the TLB with <code>invlpg</code> instruction or reload CR3.
                    </div>

                    <h3 id="enabling-paging">Implementing Paging</h3>

                    <pre><code class="language-c">/* paging.c - Paging implementation */

#include "paging.h"
#include "pmm.h"
#include &lt;string.h&gt;

/* Current active page directory */
page_directory_t* current_directory = NULL;
page_directory_t* kernel_directory = NULL;

/**
 * Map a virtual address to a physical address
 */
void paging_map_page(uint32_t virtual, uint32_t physical, uint32_t flags) {
    /* Calculate indices */
    uint32_t dir_idx = virtual >> 22;           /* Top 10 bits */
    uint32_t table_idx = (virtual >> 12) & 0x3FF; /* Middle 10 bits */
    
    /* Get or create page table */
    if (!(current_directory->entries[dir_idx] & PTE_PRESENT)) {
        /* Allocate a new page table */
        uint32_t pt_phys = pmm_alloc_frame();
        if (!pt_phys) {
            /* Out of memory! */
            return;
        }
        
        /* Map to kernel space for access */
        page_table_t* pt = (page_table_t*)pt_phys;  /* Identity mapped initially */
        memset(pt, 0, sizeof(page_table_t));
        
        /* Install in directory */
        current_directory->entries[dir_idx] = pt_phys | PTE_PRESENT | PTE_WRITABLE | flags;
        current_directory->tables[dir_idx] = pt;
    }
    
    /* Get page table */
    page_table_t* table = current_directory->tables[dir_idx];
    
    /* Set the page table entry */
    table->entries[table_idx] = (physical & PTE_FRAME) | PTE_PRESENT | flags;
    
    /* Invalidate TLB for this page */
    __asm__ volatile("invlpg (%0)" : : "r"(virtual) : "memory");
}

/**
 * Unmap a virtual address
 */
void paging_unmap_page(uint32_t virtual) {
    uint32_t dir_idx = virtual >> 22;
    uint32_t table_idx = (virtual >> 12) & 0x3FF;
    
    if (!(current_directory->entries[dir_idx] & PTE_PRESENT)) {
        return;  /* Not mapped */
    }
    
    page_table_t* table = current_directory->tables[dir_idx];
    table->entries[table_idx] = 0;
    
    /* Invalidate TLB */
    __asm__ volatile("invlpg (%0)" : : "r"(virtual) : "memory");
}

/**
 * Enable paging with the given page directory
 */
void paging_enable(page_directory_t* dir) {
    current_directory = dir;
    
    /* Load page directory address into CR3 */
    __asm__ volatile("mov %0, %%cr3" : : "r"(dir->physical_addr));
    
    /* Enable paging (set PG bit in CR0) */
    uint32_t cr0;
    __asm__ volatile("mov %%cr0, %0" : "=r"(cr0));
    cr0 |= 0x80000000;
    __asm__ volatile("mov %0, %%cr0" : : "r"(cr0));
}

/**
 * Initialize paging for the kernel
 */
void paging_init(void) {
    /* Allocate kernel page directory */
    kernel_directory = (page_directory_t*)pmm_alloc_frame();
    memset(kernel_directory, 0, sizeof(page_directory_t));
    kernel_directory->physical_addr = (uint32_t)kernel_directory;
    
    current_directory = kernel_directory;
    
    /* Identity map first 4MB (kernel + essential hardware) */
    for (uint32_t addr = 0; addr < 0x400000; addr += PAGE_SIZE) {
        paging_map_page(addr, addr, PTE_WRITABLE);
    }
    
    /* Enable paging */
    paging_enable(kernel_directory);
    
    kprintf("Paging enabled!\n");
}
</code></pre>

                    <div class="experiment-card">
                        <h4><i class="fas fa-exclamation-triangle me-2 text-crimson"></i>Critical: Identity Mapping</h4>
                        <p>When you first enable paging, the CPU's instruction pointer (EIP) contains a <strong>physical address</strong>. If your page tables don't map that address to itself (identity mapping), the CPU immediately page faults trying to fetch the next instruction!</p>
                        <p>Always identity-map the kernel and enable-paging code before enabling paging.</p>
                        <span class="bias-tag"><i class="fas fa-bug me-1"></i>Common Bug</span>
                    </div>
                </div>

                <!-- Virtual Memory Section -->
                <div id="virtual-memory" class="blog-content mt-5">
                    <h2><i class="fas fa-project-diagram me-2 text-teal"></i>Virtual Memory</h2>
                    
                    <p>With paging enabled, we can now create <strong>virtual address spaces</strong> for different purposes and eventually for different processes.</p>
                    
                    <h3 id="address-space">Address Space Layout</h3>

<pre><code class="language-plaintext">TYPICAL 32-BIT ADDRESS SPACE LAYOUT
═══════════════════════════════════════════════════════════════

0xFFFFFFFF ┌─────────────────────────────────┐
           │                                 │
           │         Kernel Space            │
           │         (Shared by all          │
           │          processes)             │
           │                                 │
0xC0000000 ├─────────────────────────────────┤ ← 3GB boundary
           │                                 │
           │         User Stack              │
           │         (grows down)            │
           │             ↓                   │
           │         [unmapped]              │
           │             ↑                   │
           │         User Heap               │
           │         (grows up)              │
           │                                 │
           │         User Data (.data,.bss)  │
           │         User Code (.text)       │
           │                                 │
0x08048000 ├─────────────────────────────────┤ ← Typical .text start
           │         [unmapped - catches     │
           │          NULL pointer derefs]   │
0x00000000 └─────────────────────────────────┘

Linux "3/1 split": 3 GB user, 1 GB kernel
Some OSes use 2/2 split (Windows 32-bit default)</code></pre>

                    <pre><code class="language-c">/* vmm.h - Virtual Memory Manager */

#define KERNEL_VIRTUAL_BASE     0xC0000000  /* 3GB mark */
#define USER_STACK_TOP          0xBFFFF000  /* Just below kernel */
#define USER_HEAP_START         0x20000000  /* 512MB mark */

/**
 * Convert physical address to kernel virtual address
 * (Only works for identity-mapped or higher-half kernel)
 */
#define PHYS_TO_VIRT(addr)  ((uint32_t)(addr) + KERNEL_VIRTUAL_BASE)
#define VIRT_TO_PHYS(addr)  ((uint32_t)(addr) - KERNEL_VIRTUAL_BASE)

/**
 * Create a new address space (for a new process)
 */
page_directory_t* vmm_create_address_space(void);

/**
 * Destroy an address space (on process exit)
 */
void vmm_destroy_address_space(page_directory_t* dir);

/**
 * Map a range of virtual memory for user space
 */
int vmm_map_user_pages(page_directory_t* dir, uint32_t vaddr, 
                       uint32_t size, uint32_t flags);
</code></pre>
                    
                    <h3 id="page-faults">Handling Page Faults</h3>
                    
                    <p>A page fault occurs when the CPU tries to access a page that isn't properly mapped. Our page fault handler (ISR 14) must decide what to do:</p>

                    <pre><code class="language-c">/* page_fault.c - Page fault handler */

#include "paging.h"
#include "pmm.h"
#include "registers.h"

/**
 * Page fault handler (ISR 14)
 * 
 * Error code bits:
 *   Bit 0 (P):   0 = not present, 1 = protection violation
 *   Bit 1 (W):   0 = read, 1 = write
 *   Bit 2 (U):   0 = supervisor, 1 = user mode
 *   Bit 3 (R):   1 = reserved bit violation
 *   Bit 4 (I):   1 = instruction fetch
 */
void page_fault_handler(registers_t* regs) {
    /* Get faulting address from CR2 */
    uint32_t faulting_address;
    __asm__ volatile("mov %%cr2, %0" : "=r"(faulting_address));
    
    /* Decode error code */
    int present   = regs->err_code & 0x1;   /* Page was present */
    int write     = regs->err_code & 0x2;   /* Write operation */
    int user      = regs->err_code & 0x4;   /* User mode */
    int reserved  = regs->err_code & 0x8;   /* Reserved bit set in PTE */
    
    /* Demand paging: If page not present, allocate it */
    if (!present) {
        /* Check if this is a valid address for this process */
        if (vmm_is_valid_address(faulting_address)) {
            /* Allocate a frame and map it */
            uint32_t frame = pmm_alloc_frame();
            if (frame) {
                uint32_t flags = PTE_PRESENT | PTE_WRITABLE;
                if (user) flags |= PTE_USER;
                paging_map_page(faulting_address & ~0xFFF, frame, flags);
                return;  /* Resume execution */
            }
        }
    }
    
    /* Unrecoverable page fault */
    kprintf("\n=== PAGE FAULT ===\n");
    kprintf("Address: 0x%08X\n", faulting_address);
    kprintf("Error: %s %s %s%s\n",
            present ? "protection" : "not-present",
            write ? "write" : "read",
            user ? "user" : "kernel",
            reserved ? " reserved-bit" : "");
    kprintf("EIP: 0x%08X\n", regs->eip);
    
    /* Kernel page fault is fatal */
    if (!user) {
        kprintf("KERNEL PANIC: Page fault in kernel mode!\n");
        for (;;) __asm__ volatile("hlt");
    }
    
    /* User page fault: terminate process (or send SIGSEGV) */
    kprintf("Terminating process due to page fault.\n");
    /* TODO: process_exit(-1); */
}
</code></pre>
                    
                    <h3 id="demand-paging">Demand Paging</h3>
                    
                    <p><strong>Demand paging</strong> means we don't actually allocate physical memory until it's accessed. This saves memory—a process can have a large virtual address space but only use memory for pages it touches.</p>

<pre><code class="language-plaintext">DEMAND PAGING FLOW
═══════════════════════════════════════════════════════════════

1. Process allocated 1 MB heap (virtual)
   ┌──────────────────────────┐
   │  Page tables created     │
   │  but PTE.Present = 0     │
   │  (no physical frames     │
   │   allocated yet!)        │
   └──────────────────────────┘

2. Process writes to address in heap
   ┌──────────────────────────┐
   │  CPU checks PTE          │
   │  Present = 0             │
   │  → PAGE FAULT!           │
   └──────────────────────────┘

3. Page fault handler allocates frame
   ┌──────────────────────────┐
   │  pmm_alloc_frame()       │
   │  Map virtual → physical  │
   │  Set PTE.Present = 1     │
   │  Return to instruction   │
   └──────────────────────────┘

4. Instruction retries and succeeds!
   ┌──────────────────────────┐
   │  Write completes         │
   │  Process continues       │
   └──────────────────────────┘

This is how processes can have huge virtual
address spaces without using all RAM!</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb me-2"></i>
                        <strong>Copy-on-Write (COW):</strong> When fork() creates a new process, both parent and child initially share the same physical pages (marked read-only). When either writes, a page fault triggers copying that page. This makes fork() fast and memory-efficient.
                    </div>
                </div>

                <!-- Heap Section -->
                <div id="heap" class="blog-content mt-5">
                    <h2><i class="fas fa-database me-2 text-teal"></i>Heap Allocator (kmalloc/kfree)</h2>
                    
                    <p>With paging working, we can finally implement <strong>dynamic memory allocation</strong>: the kernel equivalent of malloc() and free().</p>
                    
                    <h3 id="heap-design">Heap Design</h3>

<pre><code class="language-plaintext">HEAP ALLOCATOR DESIGN
═══════════════════════════════════════════════════════════════

The heap is a region of virtual memory that grows as needed.
We'll use a LINKED LIST of blocks (simple but slow for large heaps).

BLOCK HEADER STRUCTURE:
┌─────────────────────────────────────────────────────────────┐
│  Header   │              User Data                          │
├───────────┼─────────────────────────────────────────────────┤
│ size: 4B  │                                                 │
│ free: 1B  │        size bytes of usable memory              │
│ next: 4B  │                                                 │
│ (9 bytes) │                                                 │
└───────────┴─────────────────────────────────────────────────┘

HEAP LAYOUT:
                    heap_start                         heap_end
                         ↓                                 ↓
┌────────┬──────────┬────────┬──────────┬────────┬─────────┐
│ Header │   Used   │ Header │   Free   │ Header │  Used   │
│  (9B)  │  (128B)  │  (9B)  │  (256B)  │  (9B)  │  (64B)  │
└────────┴──────────┴────────┴──────────┴────────┴─────────┘
    └─────────────────→└─────────────────→└─────────→ NULL

ALLOCATION (First-Fit):
1. Walk the linked list
2. Find first FREE block with size >= requested
3. If much larger, split into two blocks
4. Mark as used, return pointer after header

DEALLOCATION:
1. Get block header (pointer - sizeof(header))
2. Mark as free
3. Coalesce with adjacent free blocks</code></pre>

                    <h3 id="malloc">kmalloc Implementation</h3>

                    <pre><code class="language-c">/* heap.c - Kernel heap allocator */

#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include "paging.h"
#include "pmm.h"

/* Heap block header */
typedef struct heap_block {
    uint32_t size;              /* Size of user data (not including header) */
    uint8_t is_free;            /* 1 if free, 0 if in use */
    struct heap_block* next;    /* Next block in list */
} __attribute__((packed)) heap_block_t;

#define HEAP_HEADER_SIZE  sizeof(heap_block_t)
#define HEAP_MIN_SPLIT    64    /* Don't split if remainder < this */

/* Heap boundaries */
static heap_block_t* heap_start = NULL;
static heap_block_t* heap_end = NULL;
static uint32_t heap_current = 0;
static uint32_t heap_max = 0;

/**
 * Initialize kernel heap
 */
void heap_init(uint32_t start, uint32_t initial_size, uint32_t max_size) {
    heap_current = start;
    heap_max = start + max_size;
    
    /* Map initial pages */
    for (uint32_t addr = start; addr < start + initial_size; addr += PAGE_SIZE) {
        uint32_t frame = pmm_alloc_frame();
        paging_map_page(addr, frame, PTE_WRITABLE);
    }
    
    /* Create initial free block */
    heap_start = (heap_block_t*)start;
    heap_start->size = initial_size - HEAP_HEADER_SIZE;
    heap_start->is_free = 1;
    heap_start->next = NULL;
    heap_end = heap_start;
    
    kprintf("Heap initialized: %d KB at 0x%08X\n", initial_size/1024, start);
}

/**
 * Expand heap by mapping more pages
 */
static int heap_expand(uint32_t size) {
    uint32_t new_end = heap_current + size;
    
    if (new_end > heap_max) {
        return 0;  /* Can't expand past max */
    }
    
    /* Map new pages */
    for (uint32_t addr = heap_current; addr < new_end; addr += PAGE_SIZE) {
        if (addr % PAGE_SIZE == 0) {
            uint32_t frame = pmm_alloc_frame();
            if (!frame) return 0;  /* Out of physical memory */
            paging_map_page(addr, frame, PTE_WRITABLE);
        }
    }
    
    heap_current = new_end;
    return 1;
}

/**
 * Allocate memory from kernel heap
 */
void* kmalloc(uint32_t size) {
    if (size == 0) return NULL;
    
    /* Align to 4 bytes */
    size = (size + 3) & ~3;
    
    /* First-fit: find a free block */
    heap_block_t* current = heap_start;
    while (current) {
        if (current->is_free && current->size >= size) {
            /* Found a suitable block */
            
            /* Split if significantly larger */
            if (current->size > size + HEAP_HEADER_SIZE + HEAP_MIN_SPLIT) {
                heap_block_t* new_block = (heap_block_t*)
                    ((uint8_t*)current + HEAP_HEADER_SIZE + size);
                new_block->size = current->size - size - HEAP_HEADER_SIZE;
                new_block->is_free = 1;
                new_block->next = current->next;
                
                current->size = size;
                current->next = new_block;
                
                if (current == heap_end) {
                    heap_end = new_block;
                }
            }
            
            current->is_free = 0;
            return (void*)((uint8_t*)current + HEAP_HEADER_SIZE);
        }
        current = current->next;
    }
    
    /* No suitable block found - expand heap */
    uint32_t expand_size = size + HEAP_HEADER_SIZE;
    if (expand_size < PAGE_SIZE) expand_size = PAGE_SIZE;
    
    if (!heap_expand(expand_size)) {
        return NULL;  /* Out of memory */
    }
    
    /* Add new block at end of heap */
    heap_block_t* new_block;
    if (heap_end->is_free) {
        /* Extend existing free block */
        heap_end->size += expand_size;
        new_block = heap_end;
    } else {
        /* Create new block */
        new_block = (heap_block_t*)
            ((uint8_t*)heap_end + HEAP_HEADER_SIZE + heap_end->size);
        new_block->size = expand_size - HEAP_HEADER_SIZE;
        new_block->is_free = 1;
        new_block->next = NULL;
        heap_end->next = new_block;
        heap_end = new_block;
    }
    
    /* Recursive call to allocate from the new block */
    return kmalloc(size);
}
</code></pre>
                    
                    <h3 id="free">kfree Implementation</h3>

                    <pre><code class="language-c">/**
 * Coalesce adjacent free blocks
 */
static void heap_coalesce(void) {
    heap_block_t* current = heap_start;
    
    while (current && current->next) {
        if (current->is_free && current->next->is_free) {
            /* Merge with next block */
            current->size += HEAP_HEADER_SIZE + current->next->size;
            current->next = current->next->next;
            
            if (!current->next) {
                heap_end = current;
            }
            /* Don't advance - check for more merges */
        } else {
            current = current->next;
        }
    }
}

/**
 * Free memory back to kernel heap
 */
void kfree(void* ptr) {
    if (!ptr) return;
    
    /* Get block header */
    heap_block_t* block = (heap_block_t*)
        ((uint8_t*)ptr - HEAP_HEADER_SIZE);
    
    /* Validate pointer is within heap */
    if ((uint32_t)block < (uint32_t)heap_start || 
        (uint32_t)block > heap_current) {
        kprintf("WARNING: kfree() on invalid pointer 0x%08X\n", ptr);
        return;
    }
    
    /* Check for double-free */
    if (block->is_free) {
        kprintf("WARNING: Double free at 0x%08X\n", ptr);
        return;
    }
    
    /* Mark as free */
    block->is_free = 1;
    
    /* Coalesce adjacent free blocks */
    heap_coalesce();
}

/**
 * Allocate and zero memory
 */
void* kcalloc(uint32_t count, uint32_t size) {
    uint32_t total = count * size;
    void* ptr = kmalloc(total);
    if (ptr) {
        memset(ptr, 0, total);
    }
    return ptr;
}

/**
 * Reallocate memory
 */
void* krealloc(void* ptr, uint32_t new_size) {
    if (!ptr) return kmalloc(new_size);
    if (new_size == 0) {
        kfree(ptr);
        return NULL;
    }
    
    heap_block_t* block = (heap_block_t*)
        ((uint8_t*)ptr - HEAP_HEADER_SIZE);
    
    if (block->size >= new_size) {
        return ptr;  /* Current block is big enough */
    }
    
    /* Allocate new, copy, free old */
    void* new_ptr = kmalloc(new_size);
    if (new_ptr) {
        memcpy(new_ptr, ptr, block->size);
        kfree(ptr);
    }
    return new_ptr;
}
</code></pre>
                    
                    <h3 id="fragmentation">Fragmentation</h3>

<pre><code class="language-plaintext">FRAGMENTATION PROBLEM
═══════════════════════════════════════════════════════════════

INTERNAL FRAGMENTATION:
Allocated more than needed due to alignment/minimum size

Request: 50 bytes
Actual:  64 bytes (aligned to 16)
Wasted:  14 bytes (internal fragmentation)

EXTERNAL FRAGMENTATION:
Free memory exists but is non-contiguous

┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐
│ USED │ free │ USED │ free │ USED │ free │ USED │ free │
│  64B │  32B │  64B │  32B │  64B │  32B │  64B │  32B │
└──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘

Total free: 128 bytes
But can't allocate 128-byte block! (only 32-byte holes)

SOLUTIONS:
1. Coalescing: Merge adjacent free blocks (we do this)
2. Compaction: Move blocks to create contiguous space (expensive)
3. Best-fit: Choose smallest adequate block (reduces waste)
4. Slab allocator: Pre-sized pools for common sizes (Linux)</code></pre>

                    <div class="experiment-card">
                        <h4><i class="fas fa-flask me-2"></i>Advanced: Slab Allocator</h4>
                        <p>Linux uses a <strong>slab allocator</strong> for kernel objects. Pre-allocated pools of fixed-size objects (inodes, task_structs, etc.) eliminate fragmentation and speed up allocation. Consider implementing this for frequently-allocated kernel structures.</p>
                        <span class="bias-tag"><i class="fas fa-linux me-1"></i>Advanced Topic</span>
                    </div>
                </div>

                <!-- What You Can Build Section -->
                <div id="build" class="blog-content mt-5">
                    <h2><i class="fas fa-hammer me-2 text-teal"></i>What You Can Build</h2>
                    
                    <div class="highlight-box">
                        <i class="fas fa-rocket me-2"></i>
                        <strong>Phase 6 Project:</strong> A kernel with working malloc() and free()! Your OS can now allocate memory dynamically at runtime, manage physical frames, and use virtual memory for process isolation.
                    </div>
                    
                    <h3>Project: Memory Statistics Display</h3>
                    
                    <p>Build a memory dashboard that displays real-time memory usage:</p>

                    <pre><code class="language-c">/* memstat.c - Memory statistics display */

#include "pmm.h"
#include "heap.h"

void display_memory_stats(void) {
    /* Physical memory stats */
    uint32_t total_frames = pmm_get_total_frames();
    uint32_t free_frames = pmm_get_free_frames();
    uint32_t used_frames = total_frames - free_frames;
    
    uint32_t total_mb = (total_frames * PAGE_SIZE) / (1024 * 1024);
    uint32_t used_mb = (used_frames * PAGE_SIZE) / (1024 * 1024);
    uint32_t free_mb = (free_frames * PAGE_SIZE) / (1024 * 1024);
    uint32_t percent_used = (used_frames * 100) / total_frames;
    
    kprintf("\n╔══════════════════════════════════════════╗\n");
    kprintf("║       MEMORY STATISTICS                  ║\n");
    kprintf("╠══════════════════════════════════════════╣\n");
    kprintf("║  PHYSICAL MEMORY                         ║\n");
    kprintf("║  Total:    %4d MB  (%6d frames)       ║\n", total_mb, total_frames);
    kprintf("║  Used:     %4d MB  (%6d frames)       ║\n", used_mb, used_frames);
    kprintf("║  Free:     %4d MB  (%6d frames)       ║\n", free_mb, free_frames);
    kprintf("║  Usage:    [");
    
    /* ASCII progress bar */
    int bar_width = 20;
    int filled = (percent_used * bar_width) / 100;
    for (int i = 0; i < bar_width; i++) {
        kprintf(i < filled ? "█" : "░");
    }
    kprintf("] %3d%%   ║\n", percent_used);
    
    kprintf("╠══════════════════════════════════════════╣\n");
    kprintf("║  KERNEL HEAP                             ║\n");
    kprintf("║  Allocated: %6d bytes                 ║\n", heap_get_used());
    kprintf("║  Fragments: %6d blocks                ║\n", heap_get_block_count());
    kprintf("╚══════════════════════════════════════════╝\n");
}

/* Stress test the allocator */
void test_allocator(void) {
    kprintf("\nAllocator stress test...\n");
    
    void* ptrs[100];
    
    /* Allocate many blocks */
    for (int i = 0; i < 100; i++) {
        ptrs[i] = kmalloc((i + 1) * 16);
        if (!ptrs[i]) {
            kprintf("  Allocation %d failed!\n", i);
            break;
        }
    }
    
    kprintf("  Allocated 100 blocks\n");
    display_memory_stats();
    
    /* Free every other block (creates fragmentation) */
    for (int i = 0; i < 100; i += 2) {
        kfree(ptrs[i]);
        ptrs[i] = NULL;
    }
    
    kprintf("\n  Freed 50 blocks (alternating)\n");
    display_memory_stats();
    
    /* Free remaining */
    for (int i = 1; i < 100; i += 2) {
        kfree(ptrs[i]);
    }
    
    kprintf("\n  Freed remaining blocks\n");
    display_memory_stats();
}
</code></pre>
                    
                    <h3>Exercises</h3>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-dumbbell me-2"></i>Exercise 1: Aligned Allocation</h4>
                        <p>Implement <code>kmalloc_aligned(size, alignment)</code> that returns memory aligned to a specified boundary (e.g., 16, 256, or 4096 bytes). This is essential for DMA buffers and SIMD operations.</p>
                        <p><strong>Hint:</strong> Allocate extra space, then return a pointer that's properly aligned. Store the original pointer somewhere so kfree() can find it.</p>
                        <span class="bias-tag"><i class="fas fa-cogs me-1"></i>Intermediate</span>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-dumbbell me-2"></i>Exercise 2: Memory Map Command</h4>
                        <p>Add a <code>memmap</code> shell command that displays the E820 memory map regions, showing which areas are usable RAM, reserved, ACPI, etc.</p>
                        <span class="bias-tag"><i class="fas fa-terminal me-1"></i>Easy</span>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-dumbbell me-2"></i>Exercise 3: Page Frame Database</h4>
                        <p>Replace the bitmap allocator with a <strong>page frame database</strong>: an array of <code>struct page</code> entries, one per physical frame. Each entry tracks: reference count, flags (dirty, locked), and a pointer for free list linking. This is how Linux manages physical memory.</p>
                        <span class="bias-tag"><i class="fas fa-linux me-1"></i>Advanced</span>
                    </div>
                </div>

                <!-- Next Steps Section -->
                <div id="next-steps" class="blog-content mt-5">
                    <h2><i class="fas fa-arrow-right me-2 text-teal"></i>Next Steps</h2>
                    
                    <p>With memory management in place, we can now build persistent storage. In Phase 7, we'll implement disk I/O and a filesystem so your kernel can read and write files.</p>

<pre><code class="language-plaintext">PHASE 7 PREVIEW: FILESYSTEM
═══════════════════════════════════════════════════════════════

Your kernel can now:
  ✓ Manage physical memory (PMM with bitmap)
  ✓ Translate virtual addresses (paging)
  ✓ Allocate memory dynamically (heap/kmalloc)

Next, you'll build:
  ┌─────────────────────────────────────────────────────────┐
  │                    VFS (Virtual File System)             │
  │              Unified interface for all filesystems       │
  └────────────────────────┬────────────────────────────────┘
                           │
           ┌───────────────┼───────────────┐
           │               │               │
    ┌──────▼─────┐  ┌──────▼─────┐  ┌──────▼─────┐
    │    FAT     │  │   ext2     │  │   tmpfs    │
    │ (Floppy/  │  │  (Linux)   │  │ (RAM disk) │
    │   USB)    │  │            │  │            │
    └──────┬─────┘  └──────┬─────┘  └──────┬─────┘
           │               │               │
    ┌──────▼─────────────▼─────────────▼──────┐
    │              Block Device Layer          │
    │          (Disk read/write operations)    │
    └────────────────────┬────────────────────┘
                         │
                         ▼
    ┌───────────────────────────────────────────┐
    │            ATA/IDE Disk Driver            │
    │          (PIO mode for simplicity)        │
    └───────────────────────────────────────────┘

You'll implement:
• ATA PIO disk driver (read/write 512-byte sectors)
• FAT12/16 filesystem (simple, well-documented)
• Basic VFS operations (open, read, write, close)
• Directory listing and file creation</code></pre>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-graduation-cap me-2"></i>
                        <strong>Key Takeaways from Phase 6:</strong>
                        <ol class="mt-2 mb-0">
                            <li><strong>Layered Design:</strong> PMM → Paging → VMM → Heap - each layer builds on the previous</li>
                            <li><strong>Virtual Memory Benefits:</strong> Process isolation, memory overcommit, simpler executable loading</li>
                            <li><strong>Two-Level Paging:</strong> Page directory + page tables provide efficient address translation</li>
                            <li><strong>Demand Paging:</strong> Allocate physical memory only when accessed (page fault triggers allocation)</li>
                            <li><strong>Heap Management:</strong> First-fit allocation with coalescing handles fragmentation</li>
                            <li><strong>Identity Mapping:</strong> Map BIOS regions and kernel 1:1 for bootstrap simplicity</li>
                        </ol>
                    </div>

                    <!-- Related Posts -->
                    <div class="related-posts">
                        <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                        <div class="related-post-item">
                            <h5 class="mb-2">Phase 5: Interrupts & CPU Control</h5>
                            <p class="text-muted small mb-2">Review the IDT, ISRs, PIC programming, and timer setup.</p>
                            <a href="kernel-dev-phase-05-interrupts.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5 class="mb-2">Phase 7: Disk Access & Filesystems</h5>
                            <p class="text-muted small mb-2">Implement ATA disk drivers, FAT filesystem, and the VFS abstraction layer.</p>
                            <a href="kernel-dev-phase-07-filesystem.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5 class="mb-2">Phase 8: Processes & User Mode</h5>
                            <p class="text-muted small mb-2">Implement task switching, system calls, and run code in user space.</p>
                            <a href="kernel-dev-phase-08-processes.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">
                        I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.
                    </p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook">
                            <i class="fab fa-facebook-f"></i>
                        </a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube">
                            <i class="fab fa-youtube"></i>
                        </a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram">
                            <i class="fab fa-instagram"></i>
                        </a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest">
                            <i class="fab fa-pinterest-p"></i>
                        </a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email">
                            <i class="fas fa-envelope"></i>
                        </a>
                    </div>
                </div>
            </div>

            <hr class="bg-secondary">

            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small">
                        <i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a>
                    </p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">
                        Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!
                    </p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Scroll-to-Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top">
        <i class="fas fa-arrow-up"></i>
    </button>
    <!-- Category Indicator -->
    <div id="categoryIndicator" class="category-indicator" title="Current Section">
        <i class="fas fa-tag"></i><span id="categoryText">Technology</span>
    </div>
    
    <!-- Cookie Consent JS -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>

    <!-- Prism.js Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-nasm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
</body>
</html>
