<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kernel Development Series - Phase 13: Graphics & GUI Systems | Wasil Zafar</title>
    <meta name="description" content="Build graphical capabilities from framebuffer primitives to font rendering, compositing, and the foundation for a windowed desktop environment.">
    <meta name="keywords" content="kernel development, graphics, GUI, framebuffer, windowing system, font rendering, OS development">
    <meta name="author" content="Wasil Zafar">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Kernel Development Series - Phase 13: Graphics & GUI Systems">
    <meta property="og:description" content="Build graphical capabilities from framebuffer primitives to font rendering, compositing, and the foundation for a windowed desktop environment.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://wasilzafar.com/pages/series/kernel-development/kernel-dev-phase-13-graphics.html">
    <meta property="og:image" content="https://wasilzafar.com/images/og-kernel-dev.png">
    <meta property="article:published_time" content="2026-02-06">
    <meta property="article:author" content="Wasil Zafar">
    <meta property="article:section" content="Technology">

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-PBS8M2JR');</script>
    
    <!-- Google Consent Mode v2 -->
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('consent', 'default', {
        'ad_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied',
        'analytics_storage': 'denied',
        'wait_for_update': 500
      });
    </script>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../../../images/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Poppins:wght@400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Prism.js Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />
    
    <!-- Main CSS -->
    <link rel="stylesheet" href="../../../css/main.css">
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript>
        <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>

    <!-- GDPR Cookie Consent Banner -->
    <div id="cookieBanner" class="light display-bottom" style="display: none;">
        <div id="closeIcon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                <path fill="currentColor" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"></path>
            </svg>
        </div>
        
        <div class="content-wrap">
            <div class="msg-wrap">
                <div class="title-wrap">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="20" height="20">
                        <path fill="#3B9797" d="M510.52 255.82c-69.97-.85-126.47-57.69-126.47-127.86-70.17 0-127-56.49-127.86-126.45-27.26-4.14-55.13.3-79.72 12.82l-69.13 35.22a132.221 132.221 0 0 0-57.79 57.81l-35.1 68.88a132.645 132.645 0 0 0-12.82 80.95l12.08 76.27a132.521 132.521 0 0 0 37.16 70.37l54.64 54.64a132.036 132.036 0 0 0 70.37 37.16l76.27 12.15c27.51 4.36 55.7-.11 80.95-12.8l68.88-35.08a132.166 132.166 0 0 0 57.79-57.81l35.1-68.88c12.56-24.64 17.01-52.58 12.91-79.91zM176 368c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32zm32-160c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32zm160 128c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32z"></path>
                    </svg>
                    <h4 style="margin: 0; font-size: 18px; color: var(--color-navy); font-weight: 700;">Cookie Consent</h4>
                </div>
                <p style="font-size: 14px; line-height: 1.6; color: var(--color-navy); margin-bottom: 15px;">
                    We use cookies to enhance your browsing experience, serve personalized content, and analyze our traffic. 
                    By clicking "Accept All", you consent to our use of cookies. See our 
                    <a href="/privacy-policy.html" style="color: var(--color-teal); border-bottom: 1px dotted var(--color-teal);">Privacy Policy</a> 
                    for more information.
                </p>
                
                <div id="cookieSettings" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="14" height="14">
                        <path fill="currentColor" d="M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z"></path>
                    </svg>
                    <span style="margin-left: 5px; font-size: 12px; font-weight: 600; color: var(--color-navy);">Customize Settings</span>
                </div>
                
                <div id="cookieTypes" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(59, 151, 151, 0.2);">
                    <h5 style="font-size: 12px; font-weight: 700; color: var(--color-navy); margin-bottom: 10px; text-transform: uppercase;">Cookie Preferences</h5>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" checked disabled style="margin-top: 2px; margin-right: 8px; cursor: not-allowed;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Essential Cookies (Required)</strong>
                                <span style="font-size: 12px; color: #666;">Necessary for the website to function properly.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" id="analyticsCookies" checked style="margin-top: 2px; margin-right: 8px;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Analytics Cookies</strong>
                                <span style="font-size: 12px; color: #666;">Help us understand how you interact with the website.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" id="marketingCookies" style="margin-top: 2px; margin-right: 8px;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Marketing Cookies</strong>
                                <span style="font-size: 12px; color: #666;">Used to deliver relevant advertisements.</span>
                            </div>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="btn-wrap">
                <button id="cookieAccept" style="background: var(--color-teal); color: white; font-weight: 600;">Accept All</button>
                <button id="cookieReject" style="background: transparent; color: var(--color-navy); border: 2px solid var(--color-teal); font-weight: 600;">Reject All</button>
                <button id="cookieSave" style="background: var(--color-blue); color: white; font-weight: 600; display: none;">Save Preferences</button>
            </div>
        </div>
    </div>

    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/">
                <span class="gradient-text">Wasil Zafar</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#about">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#skills">Skills</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#certifications">Certifications</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#interests">Interests</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link">
                    <i class="fas fa-arrow-left me-2"></i>Back to Technology
                </a>
                <h1 class="display-4 fw-bold mb-3">Phase 13: Graphics & GUI Systems</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>February 6, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>35 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
                <p class="lead">From raw pixels to a windowed desktop: implement drawing primitives, font rendering, compositing, and window management.</p>
            </div>
        </div>
    </section>

    <!-- Table of Contents Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation Overlay -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li>
                <a href="#introduction" onclick="closeNav()">Introduction</a>
                <ul>
                    <li><a href="#framebuffer-basics" onclick="closeNav()">Framebuffer Basics</a></li>
                    <li><a href="#pixel-formats" onclick="closeNav()">Pixel Formats</a></li>
                </ul>
            </li>
            <li>
                <a href="#primitives" onclick="closeNav()">Drawing Primitives</a>
                <ul>
                    <li><a href="#pixels-lines" onclick="closeNav()">Pixels & Lines</a></li>
                    <li><a href="#rectangles" onclick="closeNav()">Rectangles & Fills</a></li>
                    <li><a href="#circles" onclick="closeNav()">Circles & Ellipses</a></li>
                </ul>
            </li>
            <li>
                <a href="#fonts" onclick="closeNav()">Font Rendering</a>
                <ul>
                    <li><a href="#bitmap-fonts" onclick="closeNav()">Bitmap Fonts</a></li>
                    <li><a href="#psf-format" onclick="closeNav()">PSF Format</a></li>
                    <li><a href="#text-drawing" onclick="closeNav()">Text Drawing</a></li>
                </ul>
            </li>
            <li>
                <a href="#double-buffer" onclick="closeNav()">Double Buffering</a>
                <ul>
                    <li><a href="#back-buffer" onclick="closeNav()">Back Buffer</a></li>
                    <li><a href="#page-flip" onclick="closeNav()">Page Flipping</a></li>
                </ul>
            </li>
            <li>
                <a href="#windowing" onclick="closeNav()">Window Management</a>
                <ul>
                    <li><a href="#window-struct" onclick="closeNav()">Window Structure</a></li>
                    <li><a href="#compositing" onclick="closeNav()">Compositing</a></li>
                    <li><a href="#decorations" onclick="closeNav()">Window Decorations</a></li>
                </ul>
            </li>
            <li><a href="#build" onclick="closeNav()">What You Can Build</a></li>
            <li><a href="#next-steps" onclick="closeNav()">Next Steps</a></li>
        </ol>
    </div>

    <!-- Overlay Backdrop -->
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Main Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <!-- Introduction -->
                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-display me-2 text-teal"></i>Introduction: Graphics Foundations</h2>
                    
                    <div class="highlight-box crimson">
                        <i class="fas fa-flag me-2"></i>
                        <strong>Phase 13 Goals:</strong> By the end of this phase, your OS will have a graphical display system. You'll draw shapes, render text, use double buffering for smooth output, and have the basics of a window manager.
                    </div>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">18-Part Series</span>
                            <span class="badge bg-crimson">OS Development Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="kernel-dev-phase-00-orientation.html">Phase 0: Orientation & Big Picture</a> - OS fundamentals, kernel architectures, learning path</li>
                                <li><a href="kernel-dev-phase-01-boot-process.html">Phase 1: How a Computer Starts</a> - BIOS/UEFI, boot sequence, dev environment</li>
                                <li><a href="kernel-dev-phase-02-real-mode.html">Phase 2: Real Mode - First Steps</a> - Real mode, bootloader, BIOS interrupts</li>
                                <li><a href="kernel-dev-phase-03-protected-mode.html">Phase 3: Entering Protected Mode</a> - GDT, 32-bit mode, C code execution</li>
                                <li><a href="kernel-dev-phase-04-display-input.html">Phase 4: Display, Input & Output</a> - VGA text mode, keyboard handling</li>
                                <li><a href="kernel-dev-phase-05-interrupts.html">Phase 5: Interrupts & CPU Control</a> - IDT, ISRs, PIC programming</li>
                                <li><a href="kernel-dev-phase-06-memory.html">Phase 6: Memory Management</a> - Paging, virtual memory, heap allocator</li>
                                <li><a href="kernel-dev-phase-07-filesystem.html">Phase 7: Disk Access & Filesystems</a> - Block devices, FAT, VFS layer</li>
                                <li><a href="kernel-dev-phase-08-processes.html">Phase 8: Processes & User Mode</a> - Task switching, system calls, user space</li>
                                <li><a href="kernel-dev-phase-09-elf.html">Phase 9: ELF Loading & Executables</a> - ELF format, program loading</li>
                                <li><a href="kernel-dev-phase-10-stdlib-shell.html">Phase 10: Standard Library & Shell</a> - C library, command-line shell</li>
                                <li><a href="kernel-dev-phase-11-long-mode.html">Phase 11: 64-Bit Long Mode</a> - x86-64, 64-bit paging, modern architecture</li>
                                <li><a href="kernel-dev-phase-12-uefi.html">Phase 12: Modern Booting with UEFI</a> - UEFI boot services, memory maps</li>
                                <li><strong>Phase 13: Graphics & GUI Systems (This Guide)</strong> - Framebuffer, windowing, drawing</li>
                                <li><a href="kernel-dev-phase-14-input-timing.html">Phase 14: Advanced Input & Timing</a> - Mouse, high-precision timers</li>
                                <li><a href="kernel-dev-phase-15-hardware-drivers.html">Phase 15: Hardware Discovery & Drivers</a> - PCI, device drivers, NVMe</li>
                                <li><a href="kernel-dev-phase-16-performance.html">Phase 16: Performance & Optimization</a> - Caching, scheduler tuning</li>
                                <li><a href="kernel-dev-phase-17-security.html">Phase 17: Stability, Security & Finishing</a> - Debugging, hardening, completion</li>
                            </ol>
                        </div>
                    </div>
                    
                    <p>In Phase 12, we obtained a framebuffer through UEFI's Graphics Output Protocol (GOP). Now we'll transform that raw memory region into a full graphical system. Think of the framebuffer as a blank canvas—we need to build the brushes, pens, and eventually the window frames that make an operating system visual.</p>

                    <pre style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid var(--color-teal); border-radius: 8px; padding: 1.5rem; overflow-x: auto;">
<code style="color: #a8dadc; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
┌─────────────────────────────────────────────────────────────────┐
│                  GRAPHICS SYSTEM ARCHITECTURE                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                   Window Manager                         │    │  ▲
│  │     ┌─────────┐ ┌─────────┐ ┌─────────┐                 │    │  │
│  │     │Window A │ │Window B │ │Window C │  Window Stack   │    │  │
│  │     └─────────┘ └─────────┘ └─────────┘                 │    │  │
│  └─────────────────────────┬───────────────────────────────┘    │  │
│                            │                                     │  │ Higher
│  ┌─────────────────────────▼───────────────────────────────┐    │  │ Level
│  │                  Compositing Layer                       │    │  │
│  │        Combine windows → Double buffer → Display         │    │  │
│  └─────────────────────────┬───────────────────────────────┘    │  │
│                            │                                     │  │
│  ┌─────────────────────────▼───────────────────────────────┐    │
│  │                   Font Renderer                          │    │
│  │          PSF fonts → Glyph bitmaps → Text output         │    │
│  └─────────────────────────┬───────────────────────────────┘    │
│                            │                                     │
│  ┌─────────────────────────▼───────────────────────────────┐    │
│  │                  Drawing Primitives                      │    │
│  │     put_pixel() → draw_line() → fill_rect() → etc.       │    │
│  └─────────────────────────┬───────────────────────────────┘    │
│                            │                                     │  │
│  ┌─────────────────────────▼───────────────────────────────┐    │  │ Lower
│  │                  Framebuffer (VRAM)                      │    │  │ Level
│  │     Linear array of pixels in video memory               │    │  │
│  │     Address: 0xFD000000 (typical)  Size: ~8MB            │    │  ▼
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb"></i>
                        <strong>Key Insight:</strong> A graphical system is built in layers: framebuffer access → drawing primitives → font rendering → double buffering → window management. Each layer builds on the previous.
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-paint-brush me-2"></i>Real-World Analogy: The Artist's Studio</h4>
                        <div class="meta">
                            <span class="badge bg-teal">Conceptual Model</span>
                        </div>
                        <div class="content">
                            <p>Think of building a graphics system like setting up an artist's studio:</p>
                            <ul>
                                <li><strong>Framebuffer</strong> = The canvas (where paint actually goes)</li>
                                <li><strong>Pixel format</strong> = The color mixing rules (RGB, CMYK)</li>
                                <li><strong>Drawing primitives</strong> = Basic brushes (point, line, shape)</li>
                                <li><strong>Font renderer</strong> = Stencils for letters</li>
                                <li><strong>Double buffer</strong> = A spare canvas (paint privately, then reveal)</li>
                                <li><strong>Window manager</strong> = Arranging multiple paintings on the wall</li>
                            </ul>
                        </div>
                    </div>

                    <h3 id="framebuffer-basics">Framebuffer Basics</h3>
                    <p>The <strong>framebuffer</strong> is a region of memory that directly maps to the pixels on screen. Every byte change appears on the display. UEFI's GOP or legacy VBE (VESA BIOS Extensions) gives us the framebuffer's physical address, dimensions, and format.</p>

                    <pre style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid var(--color-teal); border-radius: 8px; padding: 1.5rem; overflow-x: auto;">
<code style="color: #a8dadc; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
     FRAMEBUFFER MEMORY LAYOUT (1920×1080 @ 32bpp)
     
     Physical Address: 0xFD000000 (memory-mapped I/O)
     
     Row 0 (y=0):
     ┌─────┬─────┬─────┬─────┬─────┬──────────────┬─────┬─────┐
     │ P0  │ P1  │ P2  │ P3  │ P4  │  ... 1920 px │P1918│P1919│ + padding
     └─────┴─────┴─────┴─────┴─────┴──────────────┴─────┴─────┘
     
     Row 1 (y=1):                    Pitch (bytes per row)
     ┌─────┬─────┬─────┬─────┬─────┬──────────────┬─────┬─────┼───────┐
     │ P0  │ P1  │ P2  │ P3  │ P4  │  ... 1920 px │P1918│P1919│ PAD   │
     └─────┴─────┴─────┴─────┴─────┴──────────────┴─────┴─────┴───────┘
     
     Each pixel (32-bit):
     ┌────────┬────────┬────────┬────────┐
     │  Blue  │ Green  │  Red   │ Alpha  │  (BGRA format)
     │ 8 bits │ 8 bits │ 8 bits │ 8 bits │
     └────────┴────────┴────────┴────────┘
     
     Pixel Address Formula:
     ┌──────────────────────────────────────────┐
     │  addr = base + (y * pitch) + (x * bpp)   │
     │                                          │
     │  Where: bpp = 4 bytes (32 bits)          │
     │         pitch = bytes_per_row (≥ w × 4)  │
     └──────────────────────────────────────────┘
</code></pre>

                    <p>The framebuffer structure encapsulates all the information we need to render graphics:</p>

                    <pre><code class="language-c">/* Framebuffer Structure */
typedef struct {
    uint32_t* buffer;       // Pixel data
    uint32_t  width;        // Horizontal resolution
    uint32_t  height;       // Vertical resolution
    uint32_t  pitch;        // Bytes per row
    uint8_t   bpp;          // Bits per pixel (32)
} framebuffer_t;

framebuffer_t fb;

/* Initialize framebuffer from UEFI/BIOS info */
void fb_init(uint32_t* base, uint32_t w, uint32_t h, uint32_t pitch) {
    fb.buffer = base;
    fb.width = w;
    fb.height = h;
    fb.pitch = pitch;
    fb.bpp = 32;
}
</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Critical: Pitch vs Width!</strong> The <code>pitch</code> is bytes per row, not pixels. GPUs often pad rows to alignment boundaries (64, 128, or 256 bytes). Always use <code>pitch</code> when calculating row addresses, never <code>width * 4</code>. This is the #1 cause of "my graphics look garbled" bugs!
                    </div>

                    <h3 id="pixel-formats">Pixel Formats</h3>
                    <p>Different hardware uses different byte orderings for pixels. The two most common 32-bit formats:</p>

                    <table class="table table-striped table-hover">
                        <thead class="table-dark">
                            <tr>
                                <th>Format</th>
                                <th>Byte Order</th>
                                <th>Common Source</th>
                                <th>Color Macro</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>BGRX/BGRA</strong></td>
                                <td>Blue, Green, Red, (Alpha)</td>
                                <td>UEFI GOP, Windows</td>
                                <td><code>(b) | (g &lt;&lt; 8) | (r &lt;&lt; 16)</code></td>
                            </tr>
                            <tr>
                                <td><strong>RGBX/RGBA</strong></td>
                                <td>Red, Green, Blue, (Alpha)</td>
                                <td>Linux fbdev, some hardware</td>
                                <td><code>(r) | (g &lt;&lt; 8) | (b &lt;&lt; 16)</code></td>
                            </tr>
                            <tr>
                                <td><strong>RGB565</strong></td>
                                <td>5-bit R, 6-bit G, 5-bit B</td>
                                <td>Embedded, legacy VGA</td>
                                <td><code>((r &gt;&gt; 3) &lt;&lt; 11) | ((g &gt;&gt; 2) &lt;&lt; 5) | (b &gt;&gt; 3)</code></td>
                            </tr>
                        </tbody>
                    </table>

                    <pre><code class="language-c">/* Pixel format handling */
typedef enum {
    PIXEL_FORMAT_BGRX,      // Blue-Green-Red-Reserved (UEFI default)
    PIXEL_FORMAT_RGBX,      // Red-Green-Blue-Reserved
    PIXEL_FORMAT_RGB565,    // 16-bit packed
} pixel_format_t;

/* Create a color value based on format */
uint32_t make_color(uint8_t r, uint8_t g, uint8_t b) {
    switch (fb.format) {
        case PIXEL_FORMAT_BGRX:
            return (uint32_t)b | ((uint32_t)g << 8) | ((uint32_t)r << 16);
        case PIXEL_FORMAT_RGBX:
            return (uint32_t)r | ((uint32_t)g << 8) | ((uint32_t)b << 16);
        default:
            return 0;  // Unsupported
    }
}

/* Standard color definitions */
#define COLOR_BLACK     make_color(0, 0, 0)
#define COLOR_WHITE     make_color(255, 255, 255)
#define COLOR_RED       make_color(255, 0, 0)
#define COLOR_GREEN     make_color(0, 255, 0)
#define COLOR_BLUE      make_color(0, 0, 255)
#define COLOR_CYAN      make_color(0, 255, 255)
#define COLOR_MAGENTA   make_color(255, 0, 255)
#define COLOR_YELLOW    make_color(255, 255, 0)
#define COLOR_GRAY      make_color(128, 128, 128)
</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Detecting Pixel Format:</strong> UEFI's <code>GOP->Mode->Info</code> structure includes <code>PixelFormat</code> (enum) and <code>PixelInformation</code> (bit masks). Check <code>PixelBlueGreenRedReserved8BitPerColor</code> for BGRX or <code>PixelRedGreenBlueReserved8BitPerColor</code> for RGBX.
                    </div>
                </div>

                <!-- Drawing Primitives Section -->
                <div id="primitives" class="blog-content mt-5">
                    <h2><i class="fas fa-pencil-ruler me-2 text-teal"></i>Drawing Primitives</h2>

                    <p>Drawing primitives are the fundamental operations from which all graphics are built. With just <code>put_pixel()</code>, you could technically draw anything—but basic shape functions make code cleaner and faster.</p>

                    <pre style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid var(--color-teal); border-radius: 8px; padding: 1.5rem; overflow-x: auto;">
<code style="color: #a8dadc; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
     DRAWING PRIMITIVES HIERARCHY
     
     Everything builds from put_pixel():
     
                           put_pixel(x, y, color)
                                    │
           ┌────────────────────────┼────────────────────────┐
           │                        │                        │
           ▼                        ▼                        ▼
    draw_line(x0,y0,x1,y1)   fill_rect(x,y,w,h)    draw_circle(cx,cy,r)
           │                        │                        │
           ▼                        ▼                        ▼
      draw_rect()              gradient()            fill_circle()
           │                        │                        │
           ▼                        ▼                        ▼
     draw_triangle()         draw_string()           draw_ellipse()
</code></pre>
                    
                    <h3 id="pixels-lines">Pixels & Lines</h3>
                    <p>The <code>put_pixel()</code> function is the atomic drawing operation—setting one pixel's color. From this, we build lines using <strong>Bresenham's algorithm</strong>, the classic integer-only line drawing algorithm from 1962.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-history me-2"></i>Bresenham's Line Algorithm</h4>
                        <div class="meta">
                            <span class="badge bg-teal">Algorithm</span>
                            <span class="badge bg-navy">1962</span>
                        </div>
                        <div class="content">
                            <p>Jack Bresenham developed this algorithm at IBM for pen plotters. Its genius: it uses only integer addition and subtraction—no multiplication, division, or floating point. This made it perfect for early computers and remains efficient today.</p>
                            <p><strong>Key insight:</strong> At each step, decide whether to move horizontally, vertically, or diagonally based on accumulated error. The algorithm chooses the pixel closest to the true line.</p>
                        </div>
                    </div>

                    <pre><code class="language-c">/* Draw a single pixel with bounds checking */
static inline void put_pixel(uint32_t x, uint32_t y, uint32_t color) {
    if (x >= fb.width || y >= fb.height) return;  // Clip to screen
    fb.buffer[y * (fb.pitch / 4) + x] = color;    // pitch/4 = pixels per row
}

/* Draw a line using Bresenham's algorithm */
void draw_line(int x0, int y0, int x1, int y1, uint32_t color) {
    int dx = abs(x1 - x0);          // Horizontal distance
    int dy = -abs(y1 - y0);         // Vertical distance (negative for error calc)
    int sx = x0 < x1 ? 1 : -1;      // X step direction
    int sy = y0 < y1 ? 1 : -1;      // Y step direction
    int err = dx + dy;              // Error accumulator
    
    while (1) {
        put_pixel(x0, y0, color);
        if (x0 == x1 && y0 == y1) break;  // Reached endpoint
        
        int e2 = 2 * err;
        if (e2 >= dy) { err += dy; x0 += sx; }  // Step horizontal
        if (e2 <= dx) { err += dx; y0 += sy; }  // Step vertical
    }
}
</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-tachometer-alt me-2"></i>
                        <strong>Performance Tip:</strong> For horizontal and vertical lines, skip Bresenham entirely. Use <code>memset32()</code> for horizontal lines (setting consecutive pixels) and a simple loop for vertical lines. This can be 10× faster for common UI elements like borders and separators.
                    </div>

                    <pre><code class="language-c">/* Optimized horizontal line */
void draw_hline(int x, int y, int width, uint32_t color) {
    if (y < 0 || y >= (int)fb.height) return;
    if (x < 0) { width += x; x = 0; }
    if (x + width > (int)fb.width) width = fb.width - x;
    if (width <= 0) return;
    
    uint32_t* ptr = &fb.buffer[y * (fb.pitch / 4) + x];
    for (int i = 0; i < width; i++) {
        ptr[i] = color;
    }
}

/* Optimized vertical line */
void draw_vline(int x, int y, int height, uint32_t color) {
    if (x < 0 || x >= (int)fb.width) return;
    int stride = fb.pitch / 4;
    uint32_t* ptr = &fb.buffer[y * stride + x];
    
    for (int i = 0; i < height; i++) {
        if (y + i >= 0 && y + i < (int)fb.height) {
            *ptr = color;
        }
        ptr += stride;
    }
}
</code></pre>
                    
                    <h3 id="rectangles">Rectangles & Fills</h3>
                    <p>Rectangles are the building blocks of user interfaces—windows, buttons, panels, and text boxes are all rectangles. We need both filled rectangles and outlines.</p>

                    <pre><code class="language-c">/* Draw filled rectangle */
void fill_rect(int x, int y, int w, int h, uint32_t color) {
    // Clip to screen bounds
    if (x < 0) { w += x; x = 0; }
    if (y < 0) { h += y; y = 0; }
    if (x + w > (int)fb.width)  w = fb.width - x;
    if (y + h > (int)fb.height) h = fb.height - y;
    if (w <= 0 || h <= 0) return;
    
    int stride = fb.pitch / 4;
    uint32_t* row = &fb.buffer[y * stride + x];
    
    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            row[i] = color;
        }
        row += stride;  // Move to next row
    }
}

/* Draw rectangle outline */
void draw_rect(int x, int y, int w, int h, uint32_t color) {
    draw_hline(x, y, w, color);              // Top
    draw_hline(x, y + h - 1, w, color);      // Bottom
    draw_vline(x, y, h, color);              // Left
    draw_vline(x + w - 1, y, h, color);      // Right
}

/* Clear screen */
void clear_screen(uint32_t color) {
    fill_rect(0, 0, fb.width, fb.height, color);
}
</code></pre>

                    <p>For visual effects, gradients add depth to UI elements:</p>

                    <pre><code class="language-c">/* Draw rectangle with vertical gradient */
void fill_rect_gradient(int x, int y, int w, int h,
                        uint32_t top_color, uint32_t bottom_color) {
    uint8_t tr = (top_color >> 16) & 0xFF;
    uint8_t tg = (top_color >> 8) & 0xFF;
    uint8_t tb = top_color & 0xFF;
    uint8_t br = (bottom_color >> 16) & 0xFF;
    uint8_t bg = (bottom_color >> 8) & 0xFF;
    uint8_t bb = bottom_color & 0xFF;
    
    for (int j = 0; j < h; j++) {
        // Linear interpolation between colors
        uint8_t r = tr + (br - tr) * j / h;
        uint8_t g = tg + (bg - tg) * j / h;
        uint8_t b = tb + (bb - tb) * j / h;
        uint32_t color = make_color(r, g, b);
        draw_hline(x, y + j, w, color);
    }
}
</code></pre>
                    
                    <h3 id="circles">Circles & Ellipses</h3>
                    <p>Circles use the <strong>Midpoint Circle Algorithm</strong> (also called Bresenham's circle algorithm). Like line drawing, it uses only integer arithmetic by exploiting the circle's 8-way symmetry.</p>

                    <pre style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid var(--color-teal); border-radius: 8px; padding: 1.5rem; overflow-x: auto;">
<code style="color: #a8dadc; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
     CIRCLE 8-WAY SYMMETRY
     
     Calculate one octant, mirror to get all 8 points:
     
            (x, y)  →  8 symmetric points
     
               ╲    |    ╱
                ╲  5│6  ╱
                 ╲  │  ╱
              4  ╲╳│╳╱  7
           ───────(cx,cy)───────
              3  ╱ │ ╲  8
                ╱  │  ╲
               ╱  2│1  ╲
              ╱    │    ╲
     
     Point (x,y) relative to center (cx,cy) gives:
     
     1: (cx + x, cy + y)    5: (cx - x, cy - y)
     2: (cx + x, cy - y)    6: (cx - x, cy + y)
     3: (cx - y, cy + x)    7: (cx + y, cy - x)
     4: (cx - y, cy - x)    8: (cx + y, cy + x)
</code></pre>

                    <pre><code class="language-c">/* Draw circle outline using midpoint algorithm */
void draw_circle(int cx, int cy, int radius, uint32_t color) {
    int x = radius;
    int y = 0;
    int err = 0;
    
    while (x >= y) {
        // Draw all 8 symmetric points
        put_pixel(cx + x, cy + y, color);
        put_pixel(cx + y, cy + x, color);
        put_pixel(cx - y, cy + x, color);
        put_pixel(cx - x, cy + y, color);
        put_pixel(cx - x, cy - y, color);
        put_pixel(cx - y, cy - x, color);
        put_pixel(cx + y, cy - x, color);
        put_pixel(cx + x, cy - y, color);
        
        y++;
        err += 1 + 2 * y;
        if (2 * (err - x) + 1 > 0) {
            x--;
            err += 1 - 2 * x;
        }
    }
}

/* Draw filled circle */
void fill_circle(int cx, int cy, int radius, uint32_t color) {
    int x = radius;
    int y = 0;
    int err = 0;
    
    while (x >= y) {
        // Draw horizontal lines for each y
        draw_hline(cx - x, cy + y, 2 * x + 1, color);
        draw_hline(cx - x, cy - y, 2 * x + 1, color);
        draw_hline(cx - y, cy + x, 2 * y + 1, color);
        draw_hline(cx - y, cy - x, 2 * y + 1, color);
        
        y++;
        err += 1 + 2 * y;
        if (2 * (err - x) + 1 > 0) {
            x--;
            err += 1 - 2 * x;
        }
    }
}

/* Draw ellipse (generalized circle) */
void draw_ellipse(int cx, int cy, int rx, int ry, uint32_t color) {
    int x = 0;
    int y = ry;
    int rx2 = rx * rx;
    int ry2 = ry * ry;
    int px = 0;
    int py = 2 * rx2 * y;
    
    // Region 1
    int p = ry2 - rx2 * ry + rx2 / 4;
    while (px < py) {
        put_pixel(cx + x, cy + y, color);
        put_pixel(cx - x, cy + y, color);
        put_pixel(cx + x, cy - y, color);
        put_pixel(cx - x, cy - y, color);
        x++;
        px += 2 * ry2;
        if (p < 0) {
            p += ry2 + px;
        } else {
            y--;
            py -= 2 * rx2;
            p += ry2 + px - py;
        }
    }
    
    // Region 2
    p = ry2 * (x + 1/2) * (x + 1/2) + rx2 * (y - 1) * (y - 1) - rx2 * ry2;
    while (y >= 0) {
        put_pixel(cx + x, cy + y, color);
        put_pixel(cx - x, cy + y, color);
        put_pixel(cx + x, cy - y, color);
        put_pixel(cx - x, cy - y, color);
        y--;
        py -= 2 * rx2;
        if (p > 0) {
            p += rx2 - py;
        } else {
            x++;
            px += 2 * ry2;
            p += rx2 - py + px;
        }
    }
}
</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-cube me-2"></i>
                        <strong>Anti-Aliasing:</strong> The algorithms above produce "jagged" edges (aliasing). For smooth edges, use <strong>Xiaolin Wu's algorithm</strong> which blends pixels based on their distance from the true line. This trades performance for visual quality—typically 2-3× slower but much smoother.
                    </div>
                </div>

                <!-- Font Rendering Section -->
                <div id="fonts" class="blog-content mt-5">
                    <h2><i class="fas fa-font me-2 text-teal"></i>Font Rendering</h2>

                    <p>Text is everywhere in a GUI—window titles, menus, file names, terminal output. We need to convert character codes into pixels. The simplest approach: <strong>bitmap fonts</strong>, where each character is a pre-drawn pixel grid.</p>
                    
                    <h3 id="bitmap-fonts">Bitmap Fonts</h3>
                    <p>A <strong>bitmap font</strong> stores each glyph (character shape) as a grid of bits—1 for foreground, 0 for background. Simple and fast to render, but doesn't scale well (you need different fonts for different sizes).</p>

                    <pre style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid var(--color-teal); border-radius: 8px; padding: 1.5rem; overflow-x: auto;">
<code style="color: #a8dadc; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
     BITMAP FONT GLYPH - Letter 'A' (8×16 pixels)
     
     Byte 0:  ░░░░░░░░  0x00  ........
     Byte 1:  ░░░██░░░  0x18  ...##...
     Byte 2:  ░░██░██░  0x3C  ..####..
     Byte 3:  ░██░░░██  0x66  .##..##.
     Byte 4:  ██░░░░░██ 0xC3  ##....##
     Byte 5:  ██░░░░░██ 0xC3  ##....##
     Byte 6:  ████████  0xFF  ########
     Byte 7:  ██░░░░░██ 0xC3  ##....##
     Byte 8:  ██░░░░░██ 0xC3  ##....##
     Byte 9:  ██░░░░░██ 0xC3  ##....##
     Byte 10: ░░░░░░░░  0x00  ........
     ...
     
     Each bit = 1 pixel
     MSB (bit 7) = leftmost pixel
     
     Storage: 16 bytes per glyph × 256 glyphs = 4KB for ASCII
</code></pre>

                    <div class="experiment-card">
                        <h4><i class="fas fa-book me-2"></i>Font Format Comparison</h4>
                        <div class="meta">
                            <span class="badge bg-teal">Typography</span>
                        </div>
                        <div class="content">
                            <table class="table table-sm">
                                <thead>
                                    <tr><th>Format</th><th>Type</th><th>Pros</th><th>Cons</th></tr>
                                </thead>
                                <tbody>
                                    <tr><td><strong>PSF</strong></td><td>Bitmap</td><td>Simple, small, fast</td><td>Fixed size, no scaling</td></tr>
                                    <tr><td><strong>BDF</strong></td><td>Bitmap</td><td>Human-readable, X11</td><td>Inefficient storage</td></tr>
                                    <tr><td><strong>TTF/OTF</strong></td><td>Vector</td><td>Scalable, hinting</td><td>Complex renderer needed</td></tr>
                                    <tr><td><strong>FNT</strong></td><td>Bitmap</td><td>Windows bitmap</td><td>Limited character set</td></tr>
                                </tbody>
                            </table>
                            <p class="mb-0"><strong>Our choice:</strong> PSF2 (PC Screen Font version 2)—Linux console font format, simple to parse, includes Unicode mapping.</p>
                        </div>
                    </div>
                    
                    <h3 id="psf-format">PSF2 Format</h3>
                    <p>PSF2 is the font format used by the Linux console. It has a straightforward header followed by glyph bitmaps and an optional Unicode table.</p>

                    <pre style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid var(--color-teal); border-radius: 8px; padding: 1.5rem; overflow-x: auto;">
<code style="color: #a8dadc; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
     PSF2 FILE STRUCTURE
     
     ┌─────────────────────────────────────────────────────────┐
     │                    PSF2 Header (32 bytes)               │
     ├─────────────────────────────────────────────────────────┤
     │  magic: 0x864ab572    (identifies PSF2 format)          │
     │  version: 0           (always zero for current spec)    │
     │  header_size: 32      (offset to first glyph)           │
     │  flags: 0 or 1        (1 = Unicode table present)       │
     │  num_glyphs: 256-512  (number of glyphs)                │
     │  bytes_per_glyph: 16  (size of each glyph bitmap)       │
     │  height: 16           (glyph height in pixels)          │
     │  width: 8             (glyph width in pixels)           │
     ├─────────────────────────────────────────────────────────┤
     │                    Glyph Data                           │
     │  ┌──────────┐                                           │
     │  │ Glyph 0  │  bytes_per_glyph bytes (char 0)           │
     │  ├──────────┤                                           │
     │  │ Glyph 1  │  bytes_per_glyph bytes (char 1)           │
     │  ├──────────┤                                           │
     │  │   ...    │  (continues for num_glyphs)               │
     │  ├──────────┤                                           │
     │  │ Glyph N  │  bytes_per_glyph bytes                    │
     │  └──────────┘                                           │
     ├─────────────────────────────────────────────────────────┤
     │                Unicode Table (optional)                 │
     │  Maps glyphs to Unicode codepoints                      │
     └─────────────────────────────────────────────────────────┘
</code></pre>

                    <pre><code class="language-c">/* PSF2 Font Header */
typedef struct {
    uint32_t magic;           // PSF2 magic: 0x864ab572
    uint32_t version;         // Zero
    uint32_t header_size;     // Offset to glyph data
    uint32_t flags;           // Unicode table flag
    uint32_t num_glyphs;      // Number of glyphs
    uint32_t bytes_per_glyph; // Size of each glyph
    uint32_t height;          // Height in pixels
    uint32_t width;           // Width in pixels
} psf2_header_t;

#define PSF2_MAGIC 0x864ab572
#define PSF2_FLAG_UNICODE 0x01

/* Load PSF2 font from embedded data or file */
psf2_header_t* font = NULL;
uint8_t* font_glyphs = NULL;

int font_init(void* psf_data) {
    font = (psf2_header_t*)psf_data;
    
    // Validate magic number
    if (font->magic != PSF2_MAGIC) {
        return -1;  // Not a PSF2 font
    }
    
    // Point to glyph data (after header)
    font_glyphs = (uint8_t*)psf_data + font->header_size;
    
    return 0;  // Success
}

/* Get font metrics */
uint32_t font_width(void)  { return font->width; }
uint32_t font_height(void) { return font->height; }
</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-download me-2"></i>
                        <strong>Getting Fonts:</strong> Linux systems include PSF fonts in <code>/usr/share/consolefonts/</code>. Popular choices: <code>Lat2-Terminus16.psf</code> (8×16), <code>ter-116n.psf</code> (Terminus). Convert with <code>psfaddtable</code> or embed directly by converting to C array: <code>xxd -i font.psf > font.h</code>
                    </div>
                    
                    <h3 id="text-drawing">Text Drawing</h3>
                    <p>Drawing text means iterating through each glyph's bitmap, checking each bit, and drawing the foreground or background color accordingly.</p>

                    <pre><code class="language-c">/* Draw a single character at x,y */
void draw_char(int x, int y, char c, uint32_t fg, uint32_t bg) {
    if (!font) return;  // Font not loaded
    
    // Get pointer to this character's glyph
    uint8_t* glyph = font_glyphs + ((uint8_t)c * font->bytes_per_glyph);
    
    // Bytes per row (width rounded up to byte boundary)
    int bytes_per_row = (font->width + 7) / 8;
    
    for (uint32_t py = 0; py < font->height; py++) {
        for (uint32_t px = 0; px < font->width; px++) {
            // Get the bit for this pixel
            uint8_t byte = glyph[py * bytes_per_row + px / 8];
            uint8_t bit = (byte >> (7 - (px % 8))) & 1;
            
            // Draw foreground or background
            put_pixel(x + px, y + py, bit ? fg : bg);
        }
    }
}

/* Draw a null-terminated string */
void draw_string(int x, int y, const char* str, uint32_t fg, uint32_t bg) {
    int start_x = x;
    
    while (*str) {
        if (*str == '\n') {
            x = start_x;        // Carriage return
            y += font->height;  // Line feed
        } else if (*str == '\t') {
            x += font->width * 4;  // Tab = 4 spaces
        } else {
            draw_char(x, y, *str, fg, bg);
            x += font->width;
        }
        str++;
    }
}

/* Printf-style formatted text */
void draw_printf(int x, int y, uint32_t fg, uint32_t bg, const char* fmt, ...) {
    char buffer[256];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);
    draw_string(x, y, buffer, fg, bg);
}
</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-bolt me-2"></i>
                        <strong>Performance: Transparent Background</strong> To draw text without a background color (transparent), skip the <code>put_pixel</code> when <code>bit == 0</code>. This is faster and allows text over images. But be careful: you must clear the area first if updating text, or old characters will show through.
                    </div>

                    <pre><code class="language-c">/* Draw character with transparent background */
void draw_char_transparent(int x, int y, char c, uint32_t fg) {
    uint8_t* glyph = font_glyphs + ((uint8_t)c * font->bytes_per_glyph);
    int bytes_per_row = (font->width + 7) / 8;
    
    for (uint32_t py = 0; py < font->height; py++) {
        for (uint32_t px = 0; px < font->width; px++) {
            uint8_t byte = glyph[py * bytes_per_row + px / 8];
            uint8_t bit = (byte >> (7 - (px % 8))) & 1;
            
            if (bit) {  // Only draw foreground pixels
                put_pixel(x + px, y + py, fg);
            }
        }
    }
}

/* Measure string width in pixels */
int string_width(const char* str) {
    int width = 0;
    int max_width = 0;
    
    while (*str) {
        if (*str == '\n') {
            max_width = (width > max_width) ? width : max_width;
            width = 0;
        } else {
            width += font->width;
        }
        str++;
    }
    return (width > max_width) ? width : max_width;
}
</code></pre>
                </div>

                <!-- Double Buffering Section -->
                <div id="double-buffer" class="blog-content mt-5">
                    <h2><i class="fas fa-clone me-2 text-teal"></i>Double Buffering</h2>

                    <p>If you draw directly to video memory, users see partially drawn frames—flickering, tearing, and visual artifacts. <strong>Double buffering</strong> solves this by drawing to an off-screen buffer first, then copying the complete frame to the display.</p>

                    <pre style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid var(--color-teal); border-radius: 8px; padding: 1.5rem; overflow-x: auto;">
<code style="color: #a8dadc; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
     DOUBLE BUFFERING CONCEPT
     
     Without double buffering:
     ┌──────────────────────────────────────────────────────────┐
     │                      Video Memory                        │
     │  User sees: ▓▓▓▓▓▓░░░░░░░░░░░░░░  (half-drawn frame!)   │
     │             ↑ drawing in progress ↑ not drawn yet        │
     └──────────────────────────────────────────────────────────┘
     
     With double buffering:
     ┌──────────────────────────────────────────────────────────┐
     │  Back Buffer (RAM)                                       │
     │  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  (draw here privately)            │
     │             │                                            │
     │             ▼  gfx_flip() - copy complete frame          │
     │  Front Buffer (VRAM)                                     │
     │  ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  (user sees complete frame)       │
     └──────────────────────────────────────────────────────────┘
</code></pre>
                    
                    <h3 id="back-buffer">Back Buffer</h3>
                    <p>The <strong>back buffer</strong> is an ordinary block of memory (allocated from our heap) the same size as the framebuffer. All drawing operations target this buffer. When the frame is complete, we copy it to video memory.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-tv me-2"></i>Why Screen Tearing Happens</h4>
                        <div class="meta">
                            <span class="badge bg-crimson">Visual Artifacts</span>
                        </div>
                        <div class="content">
                            <p><strong>Screen tearing</strong> occurs when the display refreshes mid-draw. The top half shows the old frame, the bottom half shows the new frame—creating a visible horizontal "tear" line.</p>
                            <p>Monitors refresh at fixed rates (60Hz = 60 times/second = every 16.67ms). If your frame takes 20ms to draw, the monitor grabs data before you finish.</p>
                            <p><strong>Double buffering</strong> prevents tearing because the monitor always reads a complete frame from the front buffer while you draw to the back buffer.</p>
                        </div>
                    </div>

                    <pre><code class="language-c">/* Double-buffered graphics context */
typedef struct {
    uint32_t* front;        // Video memory (display) - GPU reads this
    uint32_t* back;         // Off-screen buffer (RAM) - we draw here
    uint32_t  width;
    uint32_t  height;
    uint32_t  pitch;        // Bytes per row
    uint32_t  size;         // Total buffer size
} graphics_t;

graphics_t gfx;

/* Initialize double-buffered graphics */
int gfx_init(uint32_t* vram, uint32_t w, uint32_t h, uint32_t pitch) {
    gfx.front = vram;
    gfx.width = w;
    gfx.height = h;
    gfx.pitch = pitch;
    gfx.size = h * pitch;
    
    // Allocate back buffer from kernel heap
    gfx.back = (uint32_t*)kmalloc(gfx.size);
    if (!gfx.back) {
        return -1;  // Allocation failed
    }
    
    // Clear back buffer to black
    memset(gfx.back, 0, gfx.size);
    
    return 0;
}

/* Get pointer to draw buffer */
uint32_t* gfx_buffer(void) {
    return gfx.back;
}
</code></pre>
                    
                    <h3 id="page-flip">Page Flipping</h3>
                    <p><strong>Page flipping</strong> (or buffer swapping) copies the completed back buffer to the front buffer. The simplest approach is <code>memcpy()</code>—effective but not the fastest.</p>

                    <pre><code class="language-c">/* Swap buffers - copy back to front */
void gfx_flip(void) {
    memcpy(gfx.front, gfx.back, gfx.size);
}

/* V-Sync aware flip (if hardware supports it) */
void gfx_flip_vsync(void) {
    // Wait for vertical blanking interval
    // This prevents tearing but limits FPS to refresh rate
    while (inb(0x3DA) & 0x08);  // Wait for retrace end
    while (!(inb(0x3DA) & 0x08));  // Wait for retrace start
    
    memcpy(gfx.front, gfx.back, gfx.size);
}
</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-tachometer-alt me-2"></i>
                        <strong>Optimization: Dirty Rectangles</strong> Instead of copying the entire frame, track which regions changed ("dirty rectangles") and copy only those. At 1920×1080×4 bytes = 8MB per frame, copying takes ~2-4ms. Dirty rectangles can reduce this by 90% for typical GUIs where most of the screen doesn't change.
                    </div>

                    <pre><code class="language-c">/* Dirty rectangle tracking */
typedef struct {
    int x, y, w, h;
} rect_t;

#define MAX_DIRTY_RECTS 32
rect_t dirty_rects[MAX_DIRTY_RECTS];
int num_dirty = 0;

/* Mark a region as needing redraw */
void gfx_mark_dirty(int x, int y, int w, int h) {
    if (num_dirty < MAX_DIRTY_RECTS) {
        dirty_rects[num_dirty].x = x;
        dirty_rects[num_dirty].y = y;
        dirty_rects[num_dirty].w = w;
        dirty_rects[num_dirty].h = h;
        num_dirty++;
    }
}

/* Optimized flip - only copy dirty regions */
void gfx_flip_dirty(void) {
    for (int i = 0; i < num_dirty; i++) {
        rect_t* r = &dirty_rects[i];
        
        // Clip to screen bounds
        int x = (r->x < 0) ? 0 : r->x;
        int y = (r->y < 0) ? 0 : r->y;
        int w = r->w;
        int h = r->h;
        if (x + w > (int)gfx.width)  w = gfx.width - x;
        if (y + h > (int)gfx.height) h = gfx.height - y;
        
        // Copy each row of the dirty rectangle
        int stride = gfx.pitch / 4;
        for (int row = y; row < y + h; row++) {
            uint32_t* src = gfx.back + row * stride + x;
            uint32_t* dst = gfx.front + row * stride + x;
            memcpy(dst, src, w * 4);
        }
    }
    
    num_dirty = 0;  // Clear dirty list
}

/* Modified drawing functions should mark dirty regions */
void fill_rect_tracked(int x, int y, int w, int h, uint32_t color) {
    fill_rect(x, y, w, h, color);
    gfx_mark_dirty(x, y, w, h);
}
</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-memory me-2"></i>
                        <strong>Memory Considerations:</strong> At 1920×1080, a single back buffer uses 8MB. Triple buffering (used in games for smoother gameplay) needs 16MB. For an OS, double buffering is usually sufficient—triple buffering trades memory for marginally smoother animation.
                    </div>
                </div>

                <!-- Window Management Section -->
                <div id="windowing" class="blog-content mt-5">
                    <h2><i class="fas fa-window-maximize me-2 text-teal"></i>Window Management</h2>

                    <p>A <strong>window manager</strong> (WM) handles multiple applications sharing the screen. It tracks window positions, decides which window is on top, draws decorations (title bars, borders), and routes input to the correct window.</p>

                    <pre style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid var(--color-teal); border-radius: 8px; padding: 1.5rem; overflow-x: auto;">
<code style="color: #a8dadc; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
     WINDOW MANAGER ARCHITECTURE
     
     ┌─────────────────────────────────────────────────────────────┐
     │                      Screen Display                         │
     │  ┌──────────────────────────────────────────────────────┐   │
     │  │  Desktop Background (Wallpaper / Solid Color)        │   │
     │  │                                                      │   │
     │  │   ┌─────────────────────┐                            │   │
     │  │   │▒▒▒ Window A ▒▒[X]│   Z-Order:                    │   │
     │  │   ├─────────────────────┤   Window C (top)           │   │
     │  │   │                     │   Window B                  │   │
     │  │   │   Application       │   Window A (bottom)         │   │
     │  │   │   Content           │                            │   │
     │  │   │         ┌─────────────────────┐                  │   │
     │  │   │         │▒▒▒ Window B ▒▒[X]│                    │   │
     │  │   └─────────├─────────────────────┤                  │   │
     │  │             │                     │                  │   │
     │  │             │   ┌─────────────────────────┐          │   │
     │  │             └───│▒▒▒ Window C (focused)[X]│          │   │
     │  │                 ├─────────────────────────┤          │   │
     │  │                 │                         │          │   │
     │  └─────────────────┴─────────────────────────┴──────────┘   │
     │                                                             │
     │  Compositing: Desktop → Window A → Window B → Window C      │
     └─────────────────────────────────────────────────────────────┘
</code></pre>
                    
                    <h3 id="window-struct">Window Structure</h3>
                    <p>Each window is a data structure containing its position, size, content buffer, and metadata. Windows are typically stored in a linked list ordered by Z-order (back to front).</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-sitemap me-2"></i>Window Manager Types</h4>
                        <div class="meta">
                            <span class="badge bg-teal">GUI Design</span>
                        </div>
                        <div class="content">
                            <ul>
                                <li><strong>Stacking WM</strong> (Windows, macOS) – Windows overlap freely, most intuitive</li>
                                <li><strong>Tiling WM</strong> (i3, dwm) – Windows tile to fill screen, no overlap</li>
                                <li><strong>Compositing WM</strong> (Compiz, Wayfire) – 3D effects, transparency, shadows</li>
                            </ul>
                            <p class="mb-0">We'll build a simple stacking WM, the most common type.</p>
                        </div>
                    </div>

                    <pre><code class="language-c">/* Window structure */
typedef struct window {
    uint32_t id;            // Unique identifier
    int x, y;               // Screen position
    int width, height;      // Client area size
    uint32_t* buffer;       // Window content (pixel data)
    char title[64];         // Window title
    uint32_t flags;         // Visible, focused, etc.
    struct window* next;    // Linked list (Z-order)
    void* user_data;        // Application-specific data
} window_t;

/* Window flags */
#define WIN_VISIBLE    (1 << 0)   // Window is shown
#define WIN_FOCUSED    (1 << 1)   // Has keyboard focus
#define WIN_DECORATED  (1 << 2)   // Draw title bar & border
#define WIN_MOVABLE    (1 << 3)   // Can be dragged
#define WIN_RESIZABLE  (1 << 4)   // Can be resized
#define WIN_MINIMIZED  (1 << 5)   // Hidden in taskbar

/* Window manager state */
window_t* window_list = NULL;     // Head of Z-ordered list
window_t* focused_window = NULL;  // Currently active window
uint32_t next_window_id = 1;      // ID generator

/* Create a new window */
window_t* wm_create_window(int x, int y, int w, int h, const char* title) {
    window_t* win = (window_t*)kmalloc(sizeof(window_t));
    if (!win) return NULL;
    
    win->id = next_window_id++;
    win->x = x;
    win->y = y;
    win->width = w;
    win->height = h;
    win->flags = WIN_VISIBLE | WIN_DECORATED | WIN_MOVABLE;
    strncpy(win->title, title, 63);
    win->title[63] = '\0';
    
    // Allocate window content buffer
    win->buffer = (uint32_t*)kmalloc(w * h * 4);
    if (!win->buffer) {
        kfree(win);
        return NULL;
    }
    memset(win->buffer, 0xFF, w * h * 4);  // White background
    
    // Add to front of window list (on top)
    win->next = window_list;
    window_list = win;
    
    return win;
}

/* Destroy a window */
void wm_destroy_window(window_t* win) {
    if (!win) return;
    
    // Remove from list
    if (window_list == win) {
        window_list = win->next;
    } else {
        for (window_t* w = window_list; w; w = w->next) {
            if (w->next == win) {
                w->next = win->next;
                break;
            }
        }
    }
    
    if (focused_window == win) {
        focused_window = window_list;  // Focus next window
    }
    
    kfree(win->buffer);
    kfree(win);
}

/* Bring window to front */
void wm_raise_window(window_t* win) {
    if (!win || win == window_list) return;
    
    // Remove from current position
    for (window_t* w = window_list; w; w = w->next) {
        if (w->next == win) {
            w->next = win->next;
            break;
        }
    }
    
    // Move to front
    win->next = window_list;
    window_list = win;
}
</code></pre>
                    
                    <h3 id="compositing">Compositing</h3>
                    <p><strong>Compositing</strong> combines all visible windows into a single frame. The compositor draws windows from back to front, handling occlusion (windows covering other windows) automatically through the painting order.</p>

                    <pre><code class="language-c">/* Desktop background color or pattern */
#define DESKTOP_COLOR 0x336699  // Steel blue

/* Composite all windows to framebuffer */
void wm_composite(void) {
    int stride = gfx.pitch / 4;
    
    // 1. Draw desktop background
    for (uint32_t i = 0; i < gfx.width * gfx.height; i++) {
        gfx.back[i] = DESKTOP_COLOR;
    }
    
    // 2. Count windows for back-to-front traversal
    int count = 0;
    for (window_t* w = window_list; w; w = w->next) count++;
    
    // 3. Build reverse list (we need back-to-front)
    window_t** stack = (window_t**)alloca(count * sizeof(window_t*));
    int idx = count - 1;
    for (window_t* w = window_list; w; w = w->next) {
        stack[idx--] = w;
    }
    
    // 4. Draw windows back-to-front
    for (int i = 0; i < count; i++) {
        window_t* win = stack[i];
        if (!(win->flags & WIN_VISIBLE)) continue;
        
        // Draw decorations (title bar, border) if enabled
        if (win->flags & WIN_DECORATED) {
            wm_draw_decorations(win);
        }
        
        // Blit window content to back buffer
        for (int y = 0; y < win->height; y++) {
            for (int x = 0; x < win->width; x++) {
                int screen_x = win->x + x;
                int screen_y = win->y + y;
                
                // Clip to screen bounds
                if (screen_x >= 0 && screen_x < (int)gfx.width && 
                    screen_y >= 0 && screen_y < (int)gfx.height) {
                    gfx.back[screen_y * stride + screen_x] = 
                        win->buffer[y * win->width + x];
                }
            }
        }
    }
    
    // 5. Flip to display
    gfx_flip();
}
</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-tachometer-alt me-2"></i>
                        <strong>Optimization:</strong> Per-pixel compositing is slow. Modern compositors use GPU acceleration (OpenGL, Vulkan) or at minimum accelerated <code>memcpy</code> for window blitting. For a simple OS, the naive approach works for a few windows.
                    </div>
                    
                    <h3 id="decorations">Window Decorations</h3>
                    <p><strong>Decorations</strong> are the visual chrome around a window: title bar, minimize/maximize/close buttons, resize handles, and borders. The window manager draws these, not the application.</p>

                    <pre style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid var(--color-teal); border-radius: 8px; padding: 1.5rem; overflow-x: auto;">
<code style="color: #a8dadc; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
     WINDOW DECORATION LAYOUT
     
     ┌───────────────────────────────────────────────────────┐
     │ ┌─────────────────────────────────────────────────┐▒│ ← Border (1px)
     │ │▓▓ Title Text ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓│ _ │ □ │ X │▓▓▓│▒│ ← Title bar (24px)
     │ ├─────────────────────────────────────────────────┤▒│   Buttons
     │ │                                                 │▒│
     │ │                                                 │▒│
     │ │              Client Area                        │▒│ ← Window content
     │ │           (Application draws here)              │▒│
     │ │                                                 │▒│
     │ │                                                 │▒│
     │ └─────────────────────────────────────────────────┘▒│
     │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│ ← Bottom border
     └───────────────────────────────────────────────────────┘
     
     │◄───────────── Window outer bounds ────────────────►│
</code></pre>

                    <pre><code class="language-c">/* Decoration dimensions */
#define TITLE_BAR_HEIGHT 24
#define BORDER_WIDTH     1
#define BUTTON_SIZE      20
#define BUTTON_MARGIN    2

/* Decoration colors */
#define TITLE_ACTIVE     0x4A90D9  // Focused window
#define TITLE_INACTIVE   0x808080  // Unfocused window
#define TITLE_TEXT       0xFFFFFF  // White text
#define BORDER_COLOR     0x404040  // Dark gray
#define BUTTON_CLOSE_BG  0xE81123  // Red
#define BUTTON_HOVER_BG  0x606060  // Gray

/* Draw window decorations (title bar, border, buttons) */
void wm_draw_decorations(window_t* win) {
    int stride = gfx.pitch / 4;
    
    // Window outer bounds
    int outer_x = win->x - BORDER_WIDTH;
    int outer_y = win->y - TITLE_BAR_HEIGHT - BORDER_WIDTH;
    int outer_w = win->width + 2 * BORDER_WIDTH;
    int outer_h = win->height + TITLE_BAR_HEIGHT + 2 * BORDER_WIDTH;
    
    // Choose title bar color based on focus
    uint32_t title_color = (win->flags & WIN_FOCUSED) 
                           ? TITLE_ACTIVE : TITLE_INACTIVE;
    
    // 1. Draw border
    draw_rect(outer_x, outer_y, outer_w, outer_h, BORDER_COLOR);
    
    // 2. Draw title bar background
    fill_rect(win->x - BORDER_WIDTH + 1, 
              win->y - TITLE_BAR_HEIGHT,
              win->width + 2 * BORDER_WIDTH - 2,
              TITLE_BAR_HEIGHT,
              title_color);
    
    // 3. Draw title text
    draw_string(win->x + 4, win->y - TITLE_BAR_HEIGHT + 4,
                win->title, TITLE_TEXT, title_color);
    
    // 4. Draw close button (X)
    int close_x = win->x + win->width - BUTTON_SIZE - BUTTON_MARGIN;
    int close_y = win->y - TITLE_BAR_HEIGHT + BUTTON_MARGIN;
    fill_rect(close_x, close_y, BUTTON_SIZE, BUTTON_SIZE, BUTTON_CLOSE_BG);
    
    // Draw X on close button
    draw_line(close_x + 5, close_y + 5,
              close_x + BUTTON_SIZE - 5, close_y + BUTTON_SIZE - 5,
              TITLE_TEXT);
    draw_line(close_x + BUTTON_SIZE - 5, close_y + 5,
              close_x + 5, close_y + BUTTON_SIZE - 5,
              TITLE_TEXT);
}

/* Hit test: which part of window was clicked? */
typedef enum {
    HIT_NONE,
    HIT_TITLE_BAR,
    HIT_CLIENT,
    HIT_CLOSE_BUTTON,
    HIT_MINIMIZE_BUTTON,
    HIT_MAXIMIZE_BUTTON,
    HIT_RESIZE_BORDER,
} hit_result_t;

hit_result_t wm_hit_test(window_t* win, int mouse_x, int mouse_y) {
    // Check close button
    int close_x = win->x + win->width - BUTTON_SIZE - BUTTON_MARGIN;
    int close_y = win->y - TITLE_BAR_HEIGHT + BUTTON_MARGIN;
    if (mouse_x >= close_x && mouse_x < close_x + BUTTON_SIZE &&
        mouse_y >= close_y && mouse_y < close_y + BUTTON_SIZE) {
        return HIT_CLOSE_BUTTON;
    }
    
    // Check title bar
    if (mouse_y >= win->y - TITLE_BAR_HEIGHT && mouse_y < win->y) {
        return HIT_TITLE_BAR;
    }
    
    // Check client area
    if (mouse_x >= win->x && mouse_x < win->x + win->width &&
        mouse_y >= win->y && mouse_y < win->y + win->height) {
        return HIT_CLIENT;
    }
    
    return HIT_NONE;
}
</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-mouse-pointer me-2"></i>
                        <strong>Next Phase Preview:</strong> Window management needs mouse input for clicking, dragging, and resizing. In Phase 14, we'll add PS/2 mouse support so users can interact with our windowing system!
                    </div>
                </div>

                <!-- What You Can Build Section -->
                <div id="build" class="blog-content mt-5">
                    <h2><i class="fas fa-hammer me-2 text-teal"></i>What You Can Build</h2>
                    
                    <div class="highlight-box">
                        <i class="fas fa-rocket me-2"></i>
                        <strong>Phase 13 Project:</strong> A graphical desktop environment! Your OS now has drawing primitives, text rendering, double-buffered display, and basic windowing. You can display multiple overlapping windows with title bars.
                    </div>
                    
                    <p>Let's bring it all together with a complete graphics demo that showcases everything we built:</p>

                    <pre><code class="language-c">/*
 * graphics_demo.c - Complete Phase 13 Graphics Demo
 * Demonstrates: Framebuffer, Drawing, Fonts, Double Buffer, Windows
 */

#include "graphics.h"
#include "font.h"
#include "window.h"

/* External: PSF2 font data (embedded or loaded) */
extern uint8_t _binary_font_psf_start[];

/* Initialize the graphics subsystem */
void graphics_init(boot_info_t* boot_info) {
    // 1. Initialize framebuffer from boot info
    fb_init((uint32_t*)boot_info->framebuffer.address,
            boot_info->framebuffer.width,
            boot_info->framebuffer.height,
            boot_info->framebuffer.pitch);
    
    // 2. Initialize double buffering
    gfx_init(fb.buffer, fb.width, fb.height, fb.pitch);
    
    // 3. Load font
    font_init(_binary_font_psf_start);
    
    printf("[GFX] Graphics initialized: %dx%d @ %d bpp\n",
           fb.width, fb.height, fb.bpp);
}

/* Draw a simple pattern to test graphics */
void draw_test_pattern(void) {
    // Clear to gradient background
    for (int y = 0; y < (int)gfx.height; y++) {
        uint8_t blue = 128 + (y * 127 / gfx.height);
        uint32_t color = make_color(32, 64, blue);
        draw_hline(0, y, gfx.width, color);
    }
    
    // Draw colorful rectangles
    fill_rect(50, 50, 200, 150, COLOR_RED);
    fill_rect(100, 100, 200, 150, COLOR_GREEN);
    fill_rect(150, 150, 200, 150, COLOR_BLUE);
    
    // Draw shapes
    draw_circle(500, 300, 80, COLOR_YELLOW);
    fill_circle(500, 300, 40, COLOR_CYAN);
    draw_rect(400, 200, 200, 200, COLOR_WHITE);
    
    // Draw some lines
    for (int i = 0; i < 360; i += 15) {
        int x2 = 800 + (int)(100 * cos(i * 3.14159 / 180));
        int y2 = 300 + (int)(100 * sin(i * 3.14159 / 180));
        draw_line(800, 300, x2, y2, COLOR_MAGENTA);
    }
    
    // Draw text
    draw_string(50, 400, "Hello from Phase 13!", 
                COLOR_WHITE, COLOR_BLACK);
    draw_printf(50, 420, COLOR_CYAN, COLOR_BLACK,
                "Resolution: %dx%d", gfx.width, gfx.height);
    draw_printf(50, 440, COLOR_GREEN, COLOR_BLACK,
                "Font: %dx%d pixels", font_width(), font_height());
}

/* Create demo windows */
void create_demo_desktop(void) {
    // Create a few demo windows
    window_t* win1 = wm_create_window(100, 150, 300, 200, "Terminal");
    window_t* win2 = wm_create_window(250, 200, 350, 250, "File Manager");
    window_t* win3 = wm_create_window(450, 100, 280, 180, "System Info");
    
    // Fill window 1 with terminal-like content
    if (win1) {
        for (int i = 0; i < win1->width * win1->height; i++) {
            win1->buffer[i] = 0x1A1A2E;  // Dark terminal background
        }
        // Draw some fake terminal text (coordinates relative to window)
        // ... (would need window-local draw functions)
    }
    
    // Fill window 2 with file manager look
    if (win2) {
        for (int i = 0; i < win2->width * win2->height; i++) {
            win2->buffer[i] = 0xF0F0F0;  // Light gray
        }
    }
    
    // Fill window 3 with system info
    if (win3) {
        for (int i = 0; i < win3->width * win3->height; i++) {
            win3->buffer[i] = 0xFFFFFF;  // White
        }
    }
    
    // Focus the top window
    focused_window = win3;
    if (win3) win3->flags |= WIN_FOCUSED;
}

/* Main graphics demo entry point */
void graphics_demo(boot_info_t* boot_info) {
    graphics_init(boot_info);
    
    // Option 1: Draw test pattern (no windows)
    // draw_test_pattern();
    // gfx_flip();
    
    // Option 2: Full windowed desktop
    create_demo_desktop();
    wm_composite();  // Draw all windows to screen
    
    printf("[GFX] Desktop rendered successfully!\n");
}
</code></pre>

                    <h4>Phase 13 Exercises</h4>
                    <div class="experiment-card">
                        <h4><i class="fas fa-dumbbell me-2"></i>Exercise 1: Gradient Title Bars</h4>
                        <div class="meta">
                            <span class="badge bg-teal">Beginner</span>
                        </div>
                        <div class="content">
                            <p><strong>Goal:</strong> Make window title bars use a vertical gradient instead of a solid color.</p>
                            <p><strong>Hints:</strong></p>
                            <ul>
                                <li>Modify <code>wm_draw_decorations()</code></li>
                                <li>Use <code>fill_rect_gradient()</code> for the title bar area</li>
                                <li>Choose colors: lighter at top, darker at bottom</li>
                            </ul>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-dumbbell me-2"></i>Exercise 2: Bitmap Image Loading</h4>
                        <div class="meta">
                            <span class="badge bg-navy">Intermediate</span>
                        </div>
                        <div class="content">
                            <p><strong>Goal:</strong> Load and display a BMP image as a desktop wallpaper.</p>
                            <p><strong>Hints:</strong></p>
                            <ul>
                                <li>BMP header: 14-byte file header + 40-byte DIB header</li>
                                <li>Check <code>bfType == 0x4D42</code> ("BM") to verify BMP format</li>
                                <li>Pixel data starts at offset <code>bfOffBits</code></li>
                                <li>Note: BMP stores rows bottom-to-top (flip when loading)</li>
                            </ul>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-dumbbell me-2"></i>Exercise 3: Alpha Blending</h4>
                        <div class="meta">
                            <span class="badge bg-navy">Intermediate</span>
                        </div>
                        <div class="content">
                            <p><strong>Goal:</strong> Implement transparency so windows can have translucent areas.</p>
                            <p><strong>Hints:</strong></p>
                            <ul>
                                <li>Alpha blending formula: <code>out = (src × α + dst × (255 - α)) / 255</code></li>
                                <li>Apply per color channel (R, G, B separately)</li>
                                <li>Use the Alpha byte in BGRA (usually ignored)</li>
                                <li>Performance: Alpha blending is expensive—use sparingly</li>
                            </ul>
                            <pre><code class="language-c">uint32_t blend(uint32_t src, uint32_t dst, uint8_t alpha) {
    uint8_t sr = (src >> 16) & 0xFF;
    uint8_t sg = (src >> 8) & 0xFF;
    uint8_t sb = src & 0xFF;
    uint8_t dr = (dst >> 16) & 0xFF;
    uint8_t dg = (dst >> 8) & 0xFF;
    uint8_t db = dst & 0xFF;
    
    uint8_t r = (sr * alpha + dr * (255 - alpha)) / 255;
    uint8_t g = (sg * alpha + dg * (255 - alpha)) / 255;
    uint8_t b = (sb * alpha + db * (255 - alpha)) / 255;
    
    return make_color(r, g, b);
}</code></pre>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-dumbbell me-2"></i>Exercise 4: Anti-Aliased Circles</h4>
                        <div class="meta">
                            <span class="badge bg-crimson">Advanced</span>
                        </div>
                        <div class="content">
                            <p><strong>Goal:</strong> Implement Xiaolin Wu's algorithm for smooth, anti-aliased circles.</p>
                            <p><strong>Hints:</strong></p>
                            <ul>
                                <li>Wu's algorithm blends edge pixels based on distance from true curve</li>
                                <li>Use <code>fpart(x)</code> (fractional part) for blend weights</li>
                                <li>Draw two pixels at each position: one at integer position, one adjacent</li>
                                <li>Requires floating-point math or fixed-point approximation</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Next Steps Section -->
                <div id="next-steps" class="blog-content mt-5">
                    <h2><i class="fas fa-arrow-right me-2 text-teal"></i>Next Steps</h2>
                    
                    <p>You have a graphical system! But a GUI without mouse input is just a pretty picture. In Phase 14, we'll make it interactive.</p>

                    <pre style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid var(--color-teal); border-radius: 8px; padding: 1.5rem; overflow-x: auto;">
<code style="color: #a8dadc; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
     PHASE 13 → PHASE 14 TRANSITION
     
     Where we are:
     ┌─────────────────────────────────────────────────────────────┐
     │  Phase 13: Graphics & GUI                                   │
     │                                                              │
     │  ✓ Framebuffer access (UEFI GOP)                            │
     │  ✓ Drawing primitives (lines, rectangles, circles)          │
     │  ✓ Font rendering (PSF2 bitmap fonts)                       │
     │  ✓ Double buffering (no tearing)                            │
     │  ✓ Window management (overlapping windows)                  │
     └─────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
     ┌─────────────────────────────────────────────────────────────┐
     │  Phase 14: Advanced Input & Timing                          │
     │                                                              │
     │  → PS/2 Mouse driver                                        │
     │  → Mouse cursor drawing                                     │
     │  → Window dragging, clicking, resizing                      │
     │  → HPET (High Precision Event Timer)                        │
     │  → Smooth animations at consistent frame rates              │
     └─────────────────────────────────────────────────────────────┘
</code></pre>

                    <table class="table table-striped table-hover">
                        <thead class="table-dark">
                            <tr>
                                <th>Concept</th>
                                <th>What You Learned</th>
                                <th>Real-World Use</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Framebuffer</strong></td>
                                <td>Linear pixel array in VRAM, pitch vs width</td>
                                <td>Every GPU driver, embedded displays</td>
                            </tr>
                            <tr>
                                <td><strong>Bresenham's Algorithm</strong></td>
                                <td>Integer-only line drawing</td>
                                <td>GPU rasterization, 2D games</td>
                            </tr>
                            <tr>
                                <td><strong>PSF Fonts</strong></td>
                                <td>Bitmap glyph rendering</td>
                                <td>BIOS, bootloaders, terminals</td>
                            </tr>
                            <tr>
                                <td><strong>Double Buffering</strong></td>
                                <td>Prevent screen tearing</td>
                                <td>Every modern GUI system</td>
                            </tr>
                            <tr>
                                <td><strong>Compositing</strong></td>
                                <td>Layer windows with Z-order</td>
                                <td>Windows DWM, macOS Quartz</td>
                            </tr>
                            <tr>
                                <td><strong>Dirty Rectangles</strong></td>
                                <td>Optimize partial screen updates</td>
                                <td>Desktop environments, game engines</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="experiment-card">
                        <h4><i class="fas fa-tools me-2"></i>Development Resources</h4>
                        <div class="meta">
                            <span class="badge bg-teal">Tools & References</span>
                        </div>
                        <div class="content">
                            <ul>
                                <li><strong>PSF Fonts:</strong> <code>/usr/share/consolefonts/</code> on Linux; <a href="http://www.solarfuture.org/fonts/" target="_blank">PC Screen Fonts</a></li>
                                <li><strong>QEMU Testing:</strong> <code>-enable-kvm -vga std</code> for fast graphical output</li>
                                <li><strong>Color Picker:</strong> Use hex colors directly (e.g., <code>0xRRGGBB</code>); web tools work</li>
                                <li><strong>Benchmarking:</strong> Draw 1000 lines, time with RDTSC; measure fill_rect vs memset</li>
                                <li><strong>Screenshot:</strong> QEMU: <code>screendump filename.ppm</code> in monitor</li>
                            </ul>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-graduation-cap me-2"></i>
                        <strong>Milestone Achieved:</strong> You've implemented a complete graphics stack from scratch! This is the foundation of every graphical operating system. Modern systems add GPU acceleration, but the concepts remain identical.
                    </div>
                    <p>A graphical system needs input! In Phase 14, we'll add mouse support for window interaction and implement high-precision timers for smooth animations and scheduling.</p>

                    <!-- Related Posts -->
                    <div class="related-posts">
                        <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                        <div class="related-post-item">
                            <h5 class="mb-2">Phase 12: Modern Booting with UEFI</h5>
                            <p class="text-muted small mb-2">Review UEFI boot services and GOP framebuffer setup.</p>
                            <a href="kernel-dev-phase-12-uefi.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5 class="mb-2">Phase 14: Advanced Input & Timing</h5>
                            <p class="text-muted small mb-2">Add mouse drivers and high-precision timers.</p>
                            <a href="kernel-dev-phase-14-input-timing.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5 class="mb-2">Phase 15: Hardware Discovery & Drivers</h5>
                            <p class="text-muted small mb-2">Discover PCI devices and write drivers.</p>
                            <a href="kernel-dev-phase-15-hardware-drivers.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">
                        I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.
                    </p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook">
                            <i class="fab fa-facebook-f"></i>
                        </a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube">
                            <i class="fab fa-youtube"></i>
                        </a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram">
                            <i class="fab fa-instagram"></i>
                        </a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest">
                            <i class="fab fa-pinterest-p"></i>
                        </a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email">
                            <i class="fas fa-envelope"></i>
                        </a>
                    </div>
                </div>
            </div>

            <hr class="bg-secondary">

            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small">
                        <i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a>
                    </p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">
                        Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!
                    </p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Scroll-to-Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top">
        <i class="fas fa-arrow-up"></i>
    </button>
    <!-- Category Indicator -->
    <div id="categoryIndicator" class="category-indicator" title="Current Section">
        <i class="fas fa-tag"></i><span id="categoryText">Technology</span>
    </div>
    
    <!-- Cookie Consent JS -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>

    <!-- Prism.js Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-nasm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
</body>
</html>
