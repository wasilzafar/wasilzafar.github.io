<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kernel Development Series - Phase 8: Processes & User Mode | Wasil Zafar</title>
    <meta name="description" content="Implement task switching, system calls, and user mode execution to run programs in isolated address spaces with privilege separation.">
    <meta name="keywords" content="kernel development, processes, task switching, system calls, user mode, ring 3, TSS, context switch, OS development">
    <meta name="author" content="Wasil Zafar">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Kernel Development Series - Phase 8: Processes & User Mode">
    <meta property="og:description" content="Implement task switching, system calls, and user mode execution to run programs in isolated address spaces with privilege separation.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://wasilzafar.com/pages/series/kernel-development/kernel-dev-phase-08-processes.html">
    <meta property="og:image" content="https://wasilzafar.com/images/og-kernel-dev.png">
    <meta property="article:published_time" content="2026-02-06">
    <meta property="article:author" content="Wasil Zafar">
    <meta property="article:section" content="Technology">

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-PBS8M2JR');</script>
    
    <!-- Google Consent Mode v2 -->
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('consent', 'default', {
        'ad_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied',
        'analytics_storage': 'denied',
        'wait_for_update': 500
      });
    </script>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../../../images/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Poppins:wght@400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Prism.js Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />
    
    <!-- Main CSS -->
    <link rel="stylesheet" href="../../../css/main.css">
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript>
        <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>

    <!-- GDPR Cookie Consent Banner -->
    <div id="cookieBanner" class="light display-bottom" style="display: none;">
        <div id="closeIcon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                <path fill="currentColor" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"></path>
            </svg>
        </div>
        
        <div class="content-wrap">
            <div class="msg-wrap">
                <div class="title-wrap">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="20" height="20">
                        <path fill="#3B9797" d="M510.52 255.82c-69.97-.85-126.47-57.69-126.47-127.86-70.17 0-127-56.49-127.86-126.45-27.26-4.14-55.13.3-79.72 12.82l-69.13 35.22a132.221 132.221 0 0 0-57.79 57.81l-35.1 68.88a132.645 132.645 0 0 0-12.82 80.95l12.08 76.27a132.521 132.521 0 0 0 37.16 70.37l54.64 54.64a132.036 132.036 0 0 0 70.37 37.16l76.27 12.15c27.51 4.36 55.7-.11 80.95-12.8l68.88-35.08a132.166 132.166 0 0 0 57.79-57.81l35.1-68.88c12.56-24.64 17.01-52.58 12.91-79.91zM176 368c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32zm32-160c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32zm160 128c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32z"></path>
                    </svg>
                    <h4 style="margin: 0; font-size: 18px; color: var(--color-navy); font-weight: 700;">Cookie Consent</h4>
                </div>
                <p style="font-size: 14px; line-height: 1.6; color: var(--color-navy); margin-bottom: 15px;">
                    We use cookies to enhance your browsing experience, serve personalized content, and analyze our traffic. 
                    By clicking "Accept All", you consent to our use of cookies. See our 
                    <a href="/privacy-policy.html" style="color: var(--color-teal); border-bottom: 1px dotted var(--color-teal);">Privacy Policy</a> 
                    for more information.
                </p>
                
                <div id="cookieSettings" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="14" height="14">
                        <path fill="currentColor" d="M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z"></path>
                    </svg>
                    <span style="margin-left: 5px; font-size: 12px; font-weight: 600; color: var(--color-navy);">Customize Settings</span>
                </div>
                
                <div id="cookieTypes" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(59, 151, 151, 0.2);">
                    <h5 style="font-size: 12px; font-weight: 700; color: var(--color-navy); margin-bottom: 10px; text-transform: uppercase;">Cookie Preferences</h5>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" checked disabled style="margin-top: 2px; margin-right: 8px; cursor: not-allowed;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Essential Cookies (Required)</strong>
                                <span style="font-size: 12px; color: #666;">Necessary for the website to function properly.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" id="analyticsCookies" checked style="margin-top: 2px; margin-right: 8px;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Analytics Cookies</strong>
                                <span style="font-size: 12px; color: #666;">Help us understand how you interact with the website.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" id="marketingCookies" style="margin-top: 2px; margin-right: 8px;">
                            <div>
                                <strong style="font-size: 13px; color: var(--color-navy); display: block; margin-bottom: 2px;">Marketing Cookies</strong>
                                <span style="font-size: 12px; color: #666;">Used to deliver relevant advertisements.</span>
                            </div>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="btn-wrap">
                <button id="cookieAccept" style="background: var(--color-teal); color: white; font-weight: 600;">Accept All</button>
                <button id="cookieReject" style="background: transparent; color: var(--color-navy); border: 2px solid var(--color-teal); font-weight: 600;">Reject All</button>
                <button id="cookieSave" style="background: var(--color-blue); color: white; font-weight: 600; display: none;">Save Preferences</button>
            </div>
        </div>
    </div>

    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/">
                <span class="gradient-text">Wasil Zafar</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#about">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#skills">Skills</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#certifications">Certifications</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#interests">Interests</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link">
                    <i class="fas fa-arrow-left me-2"></i>Back to Technology
                </a>
                <h1 class="display-4 fw-bold mb-3">Phase 8: Processes & User Mode</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>February 6, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>35 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
                <p class="lead">Implement task switching for multitasking, build system calls for kernel services, and run user programs in ring 3 with proper privilege separation.</p>
            </div>
        </div>
    </section>

    <!-- Table of Contents Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation Overlay -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li>
                <a href="#introduction" onclick="closeNav()">Introduction</a>
                <ul>
                    <li><a href="#process-concept" onclick="closeNav()">Process Concept</a></li>
                    <li><a href="#privilege-levels" onclick="closeNav()">Privilege Levels</a></li>
                </ul>
            </li>
            <li>
                <a href="#tss" onclick="closeNav()">Task State Segment</a>
                <ul>
                    <li><a href="#tss-structure" onclick="closeNav()">TSS Structure</a></li>
                    <li><a href="#tss-setup" onclick="closeNav()">Setting Up TSS</a></li>
                </ul>
            </li>
            <li>
                <a href="#context-switch" onclick="closeNav()">Context Switching</a>
                <ul>
                    <li><a href="#pcb" onclick="closeNav()">Process Control Block</a></li>
                    <li><a href="#switch-code" onclick="closeNav()">Switch Implementation</a></li>
                    <li><a href="#scheduler" onclick="closeNav()">Simple Scheduler</a></li>
                </ul>
            </li>
            <li>
                <a href="#system-calls" onclick="closeNav()">System Calls</a>
                <ul>
                    <li><a href="#syscall-design" onclick="closeNav()">System Call Design</a></li>
                    <li><a href="#syscall-handler" onclick="closeNav()">Handler Implementation</a></li>
                    <li><a href="#syscall-api" onclick="closeNav()">User-Space API</a></li>
                </ul>
            </li>
            <li>
                <a href="#user-mode" onclick="closeNav()">Entering User Mode</a>
                <ul>
                    <li><a href="#ring3-setup" onclick="closeNav()">Ring 3 Setup</a></li>
                    <li><a href="#first-process" onclick="closeNav()">First User Process</a></li>
                </ul>
            </li>
            <li><a href="#build" onclick="closeNav()">What You Can Build</a></li>
            <li><a href="#next-steps" onclick="closeNav()">Next Steps</a></li>
        </ol>
    </div>

    <!-- Overlay Backdrop -->
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Main Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <!-- Introduction -->
                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-cogs me-2 text-teal"></i>Introduction: Multitasking</h2>
                    
                    <div class="highlight-box crimson">
                        <i class="fas fa-flag me-2"></i>
                        <strong>Phase 8 Goals:</strong> By the end of this phase, your kernel will run multiple processes. You'll have task switching for multitasking, system calls for controlled kernel access, and user mode execution with memory protection.
                    </div>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">18-Part Series</span>
                            <span class="badge bg-crimson">OS Development Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="kernel-dev-phase-00-orientation.html">Phase 0: Orientation & Big Picture</a> - OS fundamentals, kernel architectures, learning path</li>
                                <li><a href="kernel-dev-phase-01-boot-process.html">Phase 1: How a Computer Starts</a> - BIOS/UEFI, boot sequence, dev environment</li>
                                <li><a href="kernel-dev-phase-02-real-mode.html">Phase 2: Real Mode - First Steps</a> - Real mode, bootloader, BIOS interrupts</li>
                                <li><a href="kernel-dev-phase-03-protected-mode.html">Phase 3: Entering Protected Mode</a> - GDT, 32-bit mode, C code execution</li>
                                <li><a href="kernel-dev-phase-04-display-input.html">Phase 4: Display, Input & Output</a> - VGA text mode, keyboard handling</li>
                                <li><a href="kernel-dev-phase-05-interrupts.html">Phase 5: Interrupts & CPU Control</a> - IDT, ISRs, PIC programming</li>
                                <li><a href="kernel-dev-phase-06-memory.html">Phase 6: Memory Management</a> - Paging, virtual memory, heap allocator</li>
                                <li><a href="kernel-dev-phase-07-filesystem.html">Phase 7: Disk Access & Filesystems</a> - Block devices, FAT, VFS layer</li>
                                <li><strong>Phase 8: Processes & User Mode (This Guide)</strong> - Task switching, system calls, user space</li>
                                <li><a href="kernel-dev-phase-09-elf.html">Phase 9: ELF Loading & Executables</a> - ELF format, program loading</li>
                                <li><a href="kernel-dev-phase-10-stdlib-shell.html">Phase 10: Standard Library & Shell</a> - C library, command-line shell</li>
                                <li><a href="kernel-dev-phase-11-long-mode.html">Phase 11: 64-Bit Long Mode</a> - x86-64, 64-bit paging, modern architecture</li>
                                <li><a href="kernel-dev-phase-12-uefi.html">Phase 12: Modern Booting with UEFI</a> - UEFI boot services, memory maps</li>
                                <li><a href="kernel-dev-phase-13-graphics.html">Phase 13: Graphics & GUI Systems</a> - Framebuffer, windowing, drawing</li>
                                <li><a href="kernel-dev-phase-14-input-timing.html">Phase 14: Advanced Input & Timing</a> - Mouse, high-precision timers</li>
                                <li><a href="kernel-dev-phase-15-hardware-drivers.html">Phase 15: Hardware Discovery & Drivers</a> - PCI, device drivers, NVMe</li>
                                <li><a href="kernel-dev-phase-16-performance.html">Phase 16: Performance & Optimization</a> - Caching, scheduler tuning</li>
                                <li><a href="kernel-dev-phase-17-security.html">Phase 17: Stability, Security & Finishing</a> - Debugging, hardening, completion</li>
                            </ol>
                        </div>
                    </div>
                    
                    <p>Content will be populated here...</p>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb"></i>
                        <strong>Key Insight:</strong> Processes are the foundation of any useful operating system. Task switching creates the illusion of parallelism, while system calls provide a secure gateway from user code to kernel services.
                    </div>
                    
                    <p>Consider your computer running a web browser, music player, and text editor simultaneously. Each feels like it has the CPU to itself, yet there's only one (or a few) physical CPU cores. This magic is <strong>multitasking</strong> - the operating system rapidly switching between processes, giving each a slice of CPU time. In this phase, we'll build this capability from scratch.</p>
                    
<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│                     PROCESS ABSTRACTION                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐        │
│   │Process A│   │Process B│   │Process C│   │Process D│        │
│   │ (Shell) │   │(Browser)│   │ (Music) │   │ (Game)  │        │
│   └────┬────┘   └────┬────┘   └────┬────┘   └────┬────┘        │
│        │             │             │             │              │
│        └─────────────┼─────────────┼─────────────┘              │
│                      │ Each thinks │                            │
│                      │ it owns CPU │                            │
│                      ▼             ▼                            │
│   ┌──────────────────────────────────────────────────────┐     │
│   │                  SCHEDULER                            │     │
│   │    "A runs... now B... now C... back to A..."        │     │
│   └──────────────────────────────────────────────────────┘     │
│                      │                                          │
│                      ▼                                          │
│   ┌──────────────────────────────────────────────────────┐     │
│   │              PHYSICAL CPU                             │     │
│   │         (Actually runs ONE at a time)                 │     │
│   └──────────────────────────────────────────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>

                    <h3 id="process-concept">Process Concept</h3>
                    
                    <p>A <strong>process</strong> is a program in execution. While a program is just a file on disk (like <code>hello.exe</code>), a process is that program alive - with its own memory, registers, and state. Think of it like the difference between a recipe (program) and actually cooking (process).</p>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-cubes me-2"></i>Anatomy of a Process</h4>
                        <div class="content">
<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│                    PROCESS STRUCTURE                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   PROCESS CONTROL BLOCK (PCB)        VIRTUAL ADDRESS SPACE      │
│   ┌─────────────────────────┐        ┌─────────────────────┐    │
│   │ PID: 42                 │        │    0xFFFFFFFF       │    │
│   │ State: RUNNING          │        ├─────────────────────┤    │
│   │ Program Counter: 0x1234 │        │      KERNEL         │    │
│   │ Stack Pointer: 0x7FFF   │        │   (mapped but       │    │
│   │ Page Directory: 0x100   │        │    protected)       │    │
│   │ Priority: 5             │        ├─────────────────────┤    │
│   │ Parent PID: 1           │        │      STACK          │    │
│   │ Open Files: [0,1,2,5]   │        │       ↓             │    │
│   │ Registers: [saved...]   │        │                     │    │
│   └─────────────────────────┘        │       ↑             │    │
│                                      │      HEAP           │    │
│   PROCESS STATES                     ├─────────────────────┤    │
│   ┌─────────────────────────┐        │      BSS            │    │
│   │                         │        │  (uninitialized)    │    │
│   │  READY ──→ RUNNING ─┐   │        ├─────────────────────┤    │
│   │    ↑         │      │   │        │      DATA           │    │
│   │    │         │      │   │        │   (initialized)     │    │
│   │    │         ▼      │   │        ├─────────────────────┤    │
│   │    └──── BLOCKED ←──┘   │        │      TEXT           │    │
│   │                         │        │   (code/read-only)  │    │
│   └─────────────────────────┘        └─────────────────────┘    │
│                                          0x00000000             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
                            <p class="mt-3"><strong>PCB (Process Control Block)</strong> - The kernel's data structure for managing each process. Contains everything needed to stop a process and restart it later.</p>
                            <p><strong>Virtual Address Space</strong> - Each process believes it has the entire address space to itself. The MMU (with paging) translates virtual addresses to physical, isolating processes from each other.</p>
                        </div>
                    </div>
                    
                    <h4>Process States</h4>
                    
                    <table class="table table-bordered">
                        <thead class="table-dark">
                            <tr>
                                <th>State</th>
                                <th>Description</th>
                                <th>Transition</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>NEW</strong></td>
                                <td>Process is being created</td>
                                <td>→ READY (when fully initialized)</td>
                            </tr>
                            <tr>
                                <td><strong>READY</strong></td>
                                <td>Waiting for CPU assignment</td>
                                <td>→ RUNNING (when scheduler picks it)</td>
                            </tr>
                            <tr>
                                <td><strong>RUNNING</strong></td>
                                <td>Currently executing on CPU</td>
                                <td>→ READY (preempted) or → BLOCKED (waiting)</td>
                            </tr>
                            <tr>
                                <td><strong>BLOCKED</strong></td>
                                <td>Waiting for I/O or event</td>
                                <td>→ READY (when I/O completes)</td>
                            </tr>
                            <tr>
                                <td><strong>TERMINATED</strong></td>
                                <td>Finished execution</td>
                                <td>Resources freed, PCB removed</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3 id="privilege-levels">Privilege Levels (Protection Rings)</h3>
                    
                    <p>The x86 CPU has four <strong>privilege levels</strong> (rings 0-3), though most operating systems only use two. This hardware-enforced separation prevents user programs from corrupting the kernel or other processes.</p>
                    
<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│                 x86 PROTECTION RINGS                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                ┌─────────────────────┐                          │
│                │      RING 0         │   Kernel Mode            │
│                │    (Most Trusted)   │   - Full hardware access │
│                │                     │   - All instructions     │
│            ┌───┴─────────────────────┴───┐   - All memory       │
│            │         RING 1              │                      │
│            │    (Device Drivers)*        │   *Usually unused    │
│        ┌───┴─────────────────────────────┴───┐                  │
│        │             RING 2                  │   *Usually unused│
│        │        (Device Drivers)*            │                  │
│    ┌───┴─────────────────────────────────────┴───┐              │
│    │                 RING 3                      │   User Mode  │
│    │            (Least Trusted)                  │   - Limited  │
│    │          Applications Run Here              │   - Protected│
│    └─────────────────────────────────────────────┘              │
│                                                                  │
│   COMMON USAGE:                                                  │
│   ┌─────────────┐    ┌─────────────────────────┐               │
│   │   Ring 0    │ ←→ │  Kernel, Drivers, ISRs  │               │
│   └─────────────┘    └─────────────────────────┘               │
│   ┌─────────────┐    ┌─────────────────────────┐               │
│   │   Ring 3    │ ←→ │  User Applications      │               │
│   └─────────────┘    └─────────────────────────┘               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-shield-alt me-2"></i>
                        <strong>Why Rings Matter:</strong> In Ring 3, a program cannot:
                        <ul class="mb-0 mt-2">
                            <li>Execute privileged instructions (<code>HLT</code>, <code>LGDT</code>, <code>CLI</code>)</li>
                            <li>Access I/O ports directly</li>
                            <li>Read/write kernel memory (page protection enforced)</li>
                            <li>Modify critical CPU control registers</li>
                        </ul>
                        To do any of these, a user program must <strong>ask the kernel</strong> via a system call.
                    </div>
                    
                    <h4>CPL, DPL, and RPL</h4>
                    
<pre><code class="language-c">/*
 * Current Privilege Level (CPL) - Stored in CS register (bits 0-1)
 *   The CPU's current privilege level. 0 = kernel, 3 = user.
 *
 * Descriptor Privilege Level (DPL) - In segment descriptors
 *   The privilege level required to access that segment.
 *
 * Requested Privilege Level (RPL) - In segment selectors
 *   Used when loading segments, must be >= CPL to access.
 *
 * Access Rule:  CPL <= DPL  (lower number = more privilege)
 */

// Example: User code (CPL=3) cannot load kernel data segment (DPL=0)
// Attempting to do so triggers a General Protection Fault (#GP)

// Segment selector format:
// ┌──────────────────┬───────┬─────┐
// │  Index (13 bits) │ TI(1) │RPL(2)│
// └──────────────────┴───────┴─────┘
//   TI = 0: GDT, 1: LDT

#define KERNEL_CODE_SELECTOR  0x08  // Index 1, GDT, RPL 0
#define KERNEL_DATA_SELECTOR  0x10  // Index 2, GDT, RPL 0
#define USER_CODE_SELECTOR    0x1B  // Index 3, GDT, RPL 3
#define USER_DATA_SELECTOR    0x23  // Index 4, GDT, RPL 3
</code></pre>
                </div>

                <!-- TSS Section -->
                <div id="tss" class="blog-content mt-5">
                    <h2><i class="fas fa-layer-group me-2 text-teal"></i>Task State Segment (TSS)</h2>
                    
                    <p>When a user program makes a system call or an interrupt occurs, the CPU needs to switch from Ring 3 (user) to Ring 0 (kernel). But the user's stack is untrusted - we can't use it for kernel operations. The <strong>Task State Segment (TSS)</strong> tells the CPU where to find the kernel stack for privilege transitions.</p>
                    
<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│            TSS AND PRIVILEGE TRANSITION                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   USER MODE (Ring 3)              KERNEL MODE (Ring 0)          │
│   ┌────────────────┐              ┌────────────────┐            │
│   │  User Stack    │              │  Kernel Stack  │            │
│   │                │              │                │            │
│   │  ESP = 0x7FFF  │              │  ESP0 from TSS │            │
│   │                │              │                │            │
│   └────────────────┘              └────────────────┘            │
│          │                               ▲                      │
│          │  System Call (int 0x80)      │                       │
│          │  or Interrupt                │                       │
│          └───────────────────────────────┘                      │
│                                                                  │
│   CPU AUTOMATICALLY:                                             │
│   1. Reads SS0:ESP0 from TSS (kernel stack address)             │
│   2. Pushes user SS, ESP, EFLAGS, CS, EIP onto kernel stack     │
│   3. Loads CS:EIP from IDT (interrupt handler)                  │
│   4. Sets CPL = 0 (kernel mode)                                 │
│                                                                  │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                        TSS                               │   │
│   │  ┌──────────────────────────────────────────────────┐   │   │
│   │  │ ESP0 = 0x200000  ← Kernel stack top              │   │   │
│   │  │ SS0  = 0x10      ← Kernel data segment           │   │   │
│   │  │ ESP1 = 0         ← Ring 1 stack (unused)         │   │   │
│   │  │ SS1  = 0                                         │   │   │
│   │  │ ESP2 = 0         ← Ring 2 stack (unused)         │   │   │
│   │  │ SS2  = 0                                         │   │   │
│   │  │ IOMAP = 104      ← I/O permission bitmap         │   │   │
│   │  └──────────────────────────────────────────────────┘   │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
                    
                    <h3 id="tss-structure">TSS Structure</h3>
                    
                    <p>The TSS is a legacy from Intel's hardware task switching mechanism (rarely used today). For modern software task switching, we only need it to store the kernel stack pointer for privilege transitions.</p>

                    <pre><code class="language-c">/* tss.h - Task State Segment Definition */

#ifndef TSS_H
#define TSS_H

#include &lt;stdint.h&gt;

/* Task State Segment (32-bit) */
typedef struct {
    uint32_t prev_tss;    // Previous TSS link (for hardware switching)
    
    /* Ring 0 stack - ESSENTIAL for privilege transitions */
    uint32_t esp0;        // Stack pointer for ring 0
    uint32_t ss0;         // Stack segment for ring 0
    
    /* Ring 1 stack (typically unused) */
    uint32_t esp1;
    uint32_t ss1;
    
    /* Ring 2 stack (typically unused) */
    uint32_t esp2;
    uint32_t ss2;
    
    uint32_t cr3;         // Page directory base (for hardware switching)
    
    /* Saved registers (for hardware switching - we don't use these) */
    uint32_t eip;
    uint32_t eflags;
    uint32_t eax, ecx, edx, ebx;
    uint32_t esp, ebp, esi, edi;
    uint32_t es, cs, ss, ds, fs, gs;
    
    uint32_t ldt;         // LDT selector
    uint16_t trap;        // Debug trap flag
    uint16_t iomap_base;  // I/O permission bitmap offset
} __attribute__((packed)) tss_entry_t;

/* Global TSS instance */
extern tss_entry_t tss;

/* Initialize TSS with kernel stack address */
void tss_init(uint32_t kernel_stack);

/* Update kernel stack in TSS (called during task switch) */
void tss_set_kernel_stack(uint32_t stack);

#endif /* TSS_H */
</code></pre>
                    
                    <div class="highlight-box">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Why Only ESP0/SS0?</strong> In a Ring 3 → Ring 0 transition, the CPU only needs the Ring 0 stack. The other fields (ESP1, ESP2, saved registers) were for Intel's hardware task switching, which is slow and rarely used. Modern OSes do <strong>software task switching</strong>, saving registers manually in the interrupt handler.
                    </div>
                    
                    <h3 id="tss-setup">Setting Up TSS</h3>
                    
                    <p>Setting up the TSS requires three steps: initialize the structure, add a TSS descriptor to the GDT, and load it with the <code>LTR</code> instruction.</p>

                    <pre><code class="language-c">/* tss.c - Task State Segment Implementation */

#include "tss.h"
#include "gdt.h"
#include &lt;string.h&gt;

/* Global TSS instance */
tss_entry_t tss __attribute__((aligned(4)));

/* Initialize TSS */
void tss_init(uint32_t kernel_stack) {
    /* Zero out the TSS */
    memset(&tss, 0, sizeof(tss));
    
    /* Set kernel stack for Ring 0 - THE CRITICAL PART */
    tss.ss0 = KERNEL_DATA_SELECTOR;  // 0x10 - Kernel data segment
    tss.esp0 = kernel_stack;         // Top of kernel stack
    
    /* 
     * Set I/O permission bitmap offset beyond TSS limit
     * This denies all I/O port access from user mode
     * (offset > TSS limit means "no I/O bitmap, deny all")
     */
    tss.iomap_base = sizeof(tss);
    
    /* 
     * Install TSS descriptor in GDT (typically entry 5)
     * 
     * TSS Descriptor format:
     * - Base: Address of TSS structure
     * - Limit: sizeof(tss) - 1
     * - Access: 0x89 = Present, DPL 0, TSS (not busy)
     *           0xE9 = Present, DPL 3, TSS (accessible from ring 3)
     * - Flags: 0x00 (byte granularity, 16-bit - though limit is enough)
     */
    gdt_set_gate(5, (uint32_t)&tss, sizeof(tss) - 1, 0xE9, 0x00);
    
    /* 
     * Load TSS register
     * The selector is: index * 8 = 5 * 8 = 0x28
     * We OR with 3 to set RPL=3, making it accessible from user mode
     */
    uint16_t tss_selector = 0x28 | 0x03; // TSS selector with RPL 3
    
    asm volatile("ltr %0" : : "r"(tss_selector));
}

/* Update kernel stack (called when switching tasks) */
void tss_set_kernel_stack(uint32_t stack) {
    tss.esp0 = stack;
}
</code></pre>

                    <h4>GDT with User Segments and TSS</h4>
                    
                    <p>To support user mode, we need to expand our GDT with Ring 3 code and data segments, plus the TSS descriptor:</p>

                    <pre><code class="language-c">/* gdt.c - Extended GDT for User Mode */

#include "gdt.h"

/* GDT entries */
gdt_entry_t gdt[6];
gdt_ptr_t gdt_ptr;

void gdt_init(void) {
    gdt_ptr.limit = sizeof(gdt) - 1;
    gdt_ptr.base = (uint32_t)&gdt;
    
    /* Entry 0: Null descriptor (required) */
    gdt_set_gate(0, 0, 0, 0, 0);
    
    /* Entry 1: Kernel Code Segment - Selector 0x08 */
    /* Base=0, Limit=4GB, Execute/Read, Ring 0 */
    gdt_set_gate(1, 0, 0xFFFFFFFF, 0x9A, 0xCF);
    
    /* Entry 2: Kernel Data Segment - Selector 0x10 */
    /* Base=0, Limit=4GB, Read/Write, Ring 0 */
    gdt_set_gate(2, 0, 0xFFFFFFFF, 0x92, 0xCF);
    
    /* Entry 3: User Code Segment - Selector 0x18 (0x1B with RPL 3) */
    /* Base=0, Limit=4GB, Execute/Read, Ring 3 */
    gdt_set_gate(3, 0, 0xFFFFFFFF, 0xFA, 0xCF);
    
    /* Entry 4: User Data Segment - Selector 0x20 (0x23 with RPL 3) */
    /* Base=0, Limit=4GB, Read/Write, Ring 3 */
    gdt_set_gate(4, 0, 0xFFFFFFFF, 0xF2, 0xCF);
    
    /* Entry 5: TSS - Selector 0x28 */
    /* Will be set up by tss_init() */
    
    /* Load GDT */
    gdt_flush((uint32_t)&gdt_ptr);
}

/*
 * Access byte breakdown:
 * 
 * Kernel Code (0x9A): 1 00 1 1010
 *   Present=1, DPL=0, System=1, Type=Execute/Read
 * 
 * Kernel Data (0x92): 1 00 1 0010
 *   Present=1, DPL=0, System=1, Type=Read/Write
 * 
 * User Code (0xFA): 1 11 1 1010
 *   Present=1, DPL=3, System=1, Type=Execute/Read
 * 
 * User Data (0xF2): 1 11 1 0010
 *   Present=1, DPL=3, System=1, Type=Read/Write
 *
 * TSS (0xE9): 1 11 0 1001
 *   Present=1, DPL=3, System=0, Type=TSS (available)
 */
</code></pre>

                    <div class="experiment-card">
                        <h4><i class="fas fa-memory me-2"></i>GDT Layout Diagram</h4>
                        <div class="content">
<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│                  EXTENDED GDT LAYOUT                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Index    Selector     Description           DPL   Type        │
│   ─────    ────────     ───────────           ───   ────        │
│     0        0x00       Null Descriptor        -    Required    │
│     1        0x08       Kernel Code Segment    0    Exec/Read   │
│     2        0x10       Kernel Data Segment    0    Read/Write  │
│     3        0x18       User Code Segment      3    Exec/Read   │
│     4        0x20       User Data Segment      3    Read/Write  │
│     5        0x28       Task State Segment     3    TSS         │
│                                                                  │
│   When loading segment registers from USER mode:                 │
│   - User Code: CS = 0x1B  (0x18 | 0x03 for RPL=3)              │
│   - User Data: DS = 0x23  (0x20 | 0x03 for RPL=3)              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
                        </div>
                    </div>
                </div>

                <!-- Context Switch Section -->
                <div id="context-switch" class="blog-content mt-5">
                    <h2><i class="fas fa-sync me-2 text-teal"></i>Context Switching</h2>
                    
                    <p>The <strong>context switch</strong> is the heart of multitasking. It's the mechanism that saves one process's state and loads another's, creating the illusion that multiple programs run simultaneously.</p>
                    
<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│                   CONTEXT SWITCH FLOW                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   TIME ──────────────────────────────────────────────────────▶ │
│                                                                  │
│   PROCESS A      CONTEXT        PROCESS B      CONTEXT          │
│   RUNNING        SWITCH         RUNNING        SWITCH           │
│   ┌─────┐   ┌─────────────┐    ┌─────┐    ┌─────────────┐      │
│   │ A   │──▶│ Save A      │──▶│ B   │──▶│ Save B      │──▶...  │
│   │runs │   │ Load B      │   │runs │   │ Load A      │        │
│   └─────┘   └─────────────┘   └─────┘   └─────────────┘        │
│                                                                  │
│   WHAT GETS SAVED/RESTORED:                                      │
│   ┌──────────────────────────────────────────────────────────┐  │
│   │  • CPU Registers: EAX, EBX, ECX, EDX, ESI, EDI, EBP     │  │
│   │  • Stack Pointer: ESP (crucial for resuming execution)   │  │
│   │  • Instruction Pointer: EIP (where to continue)          │  │
│   │  • Flags: EFLAGS (CPU state flags)                       │  │
│   │  • Segment Registers: CS, DS, ES, FS, GS, SS            │  │
│   │  • Page Directory: CR3 (address space switch)            │  │
│   └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│   TRIGGERED BY:                                                  │
│   • Timer interrupt (preemptive multitasking)                   │
│   • System call (process yields or blocks)                      │
│   • I/O completion (waking a blocked process)                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
                    
                    <h3 id="pcb">Process Control Block (PCB)</h3>
                    
                    <p>The PCB is the kernel's record for each process. It contains everything needed to stop a process mid-execution and resume it later exactly where it left off.</p>

                    <pre><code class="language-c">/* process.h - Process Control Block */

#ifndef PROCESS_H
#define PROCESS_H

#include &lt;stdint.h&gt;

/* Process states */
typedef enum {
    PROCESS_STATE_NEW,        // Being created
    PROCESS_STATE_READY,      // Ready to run
    PROCESS_STATE_RUNNING,    // Currently executing
    PROCESS_STATE_BLOCKED,    // Waiting for I/O/event
    PROCESS_STATE_TERMINATED  // Finished execution
} process_state_t;

/* Saved CPU context - matches stack layout from interrupt */
typedef struct {
    /* Pushed by 'pusha' */
    uint32_t edi, esi, ebp, esp_dummy, ebx, edx, ecx, eax;
    
    /* Pushed by interrupt stub */
    uint32_t int_no, err_code;
    
    /* Pushed by CPU on interrupt */
    uint32_t eip, cs, eflags, user_esp, user_ss;
} cpu_context_t;

/* Process Control Block */
typedef struct pcb {
    /* Process identification */
    uint32_t pid;             // Unique process ID
    uint32_t parent_pid;      // Parent process ID
    char name[32];            // Process name (for debugging)
    
    /* Process state */
    process_state_t state;
    int exit_code;            // Exit status (when terminated)
    
    /* Memory management */
    uint32_t* page_directory; // Virtual address space
    uint32_t kernel_stack;    // Top of kernel stack
    uint32_t user_stack;      // Top of user stack
    
    /* CPU context saved during switch */
    uint32_t esp;             // Stack pointer (to saved context)
    uint32_t ebp;             // Base pointer
    uint32_t eip;             // Instruction pointer
    
    /* Scheduling */
    uint32_t priority;        // Higher = more important
    uint32_t time_slice;      // Remaining time in milliseconds
    uint32_t total_time;      // Total CPU time used
    
    /* File descriptors (simplified) */
    void* files[16];          // Open file handles
    
    /* Linked list for scheduler queues */
    struct pcb* next;
    struct pcb* prev;
} pcb_t;

/* Process management globals */
extern pcb_t* current_process;  // Currently running process
extern pcb_t* ready_queue;      // List of ready processes
extern uint32_t next_pid;       // Next available PID

/* Process management functions */
pcb_t* process_create(const char* name, void* entry_point, uint32_t priority);
void process_destroy(pcb_t* process);
void process_yield(void);
void process_block(process_state_t reason);
void process_unblock(pcb_t* process);

/* Context switching */
extern void switch_context(uint32_t* old_esp, uint32_t new_esp);

#endif /* PROCESS_H */
</code></pre>
                    
                    <div class="highlight-box">
                        <i class="fas fa-lightbulb me-2"></i>
                        <strong>Why Save ESP?</strong> The key insight is that we don't need to save ALL registers manually. When a process is interrupted (timer, syscall), the CPU and our handler already push everything onto the stack. We just save the stack pointer - when we restore ESP and return, all registers come back automatically!
                    </div>
                    
                    <h3 id="switch-code">Switch Implementation</h3>
                    
                    <p>The actual context switch is elegant: save the current stack pointer, load the new one, and return. Since the return address and all registers are on the stack, we seamlessly resume the new process.</p>

                    <pre><code class="language-nasm">; switch.asm - Low-level context switch
; void switch_context(uint32_t* old_esp, uint32_t new_esp)
;
; Parameters:
;   old_esp: Pointer to where to save current ESP
;   new_esp: The ESP value to switch to

global switch_context
section .text

switch_context:
    ; ========================================
    ; PHASE 1: Save current process context
    ; ========================================
    
    ; Save callee-saved registers (cdecl convention)
    push ebp
    push ebx
    push esi
    push edi
    
    ; Get pointer to old_esp (where to save)
    mov eax, [esp + 20]     ; old_esp is at esp+20 (after pushes)
    
    ; Save current stack pointer
    mov [eax], esp          ; *old_esp = current ESP
    
    ; ========================================
    ; PHASE 2: Load new process context
    ; ========================================
    
    ; Get new stack pointer
    mov esp, [esp + 24]     ; new_esp is at esp+24
    
    ; Restore callee-saved registers from new stack
    pop edi
    pop esi
    pop ebx
    pop ebp
    
    ; Return pops EIP from new stack, continuing new process
    ret
</code></pre>

                    <p>The C wrapper and process management:</p>

                    <pre><code class="language-c">/* process.c - Process Management */

#include "process.h"
#include "pmm.h"
#include "vmm.h"
#include "heap.h"
#include "tss.h"
#include &lt;string.h&gt;

/* Globals */
pcb_t* current_process = NULL;
pcb_t* ready_queue = NULL;
uint32_t next_pid = 1;

/* Kernel stack size per process */
#define KERNEL_STACK_SIZE 4096

/* Create a new process */
pcb_t* process_create(const char* name, void* entry_point, uint32_t priority) {
    /* Allocate PCB */
    pcb_t* proc = (pcb_t*)kmalloc(sizeof(pcb_t));
    if (!proc) return NULL;
    
    memset(proc, 0, sizeof(pcb_t));
    
    /* Basic info */
    proc->pid = next_pid++;
    proc->parent_pid = current_process ? current_process->pid : 0;
    strncpy(proc->name, name, sizeof(proc->name) - 1);
    proc->state = PROCESS_STATE_NEW;
    proc->priority = priority;
    proc->time_slice = 100;  // 100ms default time slice
    
    /* Create address space (clone kernel mappings) */
    proc->page_directory = vmm_create_address_space();
    if (!proc->page_directory) {
        kfree(proc);
        return NULL;
    }
    
    /* Allocate kernel stack */
    proc->kernel_stack = (uint32_t)kmalloc(KERNEL_STACK_SIZE);
    if (!proc->kernel_stack) {
        vmm_destroy_address_space(proc->page_directory);
        kfree(proc);
        return NULL;
    }
    proc->kernel_stack += KERNEL_STACK_SIZE;  // Stack grows down
    
    /* 
     * Set up initial stack frame
     * When switch_context runs, it will pop these and 'ret' to entry_point
     */
    uint32_t* stack = (uint32_t*)proc->kernel_stack;
    
    /* Create fake "saved" context on stack */
    *(--stack) = (uint32_t)entry_point;  // Return address (EIP)
    *(--stack) = 0;                       // EBP
    *(--stack) = 0;                       // EBX
    *(--stack) = 0;                       // ESI
    *(--stack) = 0;                       // EDI
    
    proc->esp = (uint32_t)stack;
    proc->state = PROCESS_STATE_READY;
    
    /* Add to ready queue */
    if (!ready_queue) {
        ready_queue = proc;
        proc->next = proc;  // Circular list
        proc->prev = proc;
    } else {
        proc->next = ready_queue;
        proc->prev = ready_queue->prev;
        ready_queue->prev->next = proc;
        ready_queue->prev = proc;
    }
    
    return proc;
}

/* Destroy a process and free resources */
void process_destroy(pcb_t* process) {
    /* Remove from scheduler queue */
    if (process->next == process) {
        /* Only process in queue */
        ready_queue = NULL;
    } else {
        process->prev->next = process->next;
        process->next->prev = process->prev;
        if (ready_queue == process) {
            ready_queue = process->next;
        }
    }
    
    /* Free resources */
    vmm_destroy_address_space(process->page_directory);
    kfree((void*)(process->kernel_stack - KERNEL_STACK_SIZE));
    kfree(process);
}

/* Voluntarily give up CPU */
void process_yield(void) {
    schedule();  // Pick next process
}
</code></pre>
                    
                    <h3 id="scheduler">Simple Scheduler</h3>
                    
                    <p>The scheduler decides which process runs next. We'll implement a simple <strong>Round-Robin</strong> scheduler - each process gets equal time slices in rotation.</p>

<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│                    ROUND-ROBIN SCHEDULING                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Ready Queue (circular):                                        │
│                                                                  │
│   ┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐                     │
│   │  A  │───▶│  B  │───▶│  C  │───▶│  D  │───┐                 │
│   └─────┘    └─────┘    └─────┘    └─────┘   │                 │
│       ▲                                      │                  │
│       └──────────────────────────────────────┘                  │
│                                                                  │
│   Timeline:                                                      │
│   ────────────────────────────────────────────────▶             │
│   │   A   │   B   │   C   │   D   │   A   │   B   │...         │
│   └───────┴───────┴───────┴───────┴───────┴───────┘             │
│    10ms    10ms    10ms    10ms    10ms    10ms                  │
│                                                                  │
│   Each process gets equal time quantum (time slice)             │
│   Timer interrupt triggers scheduler at end of quantum          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>

                    <pre><code class="language-c">/* scheduler.c - Round-Robin Scheduler */

#include "process.h"
#include "tss.h"

/* Time slice duration in timer ticks */
#define TIME_QUANTUM_TICKS 10  // ~10ms with 1000Hz timer

static uint32_t ticks_remaining = TIME_QUANTUM_TICKS;

/* 
 * Called from timer interrupt handler
 * Decrements time slice and triggers schedule when expired
 */
void scheduler_tick(void) {
    if (current_process == NULL) return;
    
    ticks_remaining--;
    current_process->total_time++;
    
    if (ticks_remaining == 0) {
        ticks_remaining = TIME_QUANTUM_TICKS;
        schedule();  // Time's up, switch process
    }
}

/*
 * Pick next process and switch to it
 * Called from:
 *   - Timer interrupt (preemption)
 *   - process_yield() (voluntary)
 *   - process_block() (waiting for I/O)
 */
void schedule(void) {
    if (!current_process || !ready_queue) return;
    
    pcb_t* old = current_process;
    pcb_t* next = NULL;
    
    /* Round-Robin: pick next in circular queue */
    if (old->state == PROCESS_STATE_RUNNING) {
        old->state = PROCESS_STATE_READY;
        next = old->next;
    } else {
        /* Old process blocked, skip it */
        next = ready_queue;
    }
    
    /* Find a READY process */
    pcb_t* start = next;
    do {
        if (next->state == PROCESS_STATE_READY) {
            break;
        }
        next = next->next;
    } while (next != start);
    
    /* No ready processes? Should not happen (idle process) */
    if (next->state != PROCESS_STATE_READY) {
        return;  // Keep running current or halt
    }
    
    next->state = PROCESS_STATE_RUNNING;
    current_process = next;
    ticks_remaining = TIME_QUANTUM_TICKS;
    
    /* Update TSS with new kernel stack */
    tss_set_kernel_stack(next->kernel_stack);
    
    /* Switch page directory (address space) */
    asm volatile("mov %0, %%cr3" : : "r"(next->page_directory));
    
    /* Perform the actual context switch */
    switch_context(&old->esp, next->esp);
}

/* Block current process (e.g., waiting for I/O) */
void process_block(process_state_t reason) {
    current_process->state = reason;
    schedule();
}

/* Unblock a process (e.g., I/O complete) */
void process_unblock(pcb_t* process) {
    process->state = PROCESS_STATE_READY;
    /* If higher priority, might want to reschedule immediately */
}
</code></pre>

                    <div class="experiment-card">
                        <h4><i class="fas fa-flask me-2"></i>Understanding Context Switch Timing</h4>
                        <div class="content">
<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│            TIMER INTERRUPT → CONTEXT SWITCH                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Process A running                                              │
│   │                                                              │
│   │  ┌───────────────────────┐                                  │
│   │  │  add eax, ebx        │  ← Executing user code            │
│   │  │  mov [esi], eax      │                                   │
│   └──│  ...                 │                                   │
│      └───────────┬──────────┘                                   │
│                  │                                               │
│   TIMER IRQ!     ▼                                               │
│   ┌──────────────────────────────────┐                          │
│   │ 1. CPU pushes SS,ESP,EFLAGS,CS,EIP│  (onto kernel stack)    │
│   │ 2. CPU switches to Ring 0        │                          │
│   │ 3. CPU jumps to IDT[32] handler  │                          │
│   └──────────────────────────────────┘                          │
│                  │                                               │
│                  ▼                                               │
│   ┌──────────────────────────────────┐                          │
│   │ timer_handler:                   │                          │
│   │   pusha                          │  Save all registers      │
│   │   call scheduler_tick            │  Check time slice        │
│   │     → calls schedule()           │  (if expired)            │
│   │       → switch_context()         │  MAGIC HAPPENS HERE      │
│   │                                  │                          │
│   │ Stack now belongs to Process B!  │                          │
│   │   popa                           │  Restore B's registers   │
│   │   iret                           │  Return to Process B     │
│   └──────────────────────────────────┘                          │
│                  │                                               │
│   Process B resuming                                             │
│   │  ┌───────────────────────┐                                  │
│   │  │  xor ecx, ecx        │  ← Process B continues            │
│   └──│  call printf         │    as if nothing happened         │
│      └──────────────────────┘                                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
                            <p class="mt-3">The beauty: Process A has no idea it was interrupted. When it runs again, it continues exactly where it left off.</p>
                        </div>
                    </div>
                </div>

                <!-- System Calls Section -->
                <div id="system-calls" class="blog-content mt-5">
                    <h2><i class="fas fa-door-open me-2 text-teal"></i>System Calls</h2>
                    
                    <p>User programs run in Ring 3 with limited privileges - they can't access hardware or kernel memory directly. When a user program needs to read a file, allocate memory, or communicate with the network, it must <strong>ask the kernel</strong>. System calls are the controlled gateway between user space and kernel space.</p>
                    
<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│                    SYSTEM CALL MECHANISM                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   USER SPACE (Ring 3)                                           │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │  Application Code                                         │ │
│   │  ──────────────────                                       │ │
│   │  int fd = open("file.txt", O_RDONLY);                    │ │
│   │              │                                            │ │
│   │              ▼                                            │ │
│   │  ┌──────────────────────────────────────────┐            │ │
│   │  │  C Library Wrapper (libc)                │            │ │
│   │  │  ────────────────────────                │            │ │
│   │  │  int open(const char* path, int flags) { │            │ │
│   │  │      return syscall(SYS_OPEN, path, flags);│           │ │
│   │  │  }                                       │            │ │
│   │  └─────────────────────┬────────────────────┘            │ │
│   └────────────────────────│────────────────────────────────┬─┘ │
│   ═════════════════════════│════════════════════════════════│═══ │
│   ┌────────────────────────│────────────────────────────────│─┐ │
│   │                        │  int 0x80                      │ │ │
│   │                        │  or SYSCALL instruction        │ │ │
│   │                        ▼                                │ │ │
│   │  ┌──────────────────────────────────────────┐         │ │ │
│   │  │  Kernel Syscall Handler                  │         │ │ │
│   │  │  ────────────────────────                │         │ │ │
│   │  │  1. Validate arguments (pointers, etc.)  │         │ │ │
│   │  │  2. Execute kernel function              │         │ │ │
│   │  │  3. Return result to user               │         │ │ │
│   │  └──────────────────────────────────────────┘         │ │ │
│   │                                                       │ │ │
│   │  KERNEL SPACE (Ring 0)                               │ │ │
│   └───────────────────────────────────────────────────────┘ │ │
│                                                              │ │
└──────────────────────────────────────────────────────────────┘ │
                                                                  │
   Returns result via EAX register ◀──────────────────────────────┘
</code></pre>
                    
                    <h3 id="syscall-design">System Call Design</h3>
                    
                    <p>We'll use the traditional x86 approach: software interrupt <code>int 0x80</code>. Parameters are passed in registers, and the return value comes back in EAX.</p>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-table me-2"></i>System Call Calling Convention</h4>
                        <div class="content">
                            <table class="table table-bordered">
                                <thead class="table-dark">
                                    <tr>
                                        <th>Register</th>
                                        <th>Purpose</th>
                                        <th>Example</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>EAX</code></td>
                                        <td>System call number</td>
                                        <td><code>1</code> = write</td>
                                    </tr>
                                    <tr>
                                        <td><code>EBX</code></td>
                                        <td>First argument</td>
                                        <td>File descriptor</td>
                                    </tr>
                                    <tr>
                                        <td><code>ECX</code></td>
                                        <td>Second argument</td>
                                        <td>Buffer pointer</td>
                                    </tr>
                                    <tr>
                                        <td><code>EDX</code></td>
                                        <td>Third argument</td>
                                        <td>Count (bytes)</td>
                                    </tr>
                                    <tr>
                                        <td><code>ESI</code></td>
                                        <td>Fourth argument</td>
                                        <td>(if needed)</td>
                                    </tr>
                                    <tr>
                                        <td><code>EDI</code></td>
                                        <td>Fifth argument</td>
                                        <td>(if needed)</td>
                                    </tr>
                                    <tr>
                                        <td><code>EAX</code> (return)</td>
                                        <td>Return value</td>
                                        <td>Bytes written, or -errno</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <pre><code class="language-c">/* syscall.h - System Call Definitions */

#ifndef SYSCALL_H
#define SYSCALL_H

/* System call numbers - keep in sync with user-space headers */
#define SYS_EXIT        0
#define SYS_FORK        1
#define SYS_READ        2
#define SYS_WRITE       3
#define SYS_OPEN        4
#define SYS_CLOSE       5
#define SYS_WAITPID     6
#define SYS_EXEC        7
#define SYS_GETPID      8
#define SYS_SBRK        9   // Heap memory allocation
#define SYS_SLEEP       10
#define SYS_YIELD       11

#define NUM_SYSCALLS    12

/* Error codes (negative return values) */
#define ENOENT          -2   // No such file or directory
#define ENOMEM          -12  // Out of memory
#define EINVAL          -22  // Invalid argument
#define ENOSYS          -38  // Function not implemented

/* Initialize system call handler */
void syscall_init(void);

#endif /* SYSCALL_H */
</code></pre>
                    
                    <h3 id="syscall-handler">Handler Implementation</h3>
                    
                    <p>The syscall handler is triggered by <code>int 0x80</code>. It looks up the requested system call in a table and executes the corresponding kernel function.</p>

                    <pre><code class="language-c">/* syscall.c - System Call Handler */

#include "syscall.h"
#include "isr.h"
#include "process.h"
#include "vfs.h"
#include "heap.h"
#include &lt;string.h&gt;

/* Forward declarations of syscall handlers */
static int sys_exit(int status);
static int sys_fork(registers_t* regs);
static int sys_read(int fd, void* buf, size_t count);
static int sys_write(int fd, const void* buf, size_t count);
static int sys_open(const char* path, int flags);
static int sys_close(int fd);
static int sys_waitpid(int pid, int* status, int options);
static int sys_exec(const char* path, char* const argv[]);
static int sys_getpid(void);
static void* sys_sbrk(intptr_t increment);
static int sys_sleep(unsigned int seconds);
static int sys_yield(void);

/* Syscall function pointer type */
typedef int (*syscall_handler_t)(void);

/* System call table */
static void* syscall_handlers[NUM_SYSCALLS] = {
    [SYS_EXIT]    = sys_exit,
    [SYS_FORK]    = sys_fork,
    [SYS_READ]    = sys_read,
    [SYS_WRITE]   = sys_write,
    [SYS_OPEN]    = sys_open,
    [SYS_CLOSE]   = sys_close,
    [SYS_WAITPID] = sys_waitpid,
    [SYS_EXEC]    = sys_exec,
    [SYS_GETPID]  = sys_getpid,
    [SYS_SBRK]    = sys_sbrk,
    [SYS_SLEEP]   = sys_sleep,
    [SYS_YIELD]   = sys_yield,
};

/* Main system call dispatcher */
static void syscall_handler(registers_t* regs) {
    /* Syscall number in EAX */
    uint32_t syscall_num = regs->eax;
    
    /* Validate syscall number */
    if (syscall_num >= NUM_SYSCALLS || !syscall_handlers[syscall_num]) {
        regs->eax = ENOSYS;  // Function not implemented
        return;
    }
    
    /* Get arguments from registers */
    uint32_t arg1 = regs->ebx;
    uint32_t arg2 = regs->ecx;
    uint32_t arg3 = regs->edx;
    uint32_t arg4 = regs->esi;
    uint32_t arg5 = regs->edi;
    
    /* Call the handler - different syscalls take different args */
    int result;
    
    switch (syscall_num) {
        case SYS_EXIT:
            result = sys_exit(arg1);
            break;
        case SYS_FORK:
            result = sys_fork(regs);  // Needs full register state
            break;
        case SYS_READ:
            result = sys_read(arg1, (void*)arg2, arg3);
            break;
        case SYS_WRITE:
            result = sys_write(arg1, (void*)arg2, arg3);
            break;
        case SYS_OPEN:
            result = sys_open((char*)arg1, arg2);
            break;
        case SYS_CLOSE:
            result = sys_close(arg1);
            break;
        case SYS_WAITPID:
            result = sys_waitpid(arg1, (int*)arg2, arg3);
            break;
        case SYS_EXEC:
            result = sys_exec((char*)arg1, (char**)arg2);
            break;
        case SYS_GETPID:
            result = sys_getpid();
            break;
        case SYS_SBRK:
            result = (int)sys_sbrk((intptr_t)arg1);
            break;
        case SYS_SLEEP:
            result = sys_sleep(arg1);
            break;
        case SYS_YIELD:
            result = sys_yield();
            break;
        default:
            result = ENOSYS;
    }
    
    /* Return value goes in EAX */
    regs->eax = result;
}

/* Install syscall handler */
void syscall_init(void) {
    /* 
     * Register int 0x80 handler
     * DPL = 3 so user code can trigger it
     * Type = Trap gate (0xEE) - interrupts stay enabled
     */
    idt_set_gate(0x80, (uint32_t)syscall_stub, 0x08, 0xEE);
}

/*
 * Syscall stub in assembly (in isr.asm)
 * Pushes registers, calls syscall_handler, pops registers, iret
 */
</code></pre>

                    <p>Assembly stub for the syscall entry point:</p>

                    <pre><code class="language-nasm">; syscall_stub in isr.asm
global syscall_stub
extern syscall_handler

syscall_stub:
    ; Save all registers
    pusha
    push ds
    push es
    push fs
    push gs
    
    ; Load kernel data segment
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    
    ; Pass pointer to saved registers
    push esp
    call syscall_handler
    add esp, 4
    
    ; Restore segments
    pop gs
    pop fs
    pop es
    pop ds
    
    ; Restore registers (EAX modified by handler = return value)
    popa
    
    ; Return to user mode
    iret
</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Security Critical:</strong> Always validate user pointers! A malicious program might pass a kernel address as a buffer. Before using any pointer from user space, verify it points to user-accessible memory:
                        <pre class="mt-2 mb-0"><code class="language-c">static int validate_user_ptr(void* ptr, size_t size) {
    // Check pointer is in user address range
    if ((uint32_t)ptr < USER_SPACE_START ||
        (uint32_t)ptr + size > USER_SPACE_END) {
        return 0;  // Invalid
    }
    return 1;  // OK
}</code></pre>
                    </div>
                    
                    <h4>Implementing Key System Calls</h4>
                    
                    <pre><code class="language-c">/* Process-related syscalls */

static int sys_exit(int status) {
    current_process->state = PROCESS_STATE_TERMINATED;
    current_process->exit_code = status;
    
    /* Wake up parent if it's waiting */
    // TODO: Implement waitpid wakeup
    
    /* Switch to another process */
    schedule();
    
    /* Never returns */
    return 0;
}

static int sys_getpid(void) {
    return current_process->pid;
}

static int sys_yield(void) {
    schedule();
    return 0;
}

/* File I/O syscalls */

static int sys_write(int fd, const void* buf, size_t count) {
    /* Validate buffer */
    if (!validate_user_ptr((void*)buf, count)) {
        return EINVAL;
    }
    
    /* Special case: stdout (fd=1) and stderr (fd=2) */
    if (fd == 1 || fd == 2) {
        /* Write to console */
        const char* str = (const char*)buf;
        for (size_t i = 0; i < count; i++) {
            terminal_putchar(str[i]);
        }
        return count;
    }
    
    /* Regular file */
    vfs_node_t* node = current_process->files[fd];
    if (!node) return EINVAL;
    
    return vfs_write(node, 0, count, (uint8_t*)buf);
}

static int sys_read(int fd, void* buf, size_t count) {
    if (!validate_user_ptr(buf, count)) {
        return EINVAL;
    }
    
    /* Special case: stdin (fd=0) */
    if (fd == 0) {
        /* Read from keyboard buffer */
        char* str = (char*)buf;
        for (size_t i = 0; i < count; i++) {
            str[i] = keyboard_getchar();  // May block
            if (str[i] == '\n') {
                return i + 1;
            }
        }
        return count;
    }
    
    vfs_node_t* node = current_process->files[fd];
    if (!node) return EINVAL;
    
    return vfs_read(node, 0, count, (uint8_t*)buf);
}

/* Memory syscall */
static void* sys_sbrk(intptr_t increment) {
    /* Adjust process heap */
    // Simplified: just allocate from kernel heap for now
    if (increment > 0) {
        return kmalloc(increment);
    }
    return (void*)-1;  // Error
}
</code></pre>
                    
                    <h3 id="syscall-api">User-Space API</h3>
                    
                    <p>User programs need a clean interface to make system calls. We provide wrapper functions that set up registers and execute <code>int 0x80</code>.</p>

                    <pre><code class="language-c">/* user/syscall.h - User-space syscall wrappers */

#ifndef _USER_SYSCALL_H
#define _USER_SYSCALL_H

/* System call numbers (must match kernel) */
#define SYS_EXIT    0
#define SYS_FORK    1
#define SYS_READ    2
#define SYS_WRITE   3
#define SYS_OPEN    4
#define SYS_CLOSE   5
#define SYS_GETPID  8
#define SYS_YIELD   11

/* Generic syscall macros */

static inline int syscall0(int num) {
    int ret;
    asm volatile(
        "int $0x80"
        : "=a"(ret)
        : "a"(num)
        : "memory"
    );
    return ret;
}

static inline int syscall1(int num, int arg1) {
    int ret;
    asm volatile(
        "int $0x80"
        : "=a"(ret)
        : "a"(num), "b"(arg1)
        : "memory"
    );
    return ret;
}

static inline int syscall2(int num, int arg1, int arg2) {
    int ret;
    asm volatile(
        "int $0x80"
        : "=a"(ret)
        : "a"(num), "b"(arg1), "c"(arg2)
        : "memory"
    );
    return ret;
}

static inline int syscall3(int num, int arg1, int arg2, int arg3) {
    int ret;
    asm volatile(
        "int $0x80"
        : "=a"(ret)
        : "a"(num), "b"(arg1), "c"(arg2), "d"(arg3)
        : "memory"
    );
    return ret;
}

/* User-friendly wrappers */

static inline void exit(int status) {
    syscall1(SYS_EXIT, status);
    while (1) {}  // Should never return
}

static inline int getpid(void) {
    return syscall0(SYS_GETPID);
}

static inline int write(int fd, const void* buf, int count) {
    return syscall3(SYS_WRITE, fd, (int)buf, count);
}

static inline int read(int fd, void* buf, int count) {
    return syscall3(SYS_READ, fd, (int)buf, count);
}

static inline void yield(void) {
    syscall0(SYS_YIELD);
}

/* Simple printf for user space */
static inline void puts(const char* str) {
    int len = 0;
    while (str[len]) len++;
    write(1, str, len);
}

#endif /* _USER_SYSCALL_H */
</code></pre>

                    <div class="experiment-card">
                        <h4><i class="fas fa-vial me-2"></i>Example User Program</h4>
                        <div class="content">
                            <pre><code class="language-c">/* user/hello.c - Simple user program */

#include "syscall.h"

void _start(void) {
    /* This runs in Ring 3! */
    
    int pid = getpid();
    
    puts("Hello from user space!\n");
    puts("My PID is: ");
    
    /* Simple number printing */
    char buf[16];
    int i = 0;
    int tmp = pid;
    do {
        buf[i++] = '0' + (tmp % 10);
        tmp /= 10;
    } while (tmp > 0);
    
    /* Reverse */
    for (int j = 0; j < i / 2; j++) {
        char t = buf[j];
        buf[j] = buf[i - 1 - j];
        buf[i - 1 - j] = t;
    }
    buf[i++] = '\n';
    
    write(1, buf, i);
    
    /* Exit cleanly */
    exit(0);
}</code></pre>
                            <p class="mt-2"><strong>Note:</strong> User programs use <code>_start</code> instead of <code>main</code> - there's no C runtime yet to call main().</p>
                        </div>
                    </div>
                </div>

                <!-- User Mode Section -->
                <div id="user-mode" class="blog-content mt-5">
                    <h2><i class="fas fa-user-shield me-2 text-teal"></i>Entering User Mode</h2>
                    
                    <p>The final piece of the process puzzle: actually running user code in Ring 3. This requires careful setup of the GDT user segments, proper stack preparation, and using <code>iret</code> to make the privilege transition.</p>
                    
<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│                 ENTERING USER MODE (Ring 3)                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   KERNEL (Ring 0)                                               │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  1. Allocate user stack (at 0x7FFFF000)                 │   │
│   │  2. Load program into user address space                │   │
│   │  3. Set up stack for IRET "return to user"              │   │
│   │                                                         │   │
│   │  Stack Layout for IRET:                                 │   │
│   │  ┌─────────────────┐ ← Current ESP                     │   │
│   │  │   User SS       │ (0x23 - user data + RPL 3)        │   │
│   │  ├─────────────────┤                                    │   │
│   │  │   User ESP      │ (0x7FFFFFF0 - top of user stack)  │   │
│   │  ├─────────────────┤                                    │   │
│   │  │   EFLAGS        │ (0x202 - IF set for interrupts)   │   │
│   │  ├─────────────────┤                                    │   │
│   │  │   User CS       │ (0x1B - user code + RPL 3)        │   │
│   │  ├─────────────────┤                                    │   │
│   │  │   User EIP      │ (entry point of user program)     │   │
│   │  └─────────────────┘                                    │   │
│   │                                                         │   │
│   │  4. Execute IRET instruction                            │   │
│   └─────────────────────────────────────────────────────────┘   │
│                          │                                      │
│                          │ IRET pops all 5 values              │
│                          │ CPU switches to Ring 3              │
│                          ▼                                      │
│   USER (Ring 3)                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  User program now executing!                            │   │
│   │  - Cannot access kernel memory                          │   │
│   │  - Cannot execute privileged instructions               │   │
│   │  - Must use syscalls for kernel services                │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
                    
                    <h3 id="ring3-setup">Ring 3 Setup</h3>
                    
                    <p>Before we can enter user mode, we need to set up the user address space with proper page mappings and ensure our GDT has user-accessible segments.</p>

                    <pre><code class="language-c">/* user_mode.c - Entering User Mode */

#include "process.h"
#include "vmm.h"
#include "tss.h"
#include &lt;stdint.h&gt;

/* User address space layout */
#define USER_STACK_TOP      0x7FFFFFF0   // Just below 2GB
#define USER_STACK_SIZE     0x10000      // 64KB stack
#define USER_STACK_BOTTOM   (USER_STACK_TOP - USER_STACK_SIZE + 16)
#define USER_CODE_START     0x08000000   // 128MB mark
#define USER_HEAP_START     0x10000000   // 256MB mark

/* Segment selectors with RPL 3 */
#define USER_CODE_SELECTOR  0x1B  // GDT[3] (0x18) | RPL 3
#define USER_DATA_SELECTOR  0x23  // GDT[4] (0x20) | RPL 3

/* Setup user address space */
int setup_user_space(pcb_t* proc) {
    /* Create a new page directory (clones kernel mappings) */
    proc->page_directory = vmm_create_address_space();
    if (!proc->page_directory) return -1;
    
    /* Allocate and map user stack pages */
    for (uint32_t addr = USER_STACK_BOTTOM; addr < USER_STACK_TOP; addr += PAGE_SIZE) {
        /* Allocate physical page */
        uint32_t phys = pmm_alloc_page();
        if (!phys) return -1;
        
        /* Map with USER access */
        vmm_map_page(proc->page_directory, addr, phys, 
                     PAGE_PRESENT | PAGE_RW | PAGE_USER);
    }
    
    proc->user_stack = USER_STACK_TOP;
    
    return 0;
}

/*
 * Jump to user mode
 * 
 * This is the magic transition from Ring 0 to Ring 3.
 * We use IRET which pops: EIP, CS, EFLAGS, ESP, SS
 * By setting up the stack correctly, we "return" to user code.
 */
void enter_user_mode(uint32_t entry_point, uint32_t user_stack) {
    /* Update TSS with kernel stack for this process */
    tss_set_kernel_stack(current_process->kernel_stack);
    
    /*
     * Critical: Set up data segments BEFORE iret
     * After iret, we'll be in Ring 3 and can't access Ring 0 segments
     */
    asm volatile(
        "cli\n"                    // Disable interrupts during transition
        
        /* Load user data segment into DS, ES, FS, GS */
        "mov $0x23, %%ax\n"        // USER_DATA_SELECTOR (0x20 | RPL 3)
        "mov %%ax, %%ds\n"
        "mov %%ax, %%es\n"
        "mov %%ax, %%fs\n"
        "mov %%ax, %%gs\n"
        
        /* Build IRET stack frame */
        "push $0x23\n"             // User SS (data segment)
        "push %0\n"                // User ESP (stack pointer)
        
        /* Push EFLAGS with IF (interrupt flag) set */
        "pushf\n"                  // Push current flags
        "pop %%eax\n"              // Get into EAX
        "or $0x200, %%eax\n"       // Set IF bit (enable interrupts)
        "push %%eax\n"             // Push modified flags
        
        "push $0x1B\n"             // User CS (code segment)
        "push %1\n"                // User EIP (entry point)
        
        /* IRET pops: EIP, CS, EFLAGS, ESP, SS */
        "iret\n"
        :
        : "r"(user_stack), "r"(entry_point)
        : "eax", "memory"
    );
    
    /* Should never reach here */
    __builtin_unreachable();
}
</code></pre>
                    
                    <div class="highlight-box">
                        <i class="fas fa-lightbulb me-2"></i>
                        <strong>The IRET Trick:</strong> IRET (Interrupt Return) is normally used to return from an ISR to the interrupted code. But we can use it to "return" to code that was never interrupted - our user program! We just set up the stack as if an interrupt had occurred.
                    </div>

                    <h4>Address Space Layout</h4>

<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│              USER PROCESS ADDRESS SPACE                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  0xFFFFFFFF ┌──────────────────────────────────────────────┐    │
│             │            KERNEL SPACE                       │    │
│             │    (Mapped but NOT accessible from Ring 3)   │    │
│             │    Page table entries: no USER flag          │    │
│  0xC0000000 ├──────────────────────────────────────────────┤    │
│             │                                              │    │
│             │     (Unmapped - will fault if accessed)      │    │
│             │                                              │    │
│  0x7FFFFFFF ├──────────────────────────────────────────────┤    │
│             │            USER STACK                        │    │
│             │         ↓ grows downward                     │    │
│  0x7FFF0000 │            (64KB)                            │    │
│             ├──────────────────────────────────────────────┤    │
│             │                                              │    │
│             │     (Available for memory mapping)           │    │
│             │                                              │    │
│  0x10000000 ├──────────────────────────────────────────────┤    │
│             │            USER HEAP                         │    │
│             │         ↑ grows upward                       │    │
│             │        (dynamic, via sbrk)                   │    │
│             ├──────────────────────────────────────────────┤    │
│             │            USER BSS                          │    │
│             │      (Uninitialized global data)             │    │
│             ├──────────────────────────────────────────────┤    │
│             │            USER DATA                         │    │
│             │      (Initialized global data)               │    │
│             ├──────────────────────────────────────────────┤    │
│  0x08000000 │            USER TEXT                         │    │
│             │      (Code - executable, read-only)          │    │
│             │         ← Entry point here                  │    │
│             ├──────────────────────────────────────────────┤    │
│  0x00001000 │     (Reserved - catches NULL pointers)       │    │
│  0x00000000 └──────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
                    
                    <h3 id="first-process">First User Process</h3>
                    
                    <p>Let's put it all together and launch our first user-mode process:</p>

                    <pre><code class="language-c">/* init.c - Create and run the first user process */

#include "process.h"
#include "vmm.h"
#include "elf.h"  // We'll implement this in Phase 9

/*
 * For now, we'll embed a simple test program directly in memory.
 * In Phase 9, we'll load proper ELF executables from disk.
 */

/* Simple user program bytecode (assembled) */
static uint8_t user_program[] = {
    /* _start: */
    /* mov eax, 8         ; SYS_GETPID */
    0xB8, 0x08, 0x00, 0x00, 0x00,
    /* int 0x80           ; syscall */
    0xCD, 0x80,
    
    /* ; Print "Hello!\n" */
    /* mov eax, 3         ; SYS_WRITE */
    0xB8, 0x03, 0x00, 0x00, 0x00,
    /* mov ebx, 1         ; fd = stdout */
    0xBB, 0x01, 0x00, 0x00, 0x00,
    /* mov ecx, msg       ; buffer (we'll patch this) */
    0xB9, 0x30, 0x00, 0x00, 0x08,  // 0x08000030
    /* mov edx, 7         ; length */
    0xBA, 0x07, 0x00, 0x00, 0x00,
    /* int 0x80 */
    0xCD, 0x80,
    
    /* ; exit(0) */
    /* mov eax, 0         ; SYS_EXIT */
    0xB8, 0x00, 0x00, 0x00, 0x00,
    /* xor ebx, ebx       ; status = 0 */
    0x31, 0xDB,
    /* int 0x80 */
    0xCD, 0x80,
    
    /* ; loop forever (should never reach) */
    /* jmp $ */
    0xEB, 0xFE,
    
    /* msg: "Hello!\n" (at offset 0x30) */
    /* padding to align */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x21, 0x0A, 0x00  // "Hello!\n\0"
};

/* Create the init process (PID 1) */
void create_init_process(void) {
    /* Create process structure */
    pcb_t* init = (pcb_t*)kmalloc(sizeof(pcb_t));
    memset(init, 0, sizeof(pcb_t));
    
    init->pid = 1;
    init->parent_pid = 0;  // No parent (we are the first!)
    strcpy(init->name, "init");
    init->priority = 1;
    
    /* Set up address space */
    if (setup_user_space(init) < 0) {
        kprintf("Failed to create address space for init!\n");
        return;
    }
    
    /* Copy user program to user address space */
    uint32_t user_entry = USER_CODE_START;  // 0x08000000
    
    /* Map code pages */
    uint32_t code_pages = (sizeof(user_program) + PAGE_SIZE - 1) / PAGE_SIZE;
    for (uint32_t i = 0; i < code_pages; i++) {
        uint32_t virt = user_entry + i * PAGE_SIZE;
        uint32_t phys = pmm_alloc_page();
        vmm_map_page(init->page_directory, virt, phys, 
                     PAGE_PRESENT | PAGE_USER);  // Read-only for code
    }
    
    /* Switch to init's address space temporarily to copy code */
    uint32_t old_cr3;
    asm volatile("mov %%cr3, %0" : "=r"(old_cr3));
    asm volatile("mov %0, %%cr3" : : "r"(init->page_directory));
    
    memcpy((void*)user_entry, user_program, sizeof(user_program));
    
    /* Switch back */
    asm volatile("mov %0, %%cr3" : : "r"(old_cr3));
    
    /* Allocate kernel stack */
    init->kernel_stack = (uint32_t)kmalloc(4096) + 4096;
    
    /* Mark as ready */
    init->state = PROCESS_STATE_READY;
    
    /* Add to scheduler */
    current_process = init;
    ready_queue = init;
    init->next = init;
    init->prev = init;
    
    kprintf("Created init process (PID %d)\n", init->pid);
    
    /* Jump to user mode! */
    kprintf("Entering user mode...\n");
    enter_user_mode(user_entry, init->user_stack);
}

/* Kernel entry point modification */
void kernel_main(void) {
    /* ... previous initialization ... */
    
    kprintf("Initializing TSS...\n");
    tss_init(get_stack_top());
    
    kprintf("Initializing syscalls...\n");
    syscall_init();
    
    kprintf("Creating init process...\n");
    create_init_process();
    
    /* Should never reach here if init runs correctly */
    kprintf("Init process returned? This shouldn't happen!\n");
    while (1) { asm volatile("hlt"); }
}
</code></pre>

                    <div class="experiment-card">
                        <h4><i class="fas fa-check-double me-2"></i>Verification Checklist</h4>
                        <div class="content">
                            <p>When your first user process runs successfully, you should see:</p>
                            <ol>
                                <li>✅ "Entering user mode..." message from kernel</li>
                                <li>✅ "Hello!" (or similar) printed via syscall</li>
                                <li>✅ Process exits cleanly (returns to scheduler)</li>
                                <li>✅ No General Protection Fault (#GP)</li>
                                <li>✅ No Page Fault (#PF) from invalid access</li>
                            </ol>
                            <p class="mt-3"><strong>Common Issues:</strong></p>
                            <ul>
                                <li><strong>Triple Fault:</strong> TSS not set up correctly, or no kernel stack on interrupt</li>
                                <li><strong>#GP:</strong> Segment selectors wrong, or trying to access Ring 0 from Ring 3</li>
                                <li><strong>#PF:</strong> User pages not mapped with USER flag</li>
                                <li><strong>Hangs:</strong> Interrupts disabled (forgot to set IF in EFLAGS)</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- What You Can Build Section -->
                <div id="build" class="blog-content mt-5">
                    <h2><i class="fas fa-hammer me-2 text-teal"></i>What You Can Build</h2>
                    
                    <div class="highlight-box">
                        <i class="fas fa-rocket me-2"></i>
                        <strong>Phase 8 Achievement:</strong> A multitasking kernel! Your OS can now run multiple processes, switch between them, handle system calls, and execute user programs with proper privilege separation. This is a real operating system!
                    </div>
                    
                    <h3>Demonstration: Multitasking Demo</h3>
                    
                    <p>Create multiple processes that run "simultaneously" and display their activity:</p>
                    
                    <pre><code class="language-c">/* demo_multitask.c - Demonstrate multitasking */

#include "process.h"
#include "terminal.h"

/* Task A: Prints 'A' periodically */
void task_a(void) {
    while (1) {
        terminal_putchar('A');
        /* Simple delay */
        for (volatile int i = 0; i < 1000000; i++);
    }
}

/* Task B: Prints 'B' periodically */
void task_b(void) {
    while (1) {
        terminal_putchar('B');
        for (volatile int i = 0; i < 1000000; i++);
    }
}

/* Task C: Counts and prints numbers */
void task_c(void) {
    int count = 0;
    while (1) {
        kprintf("%d ", count++);
        for (volatile int i = 0; i < 2000000; i++);
    }
}

void demo_multitasking(void) {
    kprintf("\n=== MULTITASKING DEMONSTRATION ===\n");
    kprintf("Watch A, B, and numbers interleave:\n\n");
    
    /* Create three tasks */
    process_create("task_a", task_a, 1);
    process_create("task_b", task_b, 1);
    process_create("task_c", task_c, 1);
    
    /* Enable timer interrupts to trigger scheduling */
    asm volatile("sti");
    
    /* The kernel becomes the idle task */
    while (1) {
        asm volatile("hlt");  // Sleep until next interrupt
    }
}

/* 
 * Expected Output (interleaved):
 * === MULTITASKING DEMONSTRATION ===
 * Watch A, B, and numbers interleave:
 * 
 * AABB0 1 ABAB2 3 BABA4 5 ABBA6 7 ...
 */
</code></pre>

                    <h3>Process List Command</h3>
                    
                    <pre><code class="language-c">/* cmd_ps.c - Display running processes */

void cmd_ps(void) {
    kprintf("\n");
    kprintf("PID   STATE     PRIORITY  NAME\n");
    kprintf("───── ───────── ──────── ────────────────\n");
    
    pcb_t* proc = ready_queue;
    if (!proc) {
        kprintf("No processes!\n");
        return;
    }
    
    /* Traverse circular list */
    do {
        const char* state_str;
        switch (proc->state) {
            case PROCESS_STATE_RUNNING:
                state_str = "RUNNING  ";
                break;
            case PROCESS_STATE_READY:
                state_str = "READY    ";
                break;
            case PROCESS_STATE_BLOCKED:
                state_str = "BLOCKED  ";
                break;
            case PROCESS_STATE_TERMINATED:
                state_str = "ZOMBIE   ";
                break;
            default:
                state_str = "UNKNOWN  ";
        }
        
        kprintf("%5d %s %8d  %s%s\n",
                proc->pid,
                state_str,
                proc->priority,
                proc->name,
                (proc == current_process) ? " *" : "");
        
        proc = proc->next;
    } while (proc != ready_queue);
    
    kprintf("\n* = currently running\n");
}

/*
 * Sample output:
 * 
 * PID   STATE     PRIORITY  NAME
 * ───── ───────── ──────── ────────────────
 *     1 RUNNING          1  init *
 *     2 READY            1  task_a
 *     3 READY            1  task_b
 *     4 BLOCKED          1  waiting_io
 * 
 * * = currently running
 */
</code></pre>

                    <h3>Kill Command</h3>
                    
                    <pre><code class="language-c">/* cmd_kill.c - Terminate a process */

void cmd_kill(int pid) {
    if (pid <= 0) {
        kprintf("Usage: kill &lt;pid&gt;\n");
        return;
    }
    
    /* Find process by PID */
    pcb_t* proc = ready_queue;
    do {
        if (proc->pid == pid) {
            if (proc == current_process) {
                kprintf("Cannot kill running process from itself!\n");
                return;
            }
            
            kprintf("Killing process %d (%s)...\n", pid, proc->name);
            
            proc->state = PROCESS_STATE_TERMINATED;
            proc->exit_code = -9;  // SIGKILL
            
            process_destroy(proc);
            kprintf("Process %d terminated.\n", pid);
            return;
        }
        proc = proc->next;
    } while (proc != ready_queue);
    
    kprintf("Process %d not found.\n", pid);
}
</code></pre>

                    <h3>Exercises</h3>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-dumbbell me-2"></i>Exercise 1: Priority Scheduler</h4>
                        <div class="content">
                            <p>Modify the round-robin scheduler to use priorities. Higher priority processes should get more CPU time or run before lower priority ones.</p>
                            <pre><code class="language-c">/* Hint: Simple priority scheduling */
void schedule_priority(void) {
    pcb_t* highest = NULL;
    pcb_t* proc = ready_queue;
    
    /* Find highest priority READY process */
    do {
        if (proc->state == PROCESS_STATE_READY) {
            if (!highest || proc->priority > highest->priority) {
                highest = proc;
            }
        }
        proc = proc->next;
    } while (proc != ready_queue);
    
    if (highest) {
        /* Switch to it */
        // TODO: Implement the switch
    }
}

/* Challenge: Prevent starvation - low priority processes
 * must eventually run. Consider "aging" priorities. */</code></pre>
                        </div>
                        <div class="tags">
                            <span class="badge bg-crimson">Intermediate</span>
                            <span class="badge bg-teal">Scheduler</span>
                        </div>
                    </div>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-dumbbell me-2"></i>Exercise 2: Implement fork()</h4>
                        <div class="content">
                            <p>Implement the <code>fork()</code> system call that creates a copy of the current process. The child process should be an exact duplicate but with a new PID.</p>
                            <pre><code class="language-c">/* Hint: fork() implementation skeleton */
int sys_fork(registers_t* regs) {
    /* 1. Create new PCB */
    pcb_t* child = kmalloc(sizeof(pcb_t));
    memcpy(child, current_process, sizeof(pcb_t));
    child->pid = next_pid++;
    child->parent_pid = current_process->pid;
    
    /* 2. Clone address space (copy-on-write is advanced) */
    child->page_directory = clone_address_space(
        current_process->page_directory
    );
    
    /* 3. Create new kernel stack */
    child->kernel_stack = (uint32_t)kmalloc(4096) + 4096;
    
    /* 4. Copy current interrupt frame to child's stack */
    // The tricky part: child returns 0, parent returns child PID
    
    /* 5. Add child to scheduler */
    // ...
    
    /* Return child PID to parent */
    return child->pid;
}</code></pre>
                            <p class="mt-2"><strong>Key insight:</strong> The child's register state (including EAX=0) must be set up so that when it's scheduled, it "returns" from fork() with 0.</p>
                        </div>
                        <div class="tags">
                            <span class="badge bg-crimson">Advanced</span>
                            <span class="badge bg-teal">Process Creation</span>
                        </div>
                    </div>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-dumbbell me-2"></i>Exercise 3: Implement wait()</h4>
                        <div class="content">
                            <p>Implement <code>waitpid()</code> so a parent process can wait for a child to exit and retrieve its exit status.</p>
                            <pre><code class="language-c">/* Hint: waitpid() blocks parent until child exits */
int sys_waitpid(int pid, int* status, int options) {
    /* Find the child process */
    pcb_t* child = find_process(pid);
    if (!child || child->parent_pid != current_process->pid) {
        return -EINVAL;  // Not our child
    }
    
    /* If child already terminated, return immediately */
    if (child->state == PROCESS_STATE_TERMINATED) {
        if (status) {
            // Copy exit code to user space (validate pointer!)
            *status = child->exit_code;
        }
        process_destroy(child);  // Clean up zombie
        return pid;
    }
    
    /* Otherwise, block until child exits */
    current_process->state = PROCESS_STATE_BLOCKED;
    current_process->waiting_for = pid;  // Add this field to PCB
    schedule();
    
    /* When we wake up, child has exited */
    // ... retrieve status and clean up
}</code></pre>
                        </div>
                        <div class="tags">
                            <span class="badge bg-crimson">Advanced</span>
                            <span class="badge bg-teal">IPC</span>
                        </div>
                    </div>
                    
                    <div class="experiment-card">
                        <h4><i class="fas fa-dumbbell me-2"></i>Exercise 4: User-Mode Shell</h4>
                        <div class="content">
                            <p>Create a simple shell that runs entirely in user mode, using only system calls to interact with the kernel.</p>
                            <pre><code class="language-c">/* user/shell.c - Minimal user-mode shell */

void _start(void) {
    char buf[256];
    int len;
    
    while (1) {
        /* Print prompt */
        write(1, "$ ", 2);
        
        /* Read command */
        len = read(0, buf, sizeof(buf) - 1);
        if (len <= 0) continue;
        buf[len] = '\0';
        
        /* Simple command parsing */
        if (strncmp(buf, "exit", 4) == 0) {
            exit(0);
        }
        else if (strncmp(buf, "echo ", 5) == 0) {
            write(1, buf + 5, len - 5);
            write(1, "\n", 1);
        }
        else if (strncmp(buf, "ps", 2) == 0) {
            /* Need a syscall for this! */
            syscall0(SYS_PS);
        }
        else {
            write(1, "Unknown command\n", 16);
        }
    }
}</code></pre>
                            <p class="mt-2"><strong>Challenge:</strong> Implement <code>exec()</code> syscall to run actual programs!</p>
                        </div>
                        <div class="tags">
                            <span class="badge bg-crimson">Advanced</span>
                            <span class="badge bg-teal">User Space</span>
                        </div>
                    </div>
                </div>

                <!-- Next Steps Section -->
                <div id="next-steps" class="blog-content mt-5">
                    <h2><i class="fas fa-arrow-right me-2 text-teal"></i>Next Steps</h2>
                    
                    <p>Congratulations! You now have a <strong>true multitasking operating system</strong>. Processes can run in isolation, communicate with the kernel via system calls, and share the CPU fairly. But there's one big limitation: we're embedding programs directly in kernel code.</p>
                    
                    <p>In <strong>Phase 9: ELF Loading & Executables</strong>, we'll learn to load real compiled programs from disk:</p>
                    
<pre><code class="language-bash">┌─────────────────────────────────────────────────────────────────┐
│                 PHASE 9 PREVIEW: ELF LOADING                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Compiled Program (on disk)         Loaded in Memory           │
│   ┌────────────────────────┐        ┌─────────────────────┐     │
│   │     ELF Header         │        │                     │     │
│   │  ┌──────────────────┐  │        │  User Address Space │     │
│   │  │ e_ident (magic)  │  │        │                     │     │
│   │  │ e_type (EXEC)    │  │        │  ┌───────────────┐  │     │
│   │  │ e_machine (386)  │  │──────▶│  │ .text (code)  │  │     │
│   │  │ e_entry (start)  │  │        │  │  @ 0x08000000 │  │     │
│   │  └──────────────────┘  │        │  └───────────────┘  │     │
│   │                        │        │  ┌───────────────┐  │     │
│   │  Program Headers       │        │  │ .data         │  │     │
│   │  ┌──────────────────┐  │        │  │ .bss          │  │     │
│   │  │ PT_LOAD (text)   │  │──────▶│  │  @ 0x08100000 │  │     │
│   │  │ PT_LOAD (data)   │  │        │  └───────────────┘  │     │
│   │  │ PT_INTERP (ld)   │  │        │                     │     │
│   │  └──────────────────┘  │        │  ┌───────────────┐  │     │
│   │                        │        │  │ Stack         │  │     │
│   │  Section Data          │        │  │  @ 0x7FFF0000 │  │     │
│   │  ┌──────────────────┐  │        │  └───────────────┘  │     │
│   │  │ .text bytes...   │  │        │                     │     │
│   │  │ .data bytes...   │  │        │  Jump to e_entry!   │     │
│   │  │ .rodata bytes... │  │        └─────────────────────┘     │
│   │  └──────────────────┘  │                                    │
│   └────────────────────────┘                                    │
│                                                                  │
│   You'll be able to:                                            │
│   • Parse ELF headers and program headers                       │
│   • Allocate and map memory segments                            │
│   • Load code and data from file                                │
│   • Run real compiled C programs!                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
                    
                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-bookmark me-2"></i>
                        <strong>Phase 8 Key Takeaways:</strong>
                        <ul class="mb-0 mt-2">
                            <li><strong>Processes</strong> are programs in execution with their own memory space and CPU context</li>
                            <li><strong>TSS</strong> provides the kernel stack pointer for Ring 3 → Ring 0 transitions</li>
                            <li><strong>Context switching</strong> saves/restores CPU state to create multitasking illusion</li>
                            <li><strong>System calls</strong> (int 0x80) are the secure gateway between user and kernel mode</li>
                            <li><strong>Ring 3</strong> (user mode) runs with limited privileges for memory protection</li>
                            <li><strong>IRET</strong> is used to "return" to user mode, even for the first time</li>
                        </ul>
                    </div>
                    
                    <p class="mt-4">With processes and user mode complete, you have a foundation for a real operating system. Users can run multiple programs safely isolated from each other and from the kernel. Next, we'll add the ability to load and run actual executable files!</p>

                    <!-- Related Posts -->
                    <div class="related-posts">
                        <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                        <div class="related-post-item">
                            <h5 class="mb-2">Phase 7: Disk Access & Filesystems</h5>
                            <p class="text-muted small mb-2">Review ATA drivers, FAT filesystem, and VFS abstraction.</p>
                            <a href="kernel-dev-phase-07-filesystem.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5 class="mb-2">Phase 9: ELF Loading & Executables</h5>
                            <p class="text-muted small mb-2">Parse ELF files and load executable programs into memory.</p>
                            <a href="kernel-dev-phase-09-elf.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5 class="mb-2">Phase 10: Standard Library & Shell</h5>
                            <p class="text-muted small mb-2">Build a C standard library and command-line shell.</p>
                            <a href="kernel-dev-phase-10-stdlib-shell.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">
                        I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.
                    </p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook">
                            <i class="fab fa-facebook-f"></i>
                        </a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube">
                            <i class="fab fa-youtube"></i>
                        </a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram">
                            <i class="fab fa-instagram"></i>
                        </a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest">
                            <i class="fab fa-pinterest-p"></i>
                        </a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email">
                            <i class="fas fa-envelope"></i>
                        </a>
                    </div>
                </div>
            </div>

            <hr class="bg-secondary">

            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small">
                        <i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a>
                    </p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">
                        Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!
                    </p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Scroll-to-Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top">
        <i class="fas fa-arrow-up"></i>
    </button>
    <!-- Category Indicator -->
    <div id="categoryIndicator" class="category-indicator" title="Current Section">
        <i class="fas fa-tag"></i><span id="categoryText">Technology</span>
    </div>
    
    <!-- Cookie Consent JS -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>

    <!-- Prism.js Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-nasm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
</body>
</html>
