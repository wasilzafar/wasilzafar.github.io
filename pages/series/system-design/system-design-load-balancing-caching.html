<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Master load balancing algorithms and caching strategies for high-performance systems. Learn about round-robin, least connections, Redis, Memcached, and CDN implementation." />
    <meta name="author" content="Wasil Zafar" />
    <meta name="keywords" content="Load Balancing, Caching, CDN, Redis, Memcached, System Design, Round Robin, Least Connections, Performance Optimization" />
    <meta property="og:title" content="System Design Series Part 3: Load Balancing & Caching" />
    <meta property="og:description" content="Master load balancing algorithms and caching strategies for high-performance distributed systems." />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2026-01-25" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />
    
    <title>System Design Series Part 3: Load Balancing & Caching - Wasil Zafar</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', { 'ad_storage': 'denied', 'ad_user_data': 'denied', 'ad_personalization': 'denied', 'analytics_storage': 'denied', 'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE'] });
        gtag('consent', 'default', { 'ad_storage': 'granted', 'ad_user_data': 'granted', 'ad_personalization': 'granted', 'analytics_storage': 'granted' });
        gtag('set', 'url_passthrough', true);
    </script>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-PBS8M2JR');</script>

    <style>
        .blog-hero { background: linear-gradient(135deg, var(--color-navy) 0%, var(--color-blue) 100%); color: white; padding: 80px 0; }
        .blog-header { margin-bottom: 2rem; }
        .blog-meta { font-size: 0.95rem; color: var(--color-teal); margin-bottom: 1rem; display: flex; align-items: center; flex-wrap: wrap; gap: 1rem; }
        .print-btn { background: var(--color-teal); color: white; border: none; padding: 0.4rem 1rem; border-radius: 4px; font-size: 0.9rem; cursor: pointer; transition: all 0.3s ease; display: inline-flex; align-items: center; gap: 0.5rem; }
        .print-btn:hover { background: var(--color-crimson); }
        @media print { .print-btn, nav, .navbar, footer, .back-link, .related-posts, .scroll-to-top, .toc-toggle-btn, .sidenav-toc, .sidenav-overlay { display: none !important; } }
        .blog-content { max-width: 900px; margin: 0 auto; font-size: 1.05rem; line-height: 1.8; color: #333; }
        .blog-content h2 { font-size: 1.8rem; font-weight: 700; margin-top: 2.5rem; margin-bottom: 1.5rem; color: var(--color-navy); border-bottom: 3px solid var(--color-teal); padding-bottom: 0.5rem; }
        .blog-content h3 { font-size: 1.3rem; font-weight: 600; margin-top: 2rem; margin-bottom: 1rem; color: var(--color-blue); }
        .blog-content p { margin-bottom: 1.2rem; text-align: justify; }
        .blog-content strong { color: var(--color-crimson); }
        .highlight-box { background: rgba(59, 151, 151, 0.1); border-left: 4px solid var(--color-teal); padding: 1.5rem; margin: 2rem 0; border-radius: 4px; }
        .experiment-card { background: #f8f9fa; border: 1px solid #ddd; border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; transition: all 0.3s ease; }
        .experiment-card:hover { box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); transform: translateY(-2px); }
        .experiment-card h4 { color: var(--color-crimson); font-weight: 700; }
        .bg-teal { background-color: var(--color-teal) !important; }
        pre[class*="language-"] { margin: 1.5rem 0; padding-top: 3rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); }
        .toc-toggle-btn { position: fixed; bottom: 2rem; left: 2rem; width: 50px; height: 50px; background: var(--color-teal); color: white; border: none; border-radius: 50%; font-size: 1.2rem; cursor: pointer; box-shadow: 0 4px 12px rgba(59, 151, 151, 0.4); transition: all 0.3s ease; z-index: 1049; display: flex; align-items: center; justify-content: center; }
        .toc-toggle-btn:hover { background: var(--color-crimson); transform: scale(1.1); }
        .sidenav-toc { height: calc(100% - 64px); width: 0; position: fixed; z-index: 1050; top: 64px; left: 0; background: linear-gradient(135deg, var(--color-navy) 0%, var(--color-blue) 100%); overflow-x: hidden; overflow-y: auto; transition: width 0.4s ease; padding-top: 30px; box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3); }
        .sidenav-toc.open { width: 350px; }
        .sidenav-toc .toc-header { display: flex; align-items: center; justify-content: space-between; padding: 20px 30px; margin-bottom: 20px; border-bottom: 2px solid var(--color-teal); opacity: 0; visibility: hidden; transition: all 0.3s ease; }
        .sidenav-toc.open .toc-header { opacity: 1; visibility: visible; }
        .sidenav-toc .closebtn { font-size: 32px; color: white; background: transparent; border: none; cursor: pointer; }
        .sidenav-toc .closebtn:hover { color: var(--color-crimson); transform: rotate(90deg); }
        .sidenav-toc h3 { color: white; margin: 0; font-weight: 700; font-size: 1.3rem; flex-grow: 1; }
        .sidenav-toc ol { list-style: decimal; padding-left: 30px; color: rgba(255, 255, 255, 0.9); }
        .sidenav-toc ol li { margin-bottom: 8px; }
        .sidenav-toc ul { list-style-type: lower-alpha; padding-left: 30px; margin-top: 8px; }
        .sidenav-toc a { padding: 12px 30px; text-decoration: none; font-size: 0.95rem; color: rgba(255, 255, 255, 0.85); display: block; transition: all 0.3s ease; border-left: 4px solid transparent; }
        .sidenav-toc a:hover { color: white; background: rgba(59, 151, 151, 0.2); border-left-color: var(--color-teal); padding-left: 35px; }
        .sidenav-toc a.active { color: white; background: rgba(191, 9, 47, 0.3); border-left-color: var(--color-crimson); font-weight: 600; }
        .sidenav-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 1049; }
        .sidenav-overlay.show { display: block; }
        @media (max-width: 768px) { .sidenav-toc.open { width: 280px; } .toc-toggle-btn { width: 45px; height: 45px; left: 1rem; bottom: 1rem; } }
        html { scroll-behavior: smooth; }
        .reading-time { display: inline-block; background: var(--color-crimson); color: white; padding: 0.3rem 0.8rem; border-radius: 4px; font-size: 0.9rem; }
        .back-link { display: inline-block; color: white; text-decoration: none; transition: all 0.3s ease; margin-bottom: 1rem; opacity: 0.9; }
        .back-link:hover { color: var(--color-teal); opacity: 1; transform: translateX(-5px); }
        .related-posts { background: #f8f9fa; border-radius: 8px; padding: 2rem; margin-top: 3rem; }
        .related-posts h3 { color: var(--color-navy); margin-bottom: 1.5rem; }
        .related-post-item { padding: 1rem; border-left: 3px solid var(--color-teal); margin-bottom: 1rem; }
        .related-post-item:hover { background: white; border-left-color: var(--color-crimson); }
        .related-post-item a { color: var(--color-blue); text-decoration: none; font-weight: 600; }
        .scroll-to-top { position: fixed; bottom: 2rem; right: 2rem; width: 50px; height: 50px; background: var(--color-teal); color: white; border: none; border-radius: 50%; font-size: 1.2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; opacity: 0; visibility: hidden; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(59, 151, 151, 0.3); z-index: 999; }
        .scroll-to-top.show { opacity: 1; visibility: visible; }
        .scroll-to-top:hover { background: var(--color-crimson); transform: translateY(-3px); }
        /* Category Indicator */
        .category-indicator {
            position: fixed;
            bottom: 2rem;
            right: 6.5rem;
            background: var(--color-navy);
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 600;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(19, 36, 64, 0.3);
            z-index: 998;
            max-width: 150px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .category-indicator.show {
            opacity: 1;
            visibility: visible;
        }

        .category-indicator i {
            margin-right: 0.5rem;
            color: var(--color-teal);
        }

        @media (max-width: 768px) {
            .category-indicator {
                display: none;
            }
        }
    </style>
</head>
<body>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <div id="cookieBanner" class="light display-bottom" style="display: none;">
        <div class="content-wrap">
            <div class="msg-wrap"><p style="font-size: 14px; color: var(--color-navy);">We use cookies. See our <a href="/privacy-policy.html" style="color: var(--color-teal);">Privacy Policy</a>.</p></div>
            <div class="btn-wrap">
                <button id="cookieAccept" style="background: var(--color-teal); color: white;">Accept All</button>
                <button id="cookieReject" style="background: transparent; color: var(--color-navy); border: 2px solid var(--color-teal);">Reject All</button>
            </div>
        </div>
    </div>

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
                <h1 class="display-4 fw-bold mb-3">System Design Series Part 3: Load Balancing & Caching</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>January 25, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>35 min read</span>
                    <button onclick="window.print()" class="print-btn"><i class="fas fa-print"></i> Print</button>
                </div>
                <p class="lead">Master load balancing algorithms and caching strategies for building high-performance distributed systems. Learn round-robin, least connections, Redis, Memcached, and CDN implementation patterns.</p>
            </div>
        </div>
    </section>

    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents"><i class="fas fa-list"></i></button>

    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()">&times;</button>
        </div>
        <ol>
            <li><a href="#load-balancing" onclick="closeNav()">Load Balancing</a>
                <ul>
                    <li><a href="#load-balancing" onclick="closeNav()">Introduction</a></li>
                    <li><a href="#algorithms" onclick="closeNav()">Load Balancing Algorithms</a></li>
                    <li><a href="#health-checks" onclick="closeNav()">Health Checks</a></li>
                </ul>
            </li>
            <li><a href="#caching" onclick="closeNav()">Caching Strategies</a>
                <ul>
                    <li><a href="#caching" onclick="closeNav()">Why Caching?</a></li>
                    <li><a href="#cache-patterns" onclick="closeNav()">Cache Patterns</a></li>
                    <li><a href="#redis" onclick="closeNav()">Redis & Memcached</a></li>
                </ul>
            </li>
            <li><a href="#cdn" onclick="closeNav()">Content Delivery Networks</a>
                <ul>
                    <li><a href="#cdn" onclick="closeNav()">CDN Fundamentals</a></li>
                    <li><a href="#next-steps" onclick="closeNav()">Next Steps</a></li>
                </ul>
            </li>
        </ol>
    </div>

    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <div id="load-balancing" class="blog-content">
                    <h2><i class="fas fa-balance-scale me-2 text-teal"></i>Load Balancing</h2>
                    
                    <div class="highlight-box" style="background: rgba(191, 9, 47, 0.1); border-left-color: var(--color-crimson);">
                        <i class="fas fa-book me-2"></i>
                        <strong>Series Navigation:</strong> This is Part 3 of the 15-part System Design Series. <a href="system-design-scalability-fundamentals.html">Review Part 2: Scalability</a> first.
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">15-Part Series</span>
                            <span class="badge bg-crimson">System Design Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="system-design-introduction.html">Introduction to System Design</a> - Fundamentals, why it matters, key concepts</li>
                                <li><a href="system-design-scalability-fundamentals.html">Scalability Fundamentals</a> - Horizontal vs vertical scaling, stateless design</li>
                                <li><strong>Load Balancing & Caching (This Guide)</strong> - Algorithms, Redis, CDN patterns</li>
                                <li><a href="system-design-database-sharding.html">Database Design & Sharding</a> - SQL vs NoSQL, replication, partitioning</li>
                                <li><a href="system-design-microservices-architecture.html">Microservices Architecture</a> - Service decomposition, API gateways, sagas</li>
                                <li><a href="system-design-api-rest-graphql.html">API Design & REST/GraphQL</a> - RESTful principles, GraphQL, gRPC</li>
                                <li><a href="system-design-message-queues-event-driven.html">Message Queues & Event-Driven</a> - Kafka, RabbitMQ, event sourcing</li>
                                <li><a href="system-design-cap-theorem-consistency.html">CAP Theorem & Consistency</a> - Distributed trade-offs, eventual consistency</li>
                                <li><a href="system-design-rate-limiting-security.html">Rate Limiting & Security</a> - Throttling algorithms, DDoS protection</li>
                                <li><a href="system-design-monitoring-observability.html">Monitoring & Observability</a> - Logging, metrics, distributed tracing</li>
                                <li><a href="system-design-real-world-case-studies.html">Real-World Case Studies</a> - URL shortener, chat, feed, video streaming</li>
                                <li><a href="system-design-low-level-design-patterns.html">Low-Level Design Patterns</a> - SOLID, OOP patterns, data modeling</li>
                                <li><a href="system-design-distributed-systems-deep-dive.html">Distributed Systems Deep Dive</a> - Consensus, Paxos, Raft, coordination</li>
                                <li><a href="system-design-authentication-security.html">Authentication & Security</a> - OAuth, JWT, zero trust, compliance</li>
                                <li><a href="system-design-interview-preparation.html">Interview Preparation</a> - 4-step framework, estimation, strategies</li>
                            </ol>
                        </div>
                    </div>
                    
                    <p><strong>Load balancing</strong> is the process of distributing network traffic across multiple servers to ensure no single server bears too much demand. This improves responsiveness and availability of applications.</p>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb"></i>
                        <strong>Key Insight:</strong> A good load balancer is invisible to users—it seamlessly routes requests while handling server failures and traffic spikes.
                    </div>

                    <h3>Why Load Balancing Matters</h3>
                    <p>Without load balancing, a single server handles all incoming requests, creating a <strong>single point of failure</strong>. When traffic exceeds the server's capacity or the server fails, your entire application becomes unavailable.</p>
                    
                    <p>Load balancers solve this by:</p>
                    <ul>
                        <li><strong>Distributing traffic</strong> across multiple servers</li>
                        <li><strong>Detecting failures</strong> and routing around unhealthy servers</li>
                        <li><strong>Enabling scaling</strong> by adding/removing servers dynamically</li>
                        <li><strong>Improving performance</strong> through optimal server selection</li>
                        <li><strong>Providing SSL termination</strong> to offload encryption from backend servers</li>
                    </ul>

                    <h3>Types of Load Balancers</h3>
                    <p>Load balancers operate at different layers of the OSI model:</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-network-wired me-2"></i>Layer 4 (Transport Layer) Load Balancer</h4>
                        <div class="experiment-content">
                            <p>Operates at the TCP/UDP level. Routes traffic based on IP address and port number without inspecting packet contents.</p>
                            <ul>
                                <li><strong>Pros:</strong> Very fast, low latency, simple to configure</li>
                                <li><strong>Cons:</strong> No content-based routing, limited visibility</li>
                                <li><strong>Use cases:</strong> High-throughput applications, database connections</li>
                            </ul>
                        </div>
                        <div class="experiment-tags">
                            <span class="bias-tag">TCP/UDP</span>
                            <span class="bias-tag">Network</span>
                            <span class="bias-tag">High Performance</span>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-globe me-2"></i>Layer 7 (Application Layer) Load Balancer</h4>
                        <div class="experiment-content">
                            <p>Operates at the HTTP/HTTPS level. Can inspect request content and make intelligent routing decisions.</p>
                            <ul>
                                <li><strong>Pros:</strong> Content-based routing, SSL termination, request modification</li>
                                <li><strong>Cons:</strong> Higher latency, more resource-intensive</li>
                                <li><strong>Use cases:</strong> Web applications, API gateways, microservices</li>
                            </ul>
<pre><code class="language-yaml"># NGINX Layer 7 Load Balancer Configuration
upstream api_servers {
    server api1.example.com:8080;
    server api2.example.com:8080;
    server api3.example.com:8080;
}

upstream static_servers {
    server static1.example.com:80;
    server static2.example.com:80;
}

server {
    listen 443 ssl;
    server_name example.com;
    
    # Route API requests to API servers
    location /api/ {
        proxy_pass http://api_servers;
    }
    
    # Route static content to static servers
    location /static/ {
        proxy_pass http://static_servers;
    }
}</code></pre>
                        </div>
                        <div class="experiment-tags">
                            <span class="bias-tag">HTTP/HTTPS</span>
                            <span class="bias-tag">Content Routing</span>
                            <span class="bias-tag">SSL Termination</span>
                        </div>
                    </div>

                    <h3>Global vs. Local Load Balancing</h3>
                    <table class="table table-bordered">
                        <thead class="table-dark">
                            <tr>
                                <th>Feature</th>
                                <th>Local Load Balancing</th>
                                <th>Global Load Balancing (GSLB)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Scope</strong></td>
                                <td>Single data center</td>
                                <td>Multiple data centers/regions</td>
                            </tr>
                            <tr>
                                <td><strong>Routing Decision</strong></td>
                                <td>Server health, capacity</td>
                                <td>Geographic location, latency, availability</td>
                            </tr>
                            <tr>
                                <td><strong>Technology</strong></td>
                                <td>HAProxy, NGINX, AWS ALB</td>
                                <td>DNS-based, Cloudflare, AWS Route 53</td>
                            </tr>
                            <tr>
                                <td><strong>Failover</strong></td>
                                <td>Within data center</td>
                                <td>Across regions/continents</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div id="algorithms" class="blog-content mt-5">
                    <h3>Load Balancing Algorithms</h3>
                    <p>The choice of algorithm significantly impacts how traffic is distributed and overall system performance.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-sync me-2"></i>Round Robin</h4>
                        <div class="experiment-content">
                            <p>Distributes requests sequentially across servers in a circular manner. Simple and effective when all servers have equal capacity.</p>
<pre><code class="language-python"># Round Robin Implementation
class RoundRobinBalancer:
    def __init__(self, servers):
        self.servers = servers
        self.current_index = 0
    
    def get_server(self):
        server = self.servers[self.current_index]
        self.current_index = (self.current_index + 1) % len(self.servers)
        return server

# Usage
balancer = RoundRobinBalancer(['server1', 'server2', 'server3'])
for i in range(6):
    print(f"Request {i+1} -> {balancer.get_server()}")
# Output: server1, server2, server3, server1, server2, server3</code></pre>
                            <p><strong>Best for:</strong> Homogeneous server environments with similar capacity.</p>
                        </div>
                        <div class="experiment-tags">
                            <span class="bias-tag">Simple</span>
                            <span class="bias-tag">Equal Distribution</span>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-weight-hanging me-2"></i>Weighted Round Robin</h4>
                        <div class="experiment-content">
                            <p>Similar to round robin but assigns weights based on server capacity. Higher-capacity servers receive more requests.</p>
<pre><code class="language-python"># Weighted Round Robin Implementation
class WeightedRoundRobinBalancer:
    def __init__(self, servers_with_weights):
        # servers_with_weights: [('server1', 3), ('server2', 2), ('server3', 1)]
        self.servers = []
        for server, weight in servers_with_weights:
            self.servers.extend([server] * weight)
        self.current_index = 0
    
    def get_server(self):
        server = self.servers[self.current_index]
        self.current_index = (self.current_index + 1) % len(self.servers)
        return server

# Usage: server1 gets 3x traffic, server2 gets 2x, server3 gets 1x
balancer = WeightedRoundRobinBalancer([
    ('powerful-server', 5),
    ('medium-server', 3),
    ('small-server', 1)
])</code></pre>
                            <p><strong>Best for:</strong> Heterogeneous environments with varying server capacities.</p>
                        </div>
                        <div class="experiment-tags">
                            <span class="bias-tag">Capacity-Aware</span>
                            <span class="bias-tag">Weighted</span>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-chart-line me-2"></i>Least Connections</h4>
                        <div class="experiment-content">
                            <p>Routes new requests to the server with the fewest active connections. Ideal when request processing times vary significantly.</p>
<pre><code class="language-python"># Least Connections Implementation
import threading

class LeastConnectionsBalancer:
    def __init__(self, servers):
        self.servers = {server: 0 for server in servers}
        self.lock = threading.Lock()
    
    def get_server(self):
        with self.lock:
            # Find server with minimum connections
            server = min(self.servers, key=self.servers.get)
            self.servers[server] += 1
            return server
    
    def release_server(self, server):
        with self.lock:
            self.servers[server] = max(0, self.servers[server] - 1)

# Usage
balancer = LeastConnectionsBalancer(['server1', 'server2', 'server3'])
server = balancer.get_server()
# ... process request ...
balancer.release_server(server)</code></pre>
                            <p><strong>Best for:</strong> Variable request processing times, long-lived connections.</p>
                        </div>
                        <div class="experiment-tags">
                            <span class="bias-tag">Connection-Aware</span>
                            <span class="bias-tag">Dynamic</span>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-hashtag me-2"></i>IP Hash</h4>
                        <div class="experiment-content">
                            <p>Uses a hash of the client's IP address to determine which server receives the request. Ensures the same client always reaches the same server (session persistence).</p>
<pre><code class="language-python"># IP Hash Implementation
import hashlib

class IPHashBalancer:
    def __init__(self, servers):
        self.servers = servers
    
    def get_server(self, client_ip):
        # Create hash of client IP
        hash_value = int(hashlib.md5(client_ip.encode()).hexdigest(), 16)
        # Map to server index
        server_index = hash_value % len(self.servers)
        return self.servers[server_index]

# Usage
balancer = IPHashBalancer(['server1', 'server2', 'server3'])
print(balancer.get_server('192.168.1.100'))  # Always same server
print(balancer.get_server('10.0.0.50'))      # May be different server</code></pre>
                            <p><strong>Best for:</strong> Applications requiring session persistence without sticky sessions.</p>
                        </div>
                        <div class="experiment-tags">
                            <span class="bias-tag">Session Persistence</span>
                            <span class="bias-tag">Deterministic</span>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-circle me-2"></i>Consistent Hashing</h4>
                        <div class="experiment-content">
                            <p>Advanced hashing that minimizes redistribution when servers are added or removed. Essential for distributed caches.</p>
<pre><code class="language-python"># Consistent Hashing Implementation
import hashlib
from bisect import bisect_left

class ConsistentHashBalancer:
    def __init__(self, servers, virtual_nodes=100):
        self.ring = []
        self.server_map = {}
        
        for server in servers:
            for i in range(virtual_nodes):
                key = f"{server}:{i}"
                hash_val = self._hash(key)
                self.ring.append(hash_val)
                self.server_map[hash_val] = server
        
        self.ring.sort()
    
    def _hash(self, key):
        return int(hashlib.md5(key.encode()).hexdigest(), 16)
    
    def get_server(self, key):
        if not self.ring:
            return None
        
        hash_val = self._hash(key)
        idx = bisect_left(self.ring, hash_val) % len(self.ring)
        return self.server_map[self.ring[idx]]

# When a server is added/removed, only ~1/N keys are redistributed</code></pre>
                            <p><strong>Best for:</strong> Distributed caching, sharded databases, dynamic server pools.</p>
                        </div>
                        <div class="experiment-tags">
                            <span class="bias-tag">Distributed Systems</span>
                            <span class="bias-tag">Minimal Redistribution</span>
                        </div>
                    </div>

                    <h4>Algorithm Comparison</h4>
                    <table class="table table-bordered">
                        <thead class="table-dark">
                            <tr>
                                <th>Algorithm</th>
                                <th>Best For</th>
                                <th>Pros</th>
                                <th>Cons</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Round Robin</strong></td>
                                <td>Equal servers</td>
                                <td>Simple, predictable</td>
                                <td>Ignores server load</td>
                            </tr>
                            <tr>
                                <td><strong>Weighted Round Robin</strong></td>
                                <td>Mixed capacity</td>
                                <td>Capacity-aware</td>
                                <td>Static weights</td>
                            </tr>
                            <tr>
                                <td><strong>Least Connections</strong></td>
                                <td>Variable load</td>
                                <td>Adaptive</td>
                                <td>Overhead tracking</td>
                            </tr>
                            <tr>
                                <td><strong>IP Hash</strong></td>
                                <td>Session persistence</td>
                                <td>Consistent routing</td>
                                <td>Uneven distribution</td>
                            </tr>
                            <tr>
                                <td><strong>Consistent Hash</strong></td>
                                <td>Dynamic pools</td>
                                <td>Minimal redistribution</td>
                                <td>Complex implementation</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div id="health-checks" class="blog-content mt-5">
                    <h3>Health Checks</h3>
                    <p>Health checks ensure load balancers only route traffic to healthy servers. There are two main approaches:</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-heartbeat me-2"></i>Passive Health Checks</h4>
                        <div class="experiment-content">
                            <p>Monitor ongoing traffic to detect failures. If a server returns errors or times out, it's marked unhealthy.</p>
<pre><code class="language-yaml"># NGINX Passive Health Check
upstream backend {
    server backend1.example.com:8080 max_fails=3 fail_timeout=30s;
    server backend2.example.com:8080 max_fails=3 fail_timeout=30s;
}
# After 3 failures, server is marked down for 30 seconds</code></pre>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-stethoscope me-2"></i>Active Health Checks</h4>
                        <div class="experiment-content">
                            <p>Periodically probe servers with dedicated health endpoints to verify availability.</p>
<pre><code class="language-python"># Python Health Check Endpoint
from flask import Flask, jsonify
import psutil

app = Flask(__name__)

@app.route('/health')
def health_check():
    """Comprehensive health check endpoint"""
    health = {
        'status': 'healthy',
        'checks': {
            'cpu_percent': psutil.cpu_percent(),
            'memory_percent': psutil.virtual_memory().percent,
            'disk_percent': psutil.disk_usage('/').percent,
            'database': check_database_connection(),
            'cache': check_cache_connection()
        }
    }
    
    # Mark unhealthy if any resource is critical
    if (health['checks']['cpu_percent'] > 90 or
        health['checks']['memory_percent'] > 90):
        health['status'] = 'unhealthy'
        return jsonify(health), 503
    
    return jsonify(health), 200

def check_database_connection():
    try:
        # Attempt database query
        return 'connected'
    except Exception:
        return 'disconnected'

def check_cache_connection():
    try:
        # Attempt cache ping
        return 'connected'
    except Exception:
        return 'disconnected'</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb"></i>
                        <strong>Best Practice:</strong> Use both passive and active health checks. Active checks catch issues before traffic is affected; passive checks provide real-time failure detection.
                    </div>
                </div>

                <div id="caching" class="blog-content mt-5">
                    <h2><i class="fas fa-database me-2 text-teal"></i>Caching Strategies</h2>
                    <p><strong>Caching</strong> stores frequently accessed data in fast storage (memory) to reduce latency and database load. It's one of the most impactful optimizations in system design.</p>

                    <h3>Why Caching Matters</h3>
                    <p>Consider these typical latency numbers:</p>
                    <ul>
                        <li><strong>L1 cache reference:</strong> 0.5 ns</li>
                        <li><strong>L2 cache reference:</strong> 7 ns</li>
                        <li><strong>Main memory reference:</strong> 100 ns</li>
                        <li><strong>SSD read:</strong> 150,000 ns (150 µs)</li>
                        <li><strong>Network round trip:</strong> 500,000 ns (500 µs)</li>
                        <li><strong>Database query:</strong> 10,000,000 ns (10 ms)</li>
                    </ul>

                    <div class="highlight-box" style="background: rgba(191, 9, 47, 0.1); border-left-color: var(--color-crimson);">
                        <i class="fas fa-chart-bar"></i>
                        <strong>Impact Example:</strong> If 90% of requests are cache hits (100 µs) instead of database queries (10 ms), you've reduced average latency from 10 ms to 1.09 ms—a 9x improvement!
                    </div>

                    <h3>Cache Layers</h3>
                    <table class="table table-bordered">
                        <thead class="table-dark">
                            <tr>
                                <th>Layer</th>
                                <th>Location</th>
                                <th>Latency</th>
                                <th>Example</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Browser Cache</strong></td>
                                <td>Client</td>
                                <td>~1 ms</td>
                                <td>HTTP cache headers, localStorage</td>
                            </tr>
                            <tr>
                                <td><strong>CDN Cache</strong></td>
                                <td>Edge</td>
                                <td>~10-50 ms</td>
                                <td>Cloudflare, CloudFront</td>
                            </tr>
                            <tr>
                                <td><strong>Application Cache</strong></td>
                                <td>Server</td>
                                <td>~1-10 ms</td>
                                <td>Redis, Memcached</td>
                            </tr>
                            <tr>
                                <td><strong>Database Cache</strong></td>
                                <td>Database</td>
                                <td>~5-20 ms</td>
                                <td>MySQL query cache, PostgreSQL buffer</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div id="cache-patterns" class="blog-content mt-5">
                    <h3>Cache Patterns</h3>
                    <p>Different caching patterns serve different consistency and performance requirements.</p>

                    <div class="experiment-card">
                        <h4><i class="fas fa-arrow-right me-2"></i>Cache-Aside (Lazy Loading)</h4>
                        <div class="experiment-content">
                            <p>Application checks cache first; on miss, fetches from database and populates cache.</p>
<pre><code class="language-python"># Cache-Aside Pattern
import redis
import json

class CacheAsideService:
    def __init__(self):
        self.cache = redis.Redis(host='localhost', port=6379)
        self.cache_ttl = 3600  # 1 hour
    
    def get_user(self, user_id):
        cache_key = f"user:{user_id}"
        
        # 1. Check cache first
        cached = self.cache.get(cache_key)
        if cached:
            return json.loads(cached)
        
        # 2. Cache miss - fetch from database
        user = self.database.query(f"SELECT * FROM users WHERE id = {user_id}")
        
        # 3. Populate cache for next time
        self.cache.setex(cache_key, self.cache_ttl, json.dumps(user))
        
        return user
    
    def update_user(self, user_id, data):
        # Update database first
        self.database.update("users", user_id, data)
        
        # Invalidate cache (will be repopulated on next read)
        self.cache.delete(f"user:{user_id}")</code></pre>
                            <p><strong>Pros:</strong> Simple, only caches what's needed, resilient to cache failures<br>
                            <strong>Cons:</strong> Cache miss penalty, potential for stale data</p>
                        </div>
                        <div class="experiment-tags">
                            <span class="bias-tag">Most Common</span>
                            <span class="bias-tag">Read-Heavy</span>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-arrow-left me-2"></i>Write-Through</h4>
                        <div class="experiment-content">
                            <p>Data is written to cache and database simultaneously. Ensures cache is always consistent.</p>
<pre><code class="language-python"># Write-Through Pattern
class WriteThroughService:
    def __init__(self):
        self.cache = redis.Redis(host='localhost', port=6379)
    
    def save_user(self, user_id, data):
        cache_key = f"user:{user_id}"
        
        # Write to both cache and database atomically
        try:
            # Write to database
            self.database.insert_or_update("users", user_id, data)
            
            # Write to cache (only if DB write succeeds)
            self.cache.set(cache_key, json.dumps(data))
            
            return True
        except Exception as e:
            # If anything fails, invalidate cache
            self.cache.delete(cache_key)
            raise e
    
    def get_user(self, user_id):
        # Cache is always up-to-date
        cached = self.cache.get(f"user:{user_id}")
        if cached:
            return json.loads(cached)
        
        # Fallback to database (should rarely happen)
        return self.database.query(f"SELECT * FROM users WHERE id = {user_id}")</code></pre>
                            <p><strong>Pros:</strong> Strong consistency, no stale data<br>
                            <strong>Cons:</strong> Higher write latency, writes to cache even if data never read</p>
                        </div>
                        <div class="experiment-tags">
                            <span class="bias-tag">Consistency</span>
                            <span class="bias-tag">Write-Heavy</span>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-clock me-2"></i>Write-Behind (Write-Back)</h4>
                        <div class="experiment-content">
                            <p>Data is written to cache immediately, then asynchronously persisted to database. Improves write performance but risks data loss.</p>
<pre><code class="language-python"># Write-Behind Pattern with Queue
import threading
import queue
import time

class WriteBehindService:
    def __init__(self):
        self.cache = redis.Redis(host='localhost', port=6379)
        self.write_queue = queue.Queue()
        self._start_background_writer()
    
    def _start_background_writer(self):
        def writer():
            while True:
                try:
                    # Batch writes every 100ms
                    time.sleep(0.1)
                    batch = []
                    while not self.write_queue.empty() and len(batch) < 100:
                        batch.append(self.write_queue.get_nowait())
                    
                    if batch:
                        self.database.batch_insert("users", batch)
                except Exception as e:
                    print(f"Write-behind error: {e}")
        
        thread = threading.Thread(target=writer, daemon=True)
        thread.start()
    
    def save_user(self, user_id, data):
        # Immediately write to cache
        self.cache.set(f"user:{user_id}", json.dumps(data))
        
        # Queue for async database write
        self.write_queue.put((user_id, data))
        
        return True  # Return immediately</code></pre>
                            <p><strong>Pros:</strong> Very fast writes, batching reduces database load<br>
                            <strong>Cons:</strong> Risk of data loss, eventual consistency</p>
                        </div>
                        <div class="experiment-tags">
                            <span class="bias-tag">High Performance</span>
                            <span class="bias-tag">Eventual Consistency</span>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-sync-alt me-2"></i>Refresh-Ahead</h4>
                        <div class="experiment-content">
                            <p>Proactively refresh cache entries before they expire, preventing cache misses.</p>
<pre><code class="language-python"># Refresh-Ahead Pattern
import threading

class RefreshAheadService:
    def __init__(self):
        self.cache = redis.Redis(host='localhost', port=6379)
        self.cache_ttl = 3600  # 1 hour
        self.refresh_threshold = 0.75  # Refresh when 75% expired
    
    def get_user(self, user_id):
        cache_key = f"user:{user_id}"
        
        # Get cached value with TTL
        cached = self.cache.get(cache_key)
        ttl = self.cache.ttl(cache_key)
        
        if cached:
            # Check if approaching expiration
            if ttl < self.cache_ttl * (1 - self.refresh_threshold):
                # Trigger async refresh
                threading.Thread(
                    target=self._refresh_cache,
                    args=(user_id,)
                ).start()
            
            return json.loads(cached)
        
        # Cache miss - fetch and cache
        return self._fetch_and_cache(user_id)
    
    def _refresh_cache(self, user_id):
        """Background refresh without blocking the request"""
        self._fetch_and_cache(user_id)
    
    def _fetch_and_cache(self, user_id):
        user = self.database.query(f"SELECT * FROM users WHERE id = {user_id}")
        self.cache.setex(f"user:{user_id}", self.cache_ttl, json.dumps(user))
        return user</code></pre>
                            <p><strong>Pros:</strong> Minimizes cache misses, predictable latency<br>
                            <strong>Cons:</strong> Complex implementation, may refresh unused data</p>
                        </div>
                        <div class="experiment-tags">
                            <span class="bias-tag">Low Latency</span>
                            <span class="bias-tag">Predictable</span>
                        </div>
                    </div>

                    <h4>Cache Eviction Policies</h4>
                    <p>When cache is full, eviction policies determine which entries to remove:</p>
                    <ul>
                        <li><strong>LRU (Least Recently Used):</strong> Evicts the least recently accessed items. Most common choice.</li>
                        <li><strong>LFU (Least Frequently Used):</strong> Evicts items accessed least often. Good for static popularity distributions.</li>
                        <li><strong>FIFO (First In First Out):</strong> Evicts oldest items. Simple but not optimal.</li>
                        <li><strong>TTL (Time To Live):</strong> Items expire after set duration. Good for time-sensitive data.</li>
                        <li><strong>Random:</strong> Randomly evicts items. Surprisingly effective and simple.</li>
                    </ul>
                </div>

                <div id="redis" class="blog-content mt-5">
                    <h3>Redis & Memcached</h3>
                    <p>The two most popular distributed caching solutions have different strengths:</p>

                    <table class="table table-bordered">
                        <thead class="table-dark">
                            <tr>
                                <th>Feature</th>
                                <th>Redis</th>
                                <th>Memcached</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Data Types</strong></td>
                                <td>Strings, Lists, Sets, Hashes, Sorted Sets, Streams</td>
                                <td>Strings only</td>
                            </tr>
                            <tr>
                                <td><strong>Persistence</strong></td>
                                <td>RDB snapshots, AOF logs</td>
                                <td>None (pure cache)</td>
                            </tr>
                            <tr>
                                <td><strong>Replication</strong></td>
                                <td>Primary-replica, Redis Cluster</td>
                                <td>None built-in</td>
                            </tr>
                            <tr>
                                <td><strong>Memory Efficiency</strong></td>
                                <td>Good</td>
                                <td>Excellent (slab allocation)</td>
                            </tr>
                            <tr>
                                <td><strong>Use Cases</strong></td>
                                <td>Sessions, leaderboards, pub/sub, queues</td>
                                <td>Simple caching, high-throughput</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="experiment-card">
                        <h4><i class="fas fa-cube me-2"></i>Redis Examples</h4>
                        <div class="experiment-content">
<pre><code class="language-python"># Redis Advanced Use Cases
import redis

r = redis.Redis(host='localhost', port=6379, decode_responses=True)

# 1. Rate Limiting with Sliding Window
def is_rate_limited(user_id, limit=100, window_seconds=60):
    key = f"rate_limit:{user_id}"
    current_time = int(time.time())
    window_start = current_time - window_seconds
    
    pipe = r.pipeline()
    pipe.zremrangebyscore(key, 0, window_start)  # Remove old entries
    pipe.zadd(key, {str(current_time): current_time})  # Add current
    pipe.zcard(key)  # Count entries
    pipe.expire(key, window_seconds)  # Set expiry
    results = pipe.execute()
    
    return results[2] > limit  # True if rate limited

# 2. Distributed Lock
def acquire_lock(lock_name, timeout=10):
    lock_key = f"lock:{lock_name}"
    identifier = str(uuid.uuid4())
    
    if r.set(lock_key, identifier, nx=True, ex=timeout):
        return identifier  # Lock acquired
    return None  # Lock held by another process

def release_lock(lock_name, identifier):
    lock_key = f"lock:{lock_name}"
    # Lua script for atomic check-and-delete
    script = """
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    """
    r.eval(script, 1, lock_key, identifier)

# 3. Leaderboard with Sorted Sets
def update_score(user_id, score):
    r.zadd("leaderboard", {user_id: score})

def get_top_players(count=10):
    return r.zrevrange("leaderboard", 0, count-1, withscores=True)

def get_user_rank(user_id):
    return r.zrevrank("leaderboard", user_id) + 1  # 1-indexed</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb"></i>
                        <strong>When to Choose:</strong> Use <strong>Redis</strong> when you need rich data structures, persistence, or pub/sub. Use <strong>Memcached</strong> for simple key-value caching at massive scale with minimal overhead.
                    </div>
                </div>

                <div id="cdn" class="blog-content mt-5">
                    <h2><i class="fas fa-globe me-2 text-teal"></i>Content Delivery Networks</h2>
                    <p>A <strong>CDN</strong> is a geographically distributed network of proxy servers that cache content close to end users, reducing latency and offloading traffic from origin servers.</p>

                    <h3>How CDNs Work</h3>
                    <ol>
                        <li><strong>User requests content</strong> (e.g., image, video, JavaScript file)</li>
                        <li><strong>DNS routes to nearest edge server</strong> (Points of Presence - PoPs)</li>
                        <li><strong>Edge server checks cache:</strong>
                            <ul>
                                <li><strong>Cache hit:</strong> Returns content immediately (~10-50ms)</li>
                                <li><strong>Cache miss:</strong> Fetches from origin, caches, then returns</li>
                            </ul>
                        </li>
                        <li><strong>Content served to user</strong> from geographically close server</li>
                    </ol>

                    <h3>CDN Benefits</h3>
                    <ul>
                        <li><strong>Reduced Latency:</strong> Content served from edge servers close to users</li>
                        <li><strong>Origin Offload:</strong> CDN handles majority of traffic</li>
                        <li><strong>DDoS Protection:</strong> Distributed infrastructure absorbs attacks</li>
                        <li><strong>High Availability:</strong> Redundant edge servers ensure uptime</li>
                        <li><strong>Cost Savings:</strong> Reduced bandwidth from origin</li>
                    </ul>

                    <h3>Push vs. Pull CDNs</h3>
                    <table class="table table-bordered">
                        <thead class="table-dark">
                            <tr>
                                <th>Feature</th>
                                <th>Pull CDN</th>
                                <th>Push CDN</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Content Population</strong></td>
                                <td>On-demand (first request triggers fetch)</td>
                                <td>Pre-uploaded to edge servers</td>
                            </tr>
                            <tr>
                                <td><strong>Best For</strong></td>
                                <td>Dynamic content, frequently changing sites</td>
                                <td>Static content, known assets</td>
                            </tr>
                            <tr>
                                <td><strong>Traffic Spikes</strong></td>
                                <td>May cause origin overload on cache miss</td>
                                <td>Handles spikes well (content pre-cached)</td>
                            </tr>
                            <tr>
                                <td><strong>Storage Cost</strong></td>
                                <td>Only popular content cached</td>
                                <td>All content replicated everywhere</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="experiment-card">
                        <h4><i class="fas fa-code me-2"></i>CDN Cache Headers</h4>
                        <div class="experiment-content">
                            <p>Control CDN caching behavior with HTTP headers:</p>
<pre><code class="language-python"># Setting Cache Headers in Python/Flask
from flask import Flask, make_response

app = Flask(__name__)

@app.route('/static/image.jpg')
def serve_image():
    response = make_response(get_image())
    
    # Cache for 1 year (immutable assets with versioned URLs)
    response.headers['Cache-Control'] = 'public, max-age=31536000, immutable'
    
    return response

@app.route('/api/user-profile')
def user_profile():
    response = make_response(get_user_data())
    
    # Private data - don't cache on CDN, only browser
    response.headers['Cache-Control'] = 'private, max-age=300'
    
    return response

@app.route('/api/prices')
def prices():
    response = make_response(get_prices())
    
    # Revalidate every request (CDN checks if-modified-since)
    response.headers['Cache-Control'] = 'public, no-cache'
    response.headers['ETag'] = calculate_etag(get_prices())
    
    return response</code></pre>
                        </div>
                    </div>

                    <h3>Common CDN Providers</h3>
                    <ul>
                        <li><strong>Cloudflare:</strong> Global network, DDoS protection, edge computing (Workers)</li>
                        <li><strong>AWS CloudFront:</strong> Deep AWS integration, Lambda@Edge for edge compute</li>
                        <li><strong>Akamai:</strong> Largest network, enterprise-focused, advanced security</li>
                        <li><strong>Fastly:</strong> Real-time purging, edge computing (Compute@Edge)</li>
                        <li><strong>Google Cloud CDN:</strong> GCP integration, Anycast network</li>
                    </ul>

                    <div class="highlight-box" style="background: rgba(191, 9, 47, 0.1); border-left-color: var(--color-crimson);">
                        <i class="fas fa-chart-line"></i>
                        <strong>Real-World Impact:</strong> Netflix uses its own CDN (Open Connect) with servers in ISP networks, achieving 95%+ cache hit rates and reducing origin traffic by orders of magnitude.
                    </div>

                    <h3>Cache Invalidation Strategies</h3>
                    <p>The famous saying "There are only two hard things in Computer Science: cache invalidation and naming things" highlights the challenge of keeping caches current:</p>
                    <ul>
                        <li><strong>TTL-based:</strong> Content expires after set duration. Simple but may serve stale content.</li>
                        <li><strong>Versioned URLs:</strong> Include version/hash in URL (e.g., <code>style.v2.css</code>, <code>bundle.a1b2c3.js</code>). Instant invalidation by changing URL.</li>
                        <li><strong>Purge API:</strong> Explicitly invalidate specific URLs or patterns via CDN API.</li>
                        <li><strong>Tag-based:</strong> Tag content (e.g., "product-123") and purge by tag when data changes.</li>
                    </ul>
                </div>

                <div id="next-steps" class="blog-content mt-5">
                    <h2><i class="fas fa-arrow-right me-2 text-teal"></i>Next Steps</h2>
                    
                    <div class="related-posts">
                        <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                        <div class="related-post-item">
                            <h5 class="mb-2">Part 2: Scalability Fundamentals</h5>
                            <p class="text-muted small mb-2">Review horizontal and vertical scaling strategies.</p>
                            <a href="system-design-scalability-fundamentals.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5 class="mb-2">Part 4: Database Design & Sharding</h5>
                            <p class="text-muted small mb-2">Learn database design patterns and sharding strategies.</p>
                            <a href="system-design-database-sharding.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5 class="mb-2">Part 5: Microservices Architecture</h5>
                            <p class="text-muted small mb-2">Master microservices patterns and service mesh.</p>
                            <a href="system-design-microservices-architecture.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">
                        I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.
                    </p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook">
                            <i class="fab fa-facebook-f"></i>
                        </a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube">
                            <i class="fab fa-youtube"></i>
                        </a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram">
                            <i class="fab fa-instagram"></i>
                        </a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest">
                            <i class="fab fa-pinterest-p"></i>
                        </a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email">
                            <i class="fas fa-envelope"></i>
                        </a>
                    </div>
                </div>
            </div>

            <hr class="bg-secondary">

            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small">
                        <i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a>
                    </p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">
                        Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!
                    </p>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <button id="scrollToTop" class="scroll-to-top"><i class="fas fa-arrow-up"></i></button>
    <!-- Category Indicator -->
    <div id="categoryIndicator" class="category-indicator" title="Current Section">
        <i class="fas fa-tag"></i><span id="categoryText">Technology</span>
    </div>
    <script src="../../../js/cookie-consent.js"></script>
    <script src="../../../js/main.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const scrollToTopBtn = document.getElementById('scrollToTop');
            window.addEventListener('scroll', function() { scrollToTopBtn.classList.toggle('show', window.scrollY > 300); });
            scrollToTopBtn.addEventListener('click', function() { window.scrollTo({ top: 0, behavior: 'smooth' }); });
        });
        function openNav() { document.getElementById('tocSidenav').classList.add('open'); document.getElementById('tocOverlay').classList.add('show'); document.body.style.overflow = 'hidden'; }
        function closeNav() { document.getElementById('tocSidenav').classList.remove('open'); document.getElementById('tocOverlay').classList.remove('show'); document.body.style.overflow = 'auto'; }
        document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closeNav(); });
        const themes = { 'prism-theme': 'Tomorrow Night', 'prism-default': 'Default', 'prism-dark': 'Dark', 'prism-twilight': 'Twilight', 'prism-okaidia': 'Okaidia', 'prism-solarizedlight': 'Solarized Light' };
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        function switchTheme(themeId) { Object.keys(themes).forEach(id => { const link = document.getElementById(id); if (link) link.disabled = true; }); const selectedLink = document.getElementById(themeId); if (selectedLink) { selectedLink.disabled = false; localStorage.setItem('prism-theme', themeId); } setTimeout(() => Prism.highlightAll(), 10); }
        document.addEventListener('DOMContentLoaded', function() { switchTheme(savedTheme); });
        Prism.plugins.toolbar.registerButton('theme-switcher', function() { const select = document.createElement('select'); Object.keys(themes).forEach(id => { const opt = document.createElement('option'); opt.value = id; opt.textContent = themes[id]; if (id === savedTheme) opt.selected = true; select.appendChild(opt); }); select.addEventListener('change', e => switchTheme(e.target.value)); return select; });
    </script>

            <!-- Scroll-to-Top and Category Indicator Script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const scrollToTopBtn = document.getElementById('scrollToTop');
            const categoryIndicator = document.getElementById('categoryIndicator');
            const categoryText = document.getElementById('categoryText');
            
            // Auto-detect H2 sections in the article (works with or without id)
            const h2Elements = document.querySelectorAll('.blog-content h2');
            const sections = [];
            h2Elements.forEach(function(h2, index) {
                // Get text without icon
                let text = h2.textContent.trim().replace(/^\d+\.\s*/, '');
                // Truncate to 25 chars
                if (text.length > 25) text = text.substring(0, 22) + '...';
                sections.push({ element: h2, name: text });
            });
            
            // Fallback to article category if no sections found
            const articleCategory = categoryText ? categoryText.textContent : 'Article';
            
            // Show/hide button on scroll and update section
            window.addEventListener('scroll', function() {
                if (window.scrollY > 300) {
                    if (scrollToTopBtn) scrollToTopBtn.classList.add('show');
                    if (categoryIndicator) categoryIndicator.classList.add('show');
                } else {
                    if (scrollToTopBtn) scrollToTopBtn.classList.remove('show');
                    if (categoryIndicator) categoryIndicator.classList.remove('show');
                }
                
                // Update current section
                updateCurrentSection();
            });
            
            // Update section based on viewport position
            function updateCurrentSection() {
                if (!categoryText || sections.length === 0) return;
                
                let currentSection = articleCategory;
                
                for (let section of sections) {
                    const rect = section.element.getBoundingClientRect();
                    if (rect.top <= window.innerHeight / 2) {
                        currentSection = section.name;
                    }
                }
                
                categoryText.textContent = currentSection;
            }
            
            // Smooth scroll to top on click
            if (scrollToTopBtn) {
                scrollToTopBtn.addEventListener('click', function() {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
            }
        });
    </script>
</body>
</html>
