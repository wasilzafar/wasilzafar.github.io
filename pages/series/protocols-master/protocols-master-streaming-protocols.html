<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Master video streaming protocols: HLS, DASH, RTMP, and WebRTC for live and on-demand video delivery. Learn adaptive bitrate streaming and CDN integration." />
    <meta name="author" content="Wasil Zafar" />
    <meta name="keywords" content="HLS, DASH, RTMP, Video Streaming, Adaptive Bitrate, ABR, CDN, Live Streaming, VOD, FFmpeg" />
    <meta property="og:title" content="Complete Protocols Master Part 12: Streaming Protocols" />
    <meta property="og:description" content="Comprehensive guide to video streaming protocols: HLS, DASH, RTMP for live and on-demand content delivery." />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2026-01-31" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />
    
    <title>Complete Protocols Master Part 12: Streaming Protocols - Wasil Zafar</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">

    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', {'ad_storage': 'denied', 'analytics_storage': 'denied', 'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE']});
        gtag('consent', 'default', {'ad_storage': 'granted', 'analytics_storage': 'granted'});
    </script>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s);j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-PBS8M2JR');</script>
</head>
<body>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
                <h1 class="display-4 fw-bold mb-3">Complete Protocols Master Part 12: Streaming Protocols</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>January 31, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>38 min read</span>
                    <button onclick="window.print()" class="print-btn"><i class="fas fa-print"></i> Print</button>
                </div>
                <p class="lead">Master video streaming from RTMP ingest to HLS/DASH delivery. Learn adaptive bitrate streaming, CDN integration, and build your own streaming pipeline.</p>
            </div>
        </div>
    </section>

    <button class="toc-toggle-btn" onclick="openNav()"><i class="fas fa-list"></i></button>
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()">&times;</button>
        </div>
        <ol>
            <li><a href="#introduction" onclick="closeNav()">Introduction</a></li>
            <li><a href="#rtmp" onclick="closeNav()">RTMP (Ingest)</a></li>
            <li><a href="#hls" onclick="closeNav()">HLS (Apple)</a></li>
            <li><a href="#dash" onclick="closeNav()">DASH (MPEG)</a></li>
            <li><a href="#abr" onclick="closeNav()">Adaptive Bitrate</a></li>
            <li><a href="#cdn" onclick="closeNav()">CDN Delivery</a></li>
            <li><a href="#ffmpeg" onclick="closeNav()">FFmpeg Pipeline</a></li>
            <li><a href="#summary" onclick="closeNav()">Summary</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-play-circle me-2 text-teal"></i>Introduction: Video Streaming Architecture</h2>
                    
                    <p>Video streaming has evolved from Flash-based RTMP to HTTP-based adaptive streaming. Modern platforms use RTMP for ingest and HLS/DASH for delivery—combining low-latency capture with scalable HTTP delivery.</p>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-sitemap me-2"></i>
                        <strong>Series Context:</strong> This is <strong>Part 12 of 20</strong> in the Complete Protocols Master series. Streaming protocols operate at the Application Layer, primarily over HTTP for delivery.
                    </div>

                    <div class="experiment-card" id="series-nav">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">20-Part Series</span>
                            <span class="badge bg-crimson">Protocol Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="protocols-master-osi-foundations.html"><strong>Part 1:</strong> OSI Model & Protocol Foundations</a> — Network layers, encapsulation, TCP/IP model</li>
                                <li><a href="protocols-master-physical-datalink.html"><strong>Part 2:</strong> Physical & Data Link Layers</a> — Ethernet, Wi-Fi, VLANs, MAC addressing</li>
                                <li><a href="protocols-master-network-layer.html"><strong>Part 3:</strong> Network Layer & IP</a> — IPv4, IPv6, ICMP, routing protocols</li>
                                <li><a href="protocols-master-transport-layer.html"><strong>Part 4:</strong> Transport Layer</a> — TCP, UDP, QUIC, ports, sockets</li>
                                <li><a href="protocols-master-session-presentation.html"><strong>Part 5:</strong> Session & Presentation Layers</a> — TLS handshake, encryption, serialization</li>
                                <li><a href="protocols-master-web-protocols.html"><strong>Part 6:</strong> Web Protocols</a> — HTTP/1.1, HTTP/2, HTTP/3, WebSockets</li>
                                <li><a href="protocols-master-api-protocols.html"><strong>Part 7:</strong> API Protocols</a> — REST, GraphQL, gRPC, SOAP</li>
                                <li><a href="protocols-master-dns-deep-dive.html"><strong>Part 8:</strong> DNS Deep Dive</a> — DNS hierarchy, records, DNSSEC</li>
                                <li><a href="protocols-master-email-protocols.html"><strong>Part 9:</strong> Email Protocols</a> — SMTP, IMAP, POP3, SPF/DKIM/DMARC</li>
                                <li><a href="protocols-master-file-transfer.html"><strong>Part 10:</strong> File Transfer Protocols</a> — FTP, SFTP, SCP, rsync</li>
                                <li><a href="protocols-master-realtime-protocols.html"><strong>Part 11:</strong> Real-Time Protocols</a> — WebRTC, SIP, RTP, VoIP</li>
                                <li><strong>Part 12: Streaming Protocols (This Guide)</strong> — HLS, DASH, RTMP, media delivery</li>
                                <li><a href="protocols-master-iot-protocols.html"><strong>Part 13:</strong> IoT Protocols</a> — MQTT, CoAP, Zigbee, LoRaWAN</li>
                                <li><a href="protocols-master-vpn-tunneling.html"><strong>Part 14:</strong> VPN & Tunneling</a> — IPsec, OpenVPN, WireGuard</li>
                                <li><a href="protocols-master-authentication-protocols.html"><strong>Part 15:</strong> Authentication Protocols</a> — OAuth, SAML, OIDC, Kerberos</li>
                                <li><a href="protocols-master-network-management.html"><strong>Part 16:</strong> Network Management</a> — SNMP, NetFlow, Syslog</li>
                                <li><a href="protocols-master-security-protocols.html"><strong>Part 17:</strong> Security Protocols</a> — TLS/SSL, certificates, PKI</li>
                                <li><a href="protocols-master-cloud-protocols.html"><strong>Part 18:</strong> Cloud Provider Protocols</a> — AWS, Azure, GCP APIs</li>
                                <li><a href="protocols-master-emerging-protocols.html"><strong>Part 19:</strong> Emerging Protocols</a> — QUIC, HTTP/3, WebTransport</li>
                                <li><a href="protocols-master-web-security-standards.html"><strong>Part 20:</strong> Web Security Standards</a> — CORS, CSP, HSTS, SRI</li>
                            </ol>
                        </div>
                    </div>

                    <div class="experiment-card">
                        <div class="card-meta mb-2"><span class="badge bg-teal text-white">Architecture</span></div>
                        <h4>Modern Streaming Pipeline</h4>
<pre><code class="language-bash">Streaming Pipeline:

ENCODER → INGEST → TRANSCODER → PACKAGER → CDN → PLAYER

1. ENCODER (OBS, Hardware)
   • Capture video/audio
   • Encode to H.264/H.265
   • Send via RTMP/SRT

2. INGEST SERVER
   • Receive RTMP stream
   • Validate stream key
   • Forward to transcoder

3. TRANSCODER
   • Create multiple bitrates
   • 1080p, 720p, 480p, 360p
   • Adaptive streaming variants

4. PACKAGER
   • Segment into chunks
   • Generate HLS/DASH manifest
   • Add encryption (DRM)

5. CDN
   • Cache at edge locations
   • Deliver to viewers globally
   • Handle millions of viewers

6. PLAYER
   • Fetch manifest
   • Select bitrate (ABR)
   • Buffer and play
</code></pre>
                    </div>

                    <div class="experiment-card">
                        <div class="card-meta mb-2"><span class="badge bg-crimson text-white">Comparison</span></div>
                        <h4>Protocol Comparison</h4>
                        <table class="table table-bordered">
                            <thead><tr><th>Protocol</th><th>Use Case</th><th>Latency</th><th>Transport</th></tr></thead>
                            <tbody>
                                <tr><td><strong>RTMP</strong></td><td>Ingest</td><td>1-3s</td><td>TCP</td></tr>
                                <tr><td><strong>HLS</strong></td><td>Delivery</td><td>10-30s</td><td>HTTP</td></tr>
                                <tr><td><strong>LL-HLS</strong></td><td>Low-latency delivery</td><td>2-5s</td><td>HTTP</td></tr>
                                <tr><td><strong>DASH</strong></td><td>Delivery</td><td>10-30s</td><td>HTTP</td></tr>
                                <tr><td><strong>LL-DASH</strong></td><td>Low-latency delivery</td><td>2-5s</td><td>HTTP</td></tr>
                                <tr><td><strong>WebRTC</strong></td><td>Ultra-low latency</td><td>&lt;1s</td><td>UDP/TCP</td></tr>
                                <tr><td><strong>SRT</strong></td><td>Reliable ingest</td><td>1-2s</td><td>UDP</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div id="rtmp" class="blog-content mt-5">
                    <h2><i class="fas fa-upload me-2 text-teal"></i>RTMP: Real-Time Messaging Protocol</h2>

                    <p><strong>RTMP</strong> was created by Adobe for Flash. While Flash is dead, RTMP lives on as the de facto standard for stream ingest—OBS, encoders, and streaming platforms all speak RTMP.</p>

                    <div class="experiment-card">
                        <div class="card-meta mb-2"><span class="badge bg-teal text-white">RTMP Basics</span></div>
                        <h4>RTMP Connection Flow</h4>
<pre><code class="language-bash">RTMP Connection:

1. TCP HANDSHAKE
   Client → Server: C0 + C1 (version + random)
   Server → Client: S0 + S1 + S2
   Client → Server: C2

2. CONNECT
   Client: connect('rtmp://server/app')
   Server: result (success)

3. CREATE STREAM
   Client: createStream()
   Server: result (stream_id)

4. PUBLISH (for streaming)
   Client: publish('stream_key', 'live')
   Server: onStatus('NetStream.Publish.Start')

5. SEND DATA
   Client: audio/video chunks
   (Continues until disconnect)

RTMP URL Format:
rtmp://server.com/app/stream_key
• server.com - Server address
• app - Application name
• stream_key - Unique stream identifier
</code></pre>
                    </div>

<pre><code class="language-bash"># RTMP streaming examples

# OBS Settings:
# Server: rtmp://live.twitch.tv/app
# Stream Key: live_xxxxx_yyyyy

# FFmpeg RTMP stream to server
ffmpeg -i input.mp4 \
    -c:v libx264 -preset veryfast \
    -maxrate 3000k -bufsize 6000k \
    -c:a aac -b:a 128k \
    -f flv rtmp://server.com/app/stream_key

# Receive RTMP and save to file
ffmpeg -i rtmp://server.com/app/stream_key \
    -c copy output.mp4

# RTMP to HLS conversion (live)
ffmpeg -i rtmp://server.com/app/stream_key \
    -c:v copy -c:a copy \
    -f hls -hls_time 4 -hls_list_size 5 \
    /var/www/stream/playlist.m3u8
</code></pre>

                    <div class="experiment-card">
                        <div class="card-meta mb-2"><span class="badge bg-crimson text-white">SRT Alternative</span></div>
                        <h4>SRT: Secure Reliable Transport</h4>
<pre><code class="language-bash">SRT vs RTMP:

SRT Advantages:
• UDP-based (lower latency)
• Built-in encryption (AES)
• Error correction (ARQ)
• Better over unreliable networks
• Open source (Haivision)

When to use SRT:
• Contribution links over internet
• Remote production
• When RTMP has packet loss issues

SRT Example:
ffmpeg -i input.mp4 \
    -c:v libx264 -f mpegts \
    'srt://server.com:9000?streamid=mystream'

# Receive SRT
ffmpeg -i 'srt://server.com:9000?mode=caller' \
    -c copy output.ts
</code></pre>
                    </div>
                </div>

                <div id="hls" class="blog-content mt-5">
                    <h2><i class="fab fa-apple me-2 text-teal"></i>HLS: HTTP Live Streaming</h2>

                    <p><strong>HLS</strong> (Apple, 2009) is the most widely supported streaming format. It segments video into small chunks delivered over HTTP, enabling CDN caching and adaptive bitrate switching.</p>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb"></i>
                        <strong>Why HTTP-based?</strong> HTTP works through firewalls, caches on CDNs, and scales massively. This is why HLS/DASH won over RTMP for delivery.
                    </div>

                    <div class="experiment-card">
                        <div class="card-meta mb-2"><span class="badge bg-teal text-white">HLS Structure</span></div>
                        <h4>HLS File Organization</h4>
<pre><code class="language-bash">HLS Directory Structure:

stream/
├── master.m3u8          # Master playlist (quality selector)
├── 1080p/
│   ├── playlist.m3u8    # Media playlist (segment list)
│   ├── segment000.ts    # Video chunk (4-10 seconds)
│   ├── segment001.ts
│   └── segment002.ts
├── 720p/
│   ├── playlist.m3u8
│   └── *.ts
├── 480p/
│   ├── playlist.m3u8
│   └── *.ts
└── audio/
    ├── playlist.m3u8
    └── *.aac

Player Flow:
1. Fetch master.m3u8
2. Select quality based on bandwidth
3. Fetch media playlist for that quality
4. Download and play segments sequentially
5. Switch quality if bandwidth changes
</code></pre>
                    </div>

<pre><code class="language-bash"># Master playlist (master.m3u8)

#EXTM3U
#EXT-X-VERSION:3

#EXT-X-STREAM-INF:BANDWIDTH=800000,RESOLUTION=640x360
360p/playlist.m3u8

#EXT-X-STREAM-INF:BANDWIDTH=1400000,RESOLUTION=842x480
480p/playlist.m3u8

#EXT-X-STREAM-INF:BANDWIDTH=2800000,RESOLUTION=1280x720
720p/playlist.m3u8

#EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1920x1080
1080p/playlist.m3u8
</code></pre>

<pre><code class="language-bash"># Media playlist (720p/playlist.m3u8)

#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:6
#EXT-X-MEDIA-SEQUENCE:0

#EXTINF:6.000,
segment000.ts
#EXTINF:6.000,
segment001.ts
#EXTINF:6.000,
segment002.ts
#EXTINF:4.500,
segment003.ts

# For VOD, add at end:
#EXT-X-ENDLIST

# For live, playlist updates as new segments added
</code></pre>

<pre><code class="language-bash"># Create HLS from video file

ffmpeg -i input.mp4 \
    -c:v libx264 -crf 21 -preset veryfast \
    -c:a aac -b:a 128k \
    -hls_time 6 \
    -hls_list_size 0 \
    -hls_segment_filename "segment%03d.ts" \
    playlist.m3u8

# Multi-bitrate HLS (adaptive)
ffmpeg -i input.mp4 \
    -filter_complex "[0:v]split=3[v1][v2][v3];\
        [v1]scale=1280:720[v1out];\
        [v2]scale=854:480[v2out];\
        [v3]scale=640:360[v3out]" \
    -map "[v1out]" -c:v:0 libx264 -b:v:0 2800k \
    -map "[v2out]" -c:v:1 libx264 -b:v:1 1400k \
    -map "[v3out]" -c:v:2 libx264 -b:v:2 800k \
    -map 0:a -c:a aac -b:a 128k \
    -f hls -hls_time 6 \
    -master_pl_name master.m3u8 \
    -var_stream_map "v:0,a:0 v:1,a:1 v:2,a:2" \
    stream_%v/playlist.m3u8
</code></pre>
                </div>

                <div id="dash" class="blog-content mt-5">
                    <h2><i class="fas fa-film me-2 text-teal"></i>DASH: Dynamic Adaptive Streaming over HTTP</h2>

                    <p><strong>MPEG-DASH</strong> is the international standard for adaptive streaming. Unlike HLS (Apple proprietary), DASH is codec-agnostic and widely adopted on non-Apple platforms.</p>

                    <div class="experiment-card">
                        <div class="card-meta mb-2"><span class="badge bg-crimson text-white">HLS vs DASH</span></div>
                        <h4>Protocol Comparison</h4>
                        <table class="table table-bordered">
                            <thead><tr><th>Feature</th><th>HLS</th><th>DASH</th></tr></thead>
                            <tbody>
                                <tr><td>Creator</td><td>Apple</td><td>MPEG (ISO Standard)</td></tr>
                                <tr><td>Manifest</td><td>.m3u8 (text)</td><td>.mpd (XML)</td></tr>
                                <tr><td>Segments</td><td>.ts (MPEG-TS)</td><td>.m4s (fMP4)</td></tr>
                                <tr><td>iOS Support</td><td>✅ Native</td><td>❌ Requires JS</td></tr>
                                <tr><td>Android Support</td><td>✅ ExoPlayer</td><td>✅ Native</td></tr>
                                <tr><td>DRM</td><td>FairPlay</td><td>Widevine, PlayReady</td></tr>
                                <tr><td>Codec Flexibility</td><td>Limited</td><td>Any codec</td></tr>
                            </tbody>
                        </table>
                    </div>

<pre><code class="language-xml">&lt;!-- DASH MPD (Media Presentation Description) --&gt;
&lt;?xml version="1.0"?&gt;
&lt;MPD xmlns="urn:mpeg:dash:schema:mpd:2011"
     type="static"
     mediaPresentationDuration="PT1H30M"
     minBufferTime="PT2S"&gt;
    
    &lt;Period&gt;
        &lt;AdaptationSet mimeType="video/mp4" segmentAlignment="true"&gt;
            &lt;!-- 1080p --&gt;
            &lt;Representation id="1080p" bandwidth="5000000" 
                            width="1920" height="1080"&gt;
                &lt;SegmentTemplate media="1080p_$Number$.m4s"
                                 initialization="1080p_init.mp4"
                                 duration="6000" timescale="1000"/&gt;
            &lt;/Representation&gt;
            
            &lt;!-- 720p --&gt;
            &lt;Representation id="720p" bandwidth="2800000"
                            width="1280" height="720"&gt;
                &lt;SegmentTemplate media="720p_$Number$.m4s"
                                 initialization="720p_init.mp4"
                                 duration="6000" timescale="1000"/&gt;
            &lt;/Representation&gt;
        &lt;/AdaptationSet&gt;
        
        &lt;AdaptationSet mimeType="audio/mp4"&gt;
            &lt;Representation id="audio" bandwidth="128000"&gt;
                &lt;SegmentTemplate media="audio_$Number$.m4s"
                                 initialization="audio_init.mp4"
                                 duration="6000" timescale="1000"/&gt;
            &lt;/Representation&gt;
        &lt;/AdaptationSet&gt;
    &lt;/Period&gt;
&lt;/MPD&gt;
</code></pre>

<pre><code class="language-bash"># Create DASH content with FFmpeg

# Single quality
ffmpeg -i input.mp4 \
    -c:v libx264 -c:a aac \
    -f dash \
    -seg_duration 6 \
    output.mpd

# Multi-bitrate DASH
ffmpeg -i input.mp4 \
    -map 0:v -map 0:v -map 0:v -map 0:a \
    -c:v libx264 -c:a aac \
    -b:v:0 5000k -s:v:0 1920x1080 \
    -b:v:1 2800k -s:v:1 1280x720 \
    -b:v:2 1400k -s:v:2 854x480 \
    -b:a 128k \
    -f dash \
    -adaptation_sets "id=0,streams=v id=1,streams=a" \
    output.mpd
</code></pre>
                </div>

                <div id="abr" class="blog-content mt-5">
                    <h2><i class="fas fa-signal me-2 text-teal"></i>Adaptive Bitrate Streaming (ABR)</h2>

                    <p><strong>ABR</strong> algorithms automatically switch video quality based on network conditions. This ensures smooth playback—high quality when bandwidth allows, lower quality to prevent buffering.</p>

                    <div class="experiment-card">
                        <div class="card-meta mb-2"><span class="badge bg-teal text-white">ABR Logic</span></div>
                        <h4>How ABR Works</h4>
<pre><code class="language-bash">ABR Decision Factors:

1. BANDWIDTH ESTIMATION
   • Measure download speed of recent segments
   • Weighted average (recent segments matter more)

2. BUFFER LEVEL
   • How many seconds in buffer?
   • Low buffer → safer (lower quality)
   • High buffer → can try higher quality

3. QUALITY SWITCHING
   • Switch up: Conservative (need consistent bandwidth)
   • Switch down: Aggressive (prevent rebuffer)

ABR Strategies:
• Rate-based: Switch based on throughput
• Buffer-based: Switch based on buffer level
• Hybrid: Combine both signals

Example Logic:
if buffer < 5s:
    select_lowest_quality()
elif throughput > 1.5 * current_bitrate:
    try_higher_quality()
elif throughput < 0.8 * current_bitrate:
    switch_lower_quality()
</code></pre>
                    </div>

<pre><code class="language-python"># Simple ABR algorithm simulation

def simple_abr_algorithm():
    """Demonstrate ABR quality selection"""
    
    # Available quality levels
    qualities = [
        {"name": "360p", "bitrate": 800_000},
        {"name": "480p", "bitrate": 1_400_000},
        {"name": "720p", "bitrate": 2_800_000},
        {"name": "1080p", "bitrate": 5_000_000},
    ]
    
    def select_quality(throughput_bps, buffer_seconds, current_quality_idx):
        """Select quality based on throughput and buffer"""
        
        # Safety margin (don't use 100% of bandwidth)
        safe_throughput = throughput_bps * 0.8
        
        # If buffer is critical, go to lowest
        if buffer_seconds < 3:
            print(f"  ⚠️ Critical buffer ({buffer_seconds}s) - lowest quality")
            return 0
        
        # Find highest quality we can sustain
        selected = 0
        for i, q in enumerate(qualities):
            if q["bitrate"] < safe_throughput:
                selected = i
        
        # Switching logic
        if selected > current_quality_idx:
            # Only switch up if buffer healthy
            if buffer_seconds > 10:
                print(f"  ↑ Buffer healthy ({buffer_seconds}s) - upgrading")
                return selected
            else:
                print(f"  → Buffer moderate - staying at current")
                return current_quality_idx
        elif selected < current_quality_idx:
            print(f"  ↓ Bandwidth dropped - downgrading")
            return selected
        
        return current_quality_idx
    
    print("ABR Algorithm Simulation")
    print("=" * 50)
    
    # Simulate scenarios
    scenarios = [
        (5_000_000, 15, 2),  # Good bandwidth, healthy buffer
        (1_000_000, 8, 2),   # Bandwidth dropped
        (3_000_000, 2, 1),   # Critical buffer
        (4_000_000, 20, 1),  # Bandwidth recovered
    ]
    
    for throughput, buffer, current in scenarios:
        print(f"\nThroughput: {throughput/1_000_000:.1f} Mbps, "
              f"Buffer: {buffer}s, Current: {qualities[current]['name']}")
        new_idx = select_quality(throughput, buffer, current)
        print(f"  Selected: {qualities[new_idx]['name']}")

simple_abr_algorithm()
</code></pre>
                </div>

                <div id="cdn" class="blog-content mt-5">
                    <h2><i class="fas fa-globe me-2 text-teal"></i>CDN Delivery</h2>

                    <p>CDNs (Content Delivery Networks) cache streaming content at edge locations worldwide. This reduces latency, handles traffic spikes, and enables global reach.</p>

                    <div class="experiment-card">
                        <div class="card-meta mb-2"><span class="badge bg-crimson text-white">CDN Architecture</span></div>
                        <h4>Video CDN Flow</h4>
<pre><code class="language-bash">CDN Video Delivery:

ORIGIN → SHIELD → EDGE → VIEWER

1. ORIGIN SERVER
   • Source of truth
   • Generates HLS/DASH
   • Only 1 location

2. SHIELD (Mid-tier)
   • Reduces origin load
   • First cache layer
   • Few locations (1-3)

3. EDGE SERVERS
   • Close to viewers
   • Final cache layer
   • 100+ locations globally

Cache Logic:
1. Viewer requests segment001.ts
2. Edge: Cache miss → ask Shield
3. Shield: Cache miss → ask Origin
4. Origin returns segment
5. Shield caches + returns
6. Edge caches + returns
7. Next viewer request → Edge hit!

CDN Providers for Video:
• CloudFront (AWS)
• Fastly
• Cloudflare Stream
• Akamai
• Azure CDN
</code></pre>
                    </div>

<pre><code class="language-bash"># CloudFront + HLS example

# 1. Upload HLS to S3
aws s3 sync ./stream/ s3://my-video-bucket/stream/

# 2. Create CloudFront distribution
# Origin: my-video-bucket.s3.amazonaws.com
# Cache Policy: CachingOptimized

# 3. Access via CDN
# https://d1234567890.cloudfront.net/stream/master.m3u8

# Cache Headers for HLS
# Manifest: Cache-Control: max-age=2 (live) or max-age=31536000 (VOD)
# Segments: Cache-Control: max-age=31536000 (immutable)

# Nginx config for HLS
location /hls/ {
    types {
        application/vnd.apple.mpegurl m3u8;
        video/mp2t ts;
    }
    root /var/www/stream;
    add_header Cache-Control "max-age=31536000";
}

location ~ \.m3u8$ {
    add_header Cache-Control "max-age=2";  # Short cache for live manifest
}
</code></pre>
                </div>

                <div id="ffmpeg" class="blog-content mt-5">
                    <h2><i class="fas fa-terminal me-2 text-teal"></i>FFmpeg Streaming Pipeline</h2>

                    <p>FFmpeg is the Swiss Army knife of video processing. Here are practical commands for building a complete streaming pipeline.</p>

<pre><code class="language-bash"># Complete HLS streaming pipeline

# 1. RTMP Ingest to HLS (live streaming)
ffmpeg -listen 1 -i rtmp://0.0.0.0:1935/live/stream \
    -c:v libx264 -preset veryfast -tune zerolatency \
    -c:a aac -b:a 128k \
    -f hls \
    -hls_time 4 \
    -hls_list_size 10 \
    -hls_flags delete_segments \
    /var/www/stream/live.m3u8

# 2. Multi-bitrate encoding (ABR ladder)
ffmpeg -i rtmp://localhost/live/stream \
    -filter_complex "[0:v]split=3[v1][v2][v3];\
        [v1]scale=1280:720[v720];\
        [v2]scale=854:480[v480];\
        [v3]scale=640:360[v360]" \
    -map "[v720]" -c:v:0 libx264 -b:v:0 2800k -maxrate:v:0 3000k -bufsize:v:0 6000k \
    -map "[v480]" -c:v:1 libx264 -b:v:1 1400k -maxrate:v:1 1500k -bufsize:v:1 3000k \
    -map "[v360]" -c:v:2 libx264 -b:v:2 800k -maxrate:v:2 900k -bufsize:v:2 1800k \
    -map 0:a -c:a aac -b:a 128k -ac 2 \
    -f hls -hls_time 4 -hls_list_size 10 \
    -master_pl_name master.m3u8 \
    -var_stream_map "v:0,a:0,name:720p v:1,a:1,name:480p v:2,a:2,name:360p" \
    stream_%v.m3u8
</code></pre>

<pre><code class="language-python"># Python streaming helper

import subprocess
import os

def create_hls_stream(input_file, output_dir, qualities=None):
    """Create multi-bitrate HLS from video file"""
    
    if qualities is None:
        qualities = [
            {"name": "720p", "scale": "1280:720", "bitrate": "2800k"},
            {"name": "480p", "scale": "854:480", "bitrate": "1400k"},
            {"name": "360p", "scale": "640:360", "bitrate": "800k"},
        ]
    
    os.makedirs(output_dir, exist_ok=True)
    
    # Build filter complex
    splits = len(qualities)
    filter_parts = [f"[0:v]split={splits}" + "".join(f"[v{i}]" for i in range(splits))]
    
    for i, q in enumerate(qualities):
        filter_parts.append(f"[v{i}]scale={q['scale']}[v{q['name']}]")
    
    filter_complex = ";".join(filter_parts)
    
    # Build command
    cmd = ["ffmpeg", "-i", input_file, "-filter_complex", filter_complex]
    
    # Add outputs
    var_stream_map = []
    for i, q in enumerate(qualities):
        cmd.extend([
            "-map", f"[v{q['name']}]",
            f"-c:v:{i}", "libx264",
            f"-b:v:{i}", q["bitrate"],
        ])
        var_stream_map.append(f"v:{i},a:0,name:{q['name']}")
    
    cmd.extend([
        "-map", "0:a", "-c:a", "aac", "-b:a", "128k",
        "-f", "hls",
        "-hls_time", "6",
        "-master_pl_name", "master.m3u8",
        "-var_stream_map", " ".join(var_stream_map),
        f"{output_dir}/stream_%v.m3u8"
    ])
    
    print("Generated FFmpeg command:")
    print(" ".join(cmd))
    return cmd

# Example usage
print("HLS Creation Example")
print("=" * 50)
create_hls_stream("input.mp4", "/var/www/hls")
</code></pre>
                </div>

                <div id="summary" class="blog-content mt-5">
                    <h2><i class="fas fa-check-circle me-2 text-teal"></i>Summary & Next Steps</h2>

                    <div class="highlight-box">
                        <i class="fas fa-graduation-cap"></i>
                        <strong>Key Takeaways:</strong>
                        <ul class="mt-2 mb-0">
                            <li><strong>RTMP</strong>: Standard for stream ingest (OBS → server)</li>
                            <li><strong>HLS</strong>: Apple's format, widest device support</li>
                            <li><strong>DASH</strong>: Open standard, codec-agnostic</li>
                            <li><strong>ABR</strong>: Automatically adapts quality to bandwidth</li>
                            <li><strong>CDN</strong>: Essential for global, scalable delivery</li>
                            <li><strong>FFmpeg</strong>: Swiss Army knife for encoding/packaging</li>
                        </ul>
                    </div>

                    <div class="experiment-card">
                        <div class="card-meta mb-2"><span class="badge bg-teal text-white">Quiz</span></div>
                        <h4>Test Your Knowledge</h4>
                        <ol>
                            <li>Why RTMP for ingest but HLS for delivery? <em>(RTMP is low-latency, HLS is cacheable/scalable)</em></li>
                            <li>What's the HLS segment duration trade-off? <em>(Longer = less requests, Shorter = lower latency)</em></li>
                            <li>HLS vs DASH: which for iOS? <em>(HLS - native support)</em></li>
                            <li>What does ABR optimize? <em>(Quality vs buffering balance)</em></li>
                            <li>CDN shield tier purpose? <em>(Reduce origin load)</em></li>
                        </ol>
                    </div>

                    <div class="series-next">
                        <h4><i class="fas fa-arrow-right me-2"></i>Next in the Series</h4>
                        <p>In <a href="protocols-master-iot-protocols.html"><strong>Part 13: IoT Protocols</strong></a>, we'll explore MQTT, CoAP, and protocols designed for constrained devices and sensor networks.</p>
                    </div>
                </div>

                <div class="related-posts mt-5">
                    <h3><i class="fas fa-book me-2"></i>Related Articles</h3>
                    <div class="related-post-item">
                        <h5>Part 11: Real-Time Protocols</h5>
                        <p>WebSockets, WebRTC for real-time communication.</p>
                        <a href="protocols-master-realtime-protocols.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                    <div class="related-post-item">
                        <h5>Part 13: IoT Protocols</h5>
                        <p>MQTT, CoAP for IoT devices.</p>
                        <a href="protocols-master-iot-protocols.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">
                        I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.
                    </p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook">
                            <i class="fab fa-facebook-f"></i>
                        </a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube">
                            <i class="fab fa-youtube"></i>
                        </a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram">
                            <i class="fab fa-instagram"></i>
                        </a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest">
                            <i class="fab fa-pinterest-p"></i>
                        </a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email">
                            <i class="fas fa-envelope"></i>
                        </a>
                    </div>
                </div>
            </div>

            <hr class="bg-secondary">

            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small">
                        <i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a>
                    </p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">
                        Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!
                    </p>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <button id="scrollToTop" class="scroll-to-top"><i class="fas fa-arrow-up"></i></button>
    <div id="categoryIndicator" class="category-indicator"></div>
    <script src="../../../js/cookie-consent.js"></script>
    <script src="../../../js/main.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
</body>
</html>
