<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Master the Transport Layer: TCP, UDP, and QUIC protocols. Learn the three-way handshake, flow control, congestion control, ports, sockets, and reliable data delivery." />
    <meta name="author" content="Wasil Zafar" />
    <meta name="keywords" content="TCP, UDP, QUIC, Transport Layer, Three-Way Handshake, Flow Control, Congestion Control, Ports, Sockets" />
    <meta property="og:title" content="Complete Protocols Master Part 4: Transport Layer (TCP, UDP, QUIC)" />
    <meta property="og:description" content="Master TCP, UDP, and QUIC. Learn reliable delivery, flow control, congestion algorithms, and modern transport protocols." />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2026-01-31" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />
    
    <title>Complete Protocols Master Part 4: Transport Layer - Wasil Zafar</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />

    <!-- Prism.js Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <!-- Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE']
        });
        
        gtag('consent', 'default', {
            'ad_storage': 'granted',
            'ad_user_data': 'granted',
            'ad_personalization': 'granted',
            'analytics_storage': 'granted'
        });
        
        gtag('set', 'url_passthrough', true);
    </script>

    <!-- Google Tag Manager -->
    <script>
        (function(w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({
                'gtm.start': new Date().getTime(),
                event: 'gtm.js'
            });
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s),
                dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript>
        <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>

    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/">
                <span class="gradient-text">Wasil Zafar</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
                <h1 class="display-4 fw-bold mb-3">Complete Protocols Master Part 4: Transport Layer</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>January 31, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>42 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article"><i class="fas fa-print"></i> Print</button>
                </div>
                <p class="lead">Dive deep into the Transport Layer where end-to-end communication happens. Master TCP's reliability mechanisms, UDP's speed advantages, and QUIC's modern innovations for the next generation of internet protocols.</p>
            </div>
        </div>
    </section>

    <!-- Table of Contents Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation Overlay -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close Table of Contents">&times;</button>
        </div>
        <ol>
            <li>
                <a href="#introduction" onclick="closeNav()">Introduction</a>
                <ul>
                    <li><a href="#introduction" onclick="closeNav()">Layer 4 Overview</a></li>
                    <li><a href="#ports" onclick="closeNav()">Ports & Sockets</a></li>
                </ul>
            </li>
            <li>
                <a href="#tcp" onclick="closeNav()">TCP Protocol</a>
                <ul>
                    <li><a href="#tcp" onclick="closeNav()">TCP Overview</a></li>
                    <li><a href="#tcp-header" onclick="closeNav()">TCP Header</a></li>
                    <li><a href="#three-way-handshake" onclick="closeNav()">Three-Way Handshake</a></li>
                    <li><a href="#four-way-teardown" onclick="closeNav()">Connection Teardown</a></li>
                </ul>
            </li>
            <li>
                <a href="#tcp-reliability" onclick="closeNav()">TCP Reliability</a>
                <ul>
                    <li><a href="#tcp-reliability" onclick="closeNav()">Sequence & ACK</a></li>
                    <li><a href="#flow-control" onclick="closeNav()">Flow Control</a></li>
                    <li><a href="#congestion-control" onclick="closeNav()">Congestion Control</a></li>
                </ul>
            </li>
            <li>
                <a href="#tcp-states" onclick="closeNav()">TCP States</a>
                <ul>
                    <li><a href="#tcp-states" onclick="closeNav()">State Machine</a></li>
                    <li><a href="#tcp-timers" onclick="closeNav()">TCP Timers</a></li>
                </ul>
            </li>
            <li>
                <a href="#udp" onclick="closeNav()">UDP Protocol</a>
                <ul>
                    <li><a href="#udp" onclick="closeNav()">UDP Overview</a></li>
                    <li><a href="#udp-header" onclick="closeNav()">UDP Header</a></li>
                    <li><a href="#udp-use-cases" onclick="closeNav()">When to Use UDP</a></li>
                </ul>
            </li>
            <li>
                <a href="#quic" onclick="closeNav()">QUIC Protocol</a>
                <ul>
                    <li><a href="#quic" onclick="closeNav()">Why QUIC?</a></li>
                    <li><a href="#quic-features" onclick="closeNav()">QUIC Features</a></li>
                    <li><a href="#quic-vs-tcp" onclick="closeNav()">QUIC vs TCP</a></li>
                </ul>
            </li>
            <li>
                <a href="#comparison" onclick="closeNav()">Protocol Comparison</a>
            </li>
            <li>
                <a href="#hands-on" onclick="closeNav()">Hands-On Exercises</a>
                <ul>
                    <li><a href="#hands-on" onclick="closeNav()">Socket Programming</a></li>
                    <li><a href="#packet-analysis" onclick="closeNav()">Packet Analysis</a></li>
                </ul>
            </li>
            <li>
                <a href="#summary" onclick="closeNav()">Summary & Next Steps</a>
            </li>
        </ol>
    </div>

    <!-- Overlay Backdrop -->
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Main Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <!-- Introduction -->
                <div id="introduction" class="blog-content">
                    <h2><i class="fas fa-exchange-alt me-2 text-teal"></i>Introduction: The Transport Layer</h2>
                    
                    <p>In <a href="protocols-master-network-layer.html">Part 3</a>, we learned how IP routes packets across networks. But IP only provides <strong>best-effort delivery</strong>—packets can be lost, duplicated, or arrive out of order. The <strong>Transport Layer (Layer 4)</strong> solves these problems by providing:</p>
                    
                    <ul>
                        <li><strong>End-to-end communication</strong> between applications</li>
                        <li><strong>Multiplexing</strong> via ports (multiple apps on one IP)</li>
                        <li><strong>Reliability</strong> (TCP) or speed (UDP)</li>
                        <li><strong>Flow and congestion control</strong></li>
                    </ul>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-sitemap me-2"></i>
                        <strong>Series Context:</strong> This is <strong>Part 4 of 20</strong> in the Complete Protocols Master series. We're building from network addressing to end-to-end application communication.
                    </div>

                    <div class="experiment-card" id="series-nav">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">20-Part Series</span>
                            <span class="badge bg-crimson">Protocol Mastery</span>
                        </div>
                        <div class="content">
                            <ol>
                                <li><a href="protocols-master-osi-foundations.html"><strong>Part 1:</strong> OSI Model & Protocol Foundations</a> — Network layers, encapsulation, TCP/IP model</li>
                                <li><a href="protocols-master-physical-datalink.html"><strong>Part 2:</strong> Physical & Data Link Layers</a> — Ethernet, Wi-Fi, VLANs, MAC addressing</li>
                                <li><a href="protocols-master-network-layer.html"><strong>Part 3:</strong> Network Layer & IP</a> — IPv4, IPv6, ICMP, routing protocols</li>
                                <li><strong>Part 4: Transport Layer (This Guide)</strong> — TCP, UDP, QUIC, ports, sockets</li>
                                <li><a href="protocols-master-session-presentation.html"><strong>Part 5:</strong> Session & Presentation Layers</a> — TLS handshake, encryption, serialization</li>
                                <li><a href="protocols-master-web-protocols.html"><strong>Part 6:</strong> Web Protocols</a> — HTTP/1.1, HTTP/2, HTTP/3, WebSockets</li>
                                <li><a href="protocols-master-api-protocols.html"><strong>Part 7:</strong> API Protocols</a> — REST, GraphQL, gRPC, SOAP</li>
                                <li><a href="protocols-master-dns-deep-dive.html"><strong>Part 8:</strong> DNS Deep Dive</a> — DNS hierarchy, records, DNSSEC</li>
                                <li><a href="protocols-master-email-protocols.html"><strong>Part 9:</strong> Email Protocols</a> — SMTP, IMAP, POP3, SPF/DKIM/DMARC</li>
                                <li><a href="protocols-master-file-transfer.html"><strong>Part 10:</strong> File Transfer Protocols</a> — FTP, SFTP, SCP, rsync</li>
                                <li><a href="protocols-master-realtime-protocols.html"><strong>Part 11:</strong> Real-Time Protocols</a> — WebRTC, SIP, RTP, VoIP</li>
                                <li><a href="protocols-master-streaming-protocols.html"><strong>Part 12:</strong> Streaming Protocols</a> — HLS, DASH, RTMP, media delivery</li>
                                <li><a href="protocols-master-iot-protocols.html"><strong>Part 13:</strong> IoT Protocols</a> — MQTT, CoAP, Zigbee, LoRaWAN</li>
                                <li><a href="protocols-master-vpn-tunneling.html"><strong>Part 14:</strong> VPN & Tunneling</a> — IPsec, OpenVPN, WireGuard</li>
                                <li><a href="protocols-master-authentication-protocols.html"><strong>Part 15:</strong> Authentication Protocols</a> — OAuth, SAML, OIDC, Kerberos</li>
                                <li><a href="protocols-master-network-management.html"><strong>Part 16:</strong> Network Management</a> — SNMP, NetFlow, Syslog</li>
                                <li><a href="protocols-master-security-protocols.html"><strong>Part 17:</strong> Security Protocols</a> — TLS/SSL, certificates, PKI</li>
                                <li><a href="protocols-master-cloud-protocols.html"><strong>Part 18:</strong> Cloud Provider Protocols</a> — AWS, Azure, GCP APIs</li>
                                <li><a href="protocols-master-emerging-protocols.html"><strong>Part 19:</strong> Emerging Protocols</a> — QUIC, HTTP/3, WebTransport</li>
                                <li><a href="protocols-master-web-security-standards.html"><strong>Part 20:</strong> Web Security Standards</a> — CORS, CSP, HSTS, SRI</li>
                            </ol>
                        </div>
                    </div>

                    <h3 id="ports">Ports and Sockets</h3>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">Ports</span>
                        </div>
                        <h4>Understanding Port Numbers</h4>
                        <p>A <strong>port</strong> is a 16-bit number (0-65535) that identifies a specific application or service on a host. Combined with an IP address, it forms a <strong>socket</strong>.</p>
<pre><code class="language-bash">Socket = IP Address + Port
Example: 192.168.1.100:443

Port Ranges:
┌─────────────────┬────────────────┬─────────────────────────────────┐
│ Range           │ Type           │ Description                     │
├─────────────────┼────────────────┼─────────────────────────────────┤
│ 0 - 1023        │ Well-Known     │ Reserved for system services    │
│                 │                │ (requires root/admin)           │
├─────────────────┼────────────────┼─────────────────────────────────┤
│ 1024 - 49151    │ Registered     │ Registered with IANA for apps   │
├─────────────────┼────────────────┼─────────────────────────────────┤
│ 49152 - 65535   │ Dynamic/       │ Ephemeral ports for client      │
│                 │ Ephemeral      │ connections (auto-assigned)     │
└─────────────────┴────────────────┴─────────────────────────────────┘
</code></pre>
                    </div>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-teal text-white">Well-Known Ports</span>
                        </div>
                        <h4>Common Port Numbers</h4>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Port</th>
                                    <th>Protocol</th>
                                    <th>Service</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td>20, 21</td><td>TCP</td><td>FTP (Data, Control)</td></tr>
                                <tr><td>22</td><td>TCP</td><td>SSH</td></tr>
                                <tr><td>23</td><td>TCP</td><td>Telnet</td></tr>
                                <tr><td>25</td><td>TCP</td><td>SMTP (Email sending)</td></tr>
                                <tr><td>53</td><td>TCP/UDP</td><td>DNS</td></tr>
                                <tr><td>67, 68</td><td>UDP</td><td>DHCP (Server, Client)</td></tr>
                                <tr><td>80</td><td>TCP</td><td>HTTP</td></tr>
                                <tr><td>110</td><td>TCP</td><td>POP3 (Email retrieval)</td></tr>
                                <tr><td>143</td><td>TCP</td><td>IMAP (Email retrieval)</td></tr>
                                <tr><td>443</td><td>TCP/UDP</td><td>HTTPS / HTTP/3 (QUIC)</td></tr>
                                <tr><td>465</td><td>TCP</td><td>SMTPS (Email over TLS)</td></tr>
                                <tr><td>587</td><td>TCP</td><td>SMTP Submission</td></tr>
                                <tr><td>993</td><td>TCP</td><td>IMAPS</td></tr>
                                <tr><td>995</td><td>TCP</td><td>POP3S</td></tr>
                                <tr><td>3306</td><td>TCP</td><td>MySQL</td></tr>
                                <tr><td>3389</td><td>TCP</td><td>RDP (Remote Desktop)</td></tr>
                                <tr><td>5432</td><td>TCP</td><td>PostgreSQL</td></tr>
                                <tr><td>6379</td><td>TCP</td><td>Redis</td></tr>
                                <tr><td>8080</td><td>TCP</td><td>HTTP Alternate</td></tr>
                            </tbody>
                        </table>
                    </div>

<pre><code class="language-bash"># View listening ports on your system

# Linux
ss -tlnp          # TCP listening ports with process
ss -ulnp          # UDP listening ports
netstat -tlnp     # Alternative

# Windows
netstat -an | findstr LISTENING
netstat -ano      # With process IDs

# macOS
lsof -i -P | grep LISTEN
netstat -an | grep LISTEN

# Check what's using a specific port
# Linux
lsof -i :80
fuser 80/tcp

# Windows
netstat -ano | findstr :80
</code></pre>
                </div>

                <!-- TCP Section -->
                <div id="tcp" class="blog-content mt-5">
                    <h2><i class="fas fa-check-double me-2 text-teal"></i>TCP: Transmission Control Protocol</h2>
                    
                    <p><strong>TCP</strong> is a <strong>connection-oriented, reliable</strong> protocol that guarantees data delivery in order. It's the workhorse of the internet, carrying HTTP, email, file transfers, and more.</p>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">TCP Features</span>
                        </div>
                        <h4>Key TCP Characteristics</h4>
                        <ul>
                            <li><strong>Connection-oriented:</strong> Establishes connection before data transfer</li>
                            <li><strong>Reliable delivery:</strong> Guarantees all data arrives correctly</li>
                            <li><strong>Ordered:</strong> Data delivered in sequence</li>
                            <li><strong>Error detection:</strong> Checksum verifies integrity</li>
                            <li><strong>Flow control:</strong> Prevents overwhelming receiver</li>
                            <li><strong>Congestion control:</strong> Adapts to network conditions</li>
                            <li><strong>Full-duplex:</strong> Simultaneous bidirectional communication</li>
                            <li><strong>Byte-stream:</strong> No message boundaries (stream of bytes)</li>
                        </ul>
                    </div>

                    <h3 id="tcp-header">TCP Header Structure</h3>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-teal text-white">TCP Header</span>
                        </div>
                        <h4>TCP Segment Header (20-60 bytes)</h4>
<pre><code class="language-bash"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |       |C|E|U|A|P|R|S|F|                               |
| Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |
|       |       |R|E|G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options (if Data Offset > 5)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Key Fields:
- Source/Dest Port (16 bits each): Application endpoints
- Sequence Number (32 bits): Position of first data byte
- ACK Number (32 bits): Next expected byte from sender
- Data Offset (4 bits): Header length in 32-bit words
- Flags (9 bits): Control flags (SYN, ACK, FIN, RST, PSH, URG, etc.)
- Window (16 bits): Receive buffer space available
- Checksum (16 bits): Error detection
</code></pre>
                    </div>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">TCP Flags</span>
                        </div>
                        <h4>TCP Control Flags</h4>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Flag</th>
                                    <th>Name</th>
                                    <th>Purpose</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td>SYN</td><td>Synchronize</td><td>Initiate connection, synchronize sequence numbers</td></tr>
                                <tr><td>ACK</td><td>Acknowledgment</td><td>Acknowledges received data</td></tr>
                                <tr><td>FIN</td><td>Finish</td><td>Sender finished sending data</td></tr>
                                <tr><td>RST</td><td>Reset</td><td>Abort connection immediately</td></tr>
                                <tr><td>PSH</td><td>Push</td><td>Push data to application immediately</td></tr>
                                <tr><td>URG</td><td>Urgent</td><td>Urgent data present (use urgent pointer)</td></tr>
                                <tr><td>ECE</td><td>ECN-Echo</td><td>Congestion experienced</td></tr>
                                <tr><td>CWR</td><td>Congestion Window Reduced</td><td>Sender reduced transmission rate</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <h3 id="three-way-handshake">The Three-Way Handshake</h3>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-teal text-white">Connection Establishment</span>
                        </div>
                        <h4>TCP Connection Setup</h4>
<pre><code class="language-bash">Three-Way Handshake: SYN → SYN-ACK → ACK

    Client                              Server
       |                                   |
       |  1. SYN (seq=100)                 |
       |  "I want to connect"              |
       |---------------------------------->|
       |                                   |
       |  2. SYN-ACK (seq=300, ack=101)    |
       |  "OK, I acknowledge, let's sync"  |
       |<----------------------------------|
       |                                   |
       |  3. ACK (seq=101, ack=301)        |
       |  "Got it, connection established" |
       |---------------------------------->|
       |                                   |
       |  === CONNECTION ESTABLISHED ===   |
       |                                   |
       |  Data exchange can now begin      |
       |<=================================>|

Why Three Steps?
1. SYN: Client proposes initial sequence number (ISN)
2. SYN-ACK: Server acknowledges client's ISN, proposes its own ISN
3. ACK: Client acknowledges server's ISN

This ensures both sides agree on sequence numbers and 
prevents old duplicate connections from being accepted.
</code></pre>
                    </div>

<pre><code class="language-python"># Simulate TCP three-way handshake
import random

class TCPEndpoint:
    """Simulates TCP connection establishment"""
    
    def __init__(self, name):
        self.name = name
        self.state = "CLOSED"
        self.seq_num = random.randint(0, 2**32 - 1)  # Initial Sequence Number
        self.ack_num = 0
    
    def send_syn(self):
        """Client sends SYN"""
        self.state = "SYN_SENT"
        print(f"\n[{self.name}] Sending SYN")
        print(f"  State: CLOSED → SYN_SENT")
        print(f"  Flags: SYN=1")
        print(f"  Seq: {self.seq_num}")
        return {"type": "SYN", "seq": self.seq_num}
    
    def receive_syn_send_synack(self, syn_packet):
        """Server receives SYN, sends SYN-ACK"""
        self.state = "SYN_RECEIVED"
        self.ack_num = syn_packet["seq"] + 1
        
        print(f"\n[{self.name}] Received SYN, sending SYN-ACK")
        print(f"  State: LISTEN → SYN_RECEIVED")
        print(f"  Flags: SYN=1, ACK=1")
        print(f"  Seq: {self.seq_num}")
        print(f"  Ack: {self.ack_num}")
        
        return {"type": "SYN-ACK", "seq": self.seq_num, "ack": self.ack_num}
    
    def receive_synack_send_ack(self, synack_packet):
        """Client receives SYN-ACK, sends ACK"""
        self.state = "ESTABLISHED"
        self.ack_num = synack_packet["seq"] + 1
        self.seq_num += 1  # SYN consumes one sequence number
        
        print(f"\n[{self.name}] Received SYN-ACK, sending ACK")
        print(f"  State: SYN_SENT → ESTABLISHED")
        print(f"  Flags: ACK=1")
        print(f"  Seq: {self.seq_num}")
        print(f"  Ack: {self.ack_num}")
        
        return {"type": "ACK", "seq": self.seq_num, "ack": self.ack_num}
    
    def receive_ack(self, ack_packet):
        """Server receives ACK, connection established"""
        self.state = "ESTABLISHED"
        self.seq_num += 1
        
        print(f"\n[{self.name}] Received ACK")
        print(f"  State: SYN_RECEIVED → ESTABLISHED")
        print(f"  Connection established!")

# Simulate the handshake
print("=" * 60)
print("TCP THREE-WAY HANDSHAKE SIMULATION")
print("=" * 60)

client = TCPEndpoint("Client")
server = TCPEndpoint("Server")
server.state = "LISTEN"

# Step 1: Client → Server: SYN
syn = client.send_syn()

# Step 2: Server → Client: SYN-ACK
synack = server.receive_syn_send_synack(syn)

# Step 3: Client → Server: ACK
ack = client.receive_synack_send_ack(synack)

# Server processes ACK
server.receive_ack(ack)

print("\n" + "=" * 60)
print(f"Final States: Client={client.state}, Server={server.state}")
print("=" * 60)
</code></pre>

                    <h3 id="four-way-teardown">Connection Teardown</h3>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">Four-Way Teardown</span>
                        </div>
                        <h4>TCP Connection Termination</h4>
<pre><code class="language-bash">Four-Way Teardown: FIN → ACK → FIN → ACK

    Client                              Server
       |                                   |
       |  1. FIN (seq=500)                 |
       |  "I'm done sending"               |
       |---------------------------------->|
       |                                   |
       |  2. ACK (ack=501)                 |
       |  "Got it, but I might have more"  |
       |<----------------------------------|
       |                                   |
       |  (Server can still send data)     |
       |                                   |
       |  3. FIN (seq=700)                 |
       |  "OK, I'm also done"              |
       |<----------------------------------|
       |                                   |
       |  4. ACK (ack=701)                 |
       |  "Acknowledged, goodbye"          |
       |---------------------------------->|
       |                                   |
       |  === CONNECTION CLOSED ===        |

Why Four Steps?
- TCP is full-duplex: each direction closes independently
- After receiving FIN, host can still send pending data
- TIME_WAIT state (2*MSL) ensures all packets are gone
</code></pre>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb"></i>
                        <strong>RST vs FIN:</strong> FIN is a graceful close—both sides agree to terminate. RST is an abrupt reset—used when something's wrong (connection doesn't exist, port closed, application crash). RST doesn't require acknowledgment.
                    </div>
                </div>

                <!-- TCP Reliability Section -->
                <div id="tcp-reliability" class="blog-content mt-5">
                    <h2><i class="fas fa-shield-alt me-2 text-teal"></i>TCP Reliability Mechanisms</h2>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-teal text-white">Sequence & ACK</span>
                        </div>
                        <h4>Sequence Numbers and Acknowledgments</h4>
<pre><code class="language-bash">How TCP ensures reliable delivery:

1. Sequence Numbers: Track bytes sent
   - Each byte has a sequence number
   - ISN (Initial Sequence Number) is random for security
   
2. Acknowledgments: Confirm bytes received
   - ACK number = next expected byte
   - Cumulative: ACK 1000 means "got all bytes up to 999"

Example Data Transfer:

Client sends 1000 bytes starting at seq=1000:
┌─────────────────────────────────────────────┐
│ Seq=1000, Data=bytes 1000-1999              │
└─────────────────────────────────────────────┘
                    ↓
Server acknowledges with ACK=2000:
┌─────────────────────────────────────────────┐
│ ACK=2000 ("I've received up to byte 1999,   │
│           send me byte 2000 next")          │
└─────────────────────────────────────────────┘

3. Retransmission: If ACK not received within timeout
   - Sender retransmits the data
   - Uses exponential backoff for timeouts
</code></pre>
                    </div>

<pre><code class="language-python"># Simulate TCP reliable data transfer with retransmission
import random
import time

class ReliableTCPSender:
    """Simulates TCP reliable transmission with retransmission"""
    
    def __init__(self, loss_probability=0.2):
        self.seq_num = 0
        self.window_size = 4  # Simplified window
        self.timeout = 1.0    # Seconds
        self.loss_prob = loss_probability
        self.sent_data = {}   # seq -> (data, time_sent, retries)
    
    def send_segment(self, data, simulate_loss=True):
        """Send a segment, potentially simulating packet loss"""
        seq = self.seq_num
        self.seq_num += len(data)
        
        # Simulate network loss
        if simulate_loss and random.random() < self.loss_prob:
            print(f"  [LOST] Segment seq={seq} lost in transit!")
            return None
        
        print(f"  [SENT] Segment seq={seq}, data='{data}'")
        return {"seq": seq, "data": data, "len": len(data)}
    
    def receive_ack(self, ack_num):
        """Process acknowledgment"""
        print(f"  [ACK]  Received ACK={ack_num}")
        # Remove acknowledged data from sent buffer
        self.sent_data = {k: v for k, v in self.sent_data.items() 
                         if k >= ack_num}

def simulate_transfer():
    """Simulate reliable data transfer"""
    print("TCP Reliable Transfer Simulation")
    print("=" * 50)
    print("Sending 'HELLO' character by character with 20% loss\n")
    
    sender = ReliableTCPSender(loss_probability=0.2)
    data_to_send = list("HELLO")
    acked_up_to = 0
    max_retries = 3
    
    i = 0
    while i < len(data_to_send):
        char = data_to_send[i]
        print(f"\nAttempting to send '{char}' (byte {i}):")
        
        retries = 0
        while retries < max_retries:
            result = sender.send_segment(char)
            
            if result:
                # Simulate ACK (50% chance of ACK loss too)
                if random.random() > 0.1:  # 10% ACK loss
                    acked_up_to = result["seq"] + result["len"]
                    sender.receive_ack(acked_up_to)
                    i += 1
                    break
                else:
                    print(f"  [LOST] ACK lost! Retransmitting...")
                    retries += 1
            else:
                retries += 1
                if retries < max_retries:
                    print(f"  [RETRY] Retransmitting (attempt {retries + 1})...")
        
        if retries >= max_retries:
            print(f"  [FAIL] Max retries exceeded!")
            i += 1  # Move on (in real TCP, connection might reset)
    
    print(f"\n{'=' * 50}")
    print(f"Transfer complete! ACKed up to byte {acked_up_to}")

# Run simulation
simulate_transfer()
</code></pre>

                    <h3 id="flow-control">Flow Control: Sliding Window</h3>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">Flow Control</span>
                        </div>
                        <h4>Receiver-Based Flow Control</h4>
<pre><code class="language-bash">Flow Control prevents sender from overwhelming receiver.

Sliding Window Mechanism:
- Receiver advertises available buffer space (Window Size)
- Sender limits unacknowledged data to window size
- Window "slides" as ACKs arrive

Window Size Field: 16 bits (max 65,535 bytes)
Window Scaling Option: Allows windows up to 1 GB (shift count up to 14)

Example:

Initial: Receiver window = 4000 bytes

Sender                              Receiver (Buffer: 4000)
   |                                   |
   | Segment 1-1000 (1000 bytes)       |
   |---------------------------------->| Buffer: 3000 free
   |                                   |
   | Segment 1001-2000 (1000 bytes)    |
   |---------------------------------->| Buffer: 2000 free
   |                                   |
   | ACK=2001, Window=2000             |
   |<----------------------------------| (App consumed some)
   |                                   |
   | Segment 2001-3000 (1000 bytes)    |
   |---------------------------------->| Buffer: 1000 free
   |                                   |
   | ACK=3001, Window=3500             |
   |<----------------------------------| (App consumed more)

Zero Window: When receiver buffer is full
- Sender stops until window opens
- Sender periodically probes with Window Probe
</code></pre>
                    </div>

                    <h3 id="congestion-control">Congestion Control</h3>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-teal text-white">Congestion Control</span>
                        </div>
                        <h4>Network-Based Congestion Control</h4>
                        <p>While flow control prevents overwhelming the <em>receiver</em>, congestion control prevents overwhelming the <em>network</em>.</p>
                        <ul>
                            <li><strong>Congestion Window (cwnd):</strong> Sender's self-imposed limit</li>
                            <li><strong>Effective Window:</strong> min(cwnd, receiver window)</li>
                            <li><strong>Goal:</strong> Find optimal sending rate without causing congestion</li>
                        </ul>
                    </div>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">Congestion Algorithms</span>
                        </div>
                        <h4>TCP Congestion Control Phases</h4>
<pre><code class="language-bash">1. SLOW START
   - Initial cwnd = 1 MSS (Maximum Segment Size)
   - cwnd doubles every RTT (exponential growth)
   - Continues until ssthresh (slow start threshold)

2. CONGESTION AVOIDANCE  
   - After reaching ssthresh
   - cwnd increases by 1 MSS per RTT (linear growth)
   - "Additive Increase"

3. CONGESTION DETECTION
   - Timeout: Severe congestion
     → ssthresh = cwnd/2, cwnd = 1 MSS (back to slow start)
   - 3 Duplicate ACKs: Mild congestion (Fast Retransmit)
     → ssthresh = cwnd/2, cwnd = ssthresh (Fast Recovery)

       cwnd
        │
        │        /\
        │       /  \    ← Congestion detected
        │      /    \   
        │     /      \──────── Linear (Congestion Avoidance)
        │    /              
        │   /  ← Exponential (Slow Start)
        │  /
        │ /
        └────────────────────────── time
           ssthresh
</code></pre>
                    </div>

<pre><code class="language-python"># Visualize TCP congestion control
import matplotlib.pyplot as plt

def simulate_tcp_congestion_control(rounds=30, initial_ssthresh=16):
    """Simulate TCP Reno congestion control"""
    cwnd = 1  # Initial congestion window (MSS units)
    ssthresh = initial_ssthresh
    
    cwnd_history = [cwnd]
    ssthresh_history = [ssthresh]
    phases = ["Slow Start"]
    
    for round_num in range(1, rounds):
        # Simulate congestion event at certain points
        congestion_event = round_num in [12, 22]
        triple_dup_ack = round_num == 12  # Fast retransmit
        timeout = round_num == 22         # Timeout
        
        if congestion_event:
            if timeout:
                # Timeout: severe congestion
                ssthresh = max(cwnd // 2, 2)
                cwnd = 1  # Back to slow start
                phases.append("Timeout→SS")
            elif triple_dup_ack:
                # Fast Retransmit/Recovery
                ssthresh = max(cwnd // 2, 2)
                cwnd = ssthresh  # Fast recovery
                phases.append("3DupACK→FR")
        else:
            if cwnd < ssthresh:
                # Slow Start: exponential growth
                cwnd *= 2
                if phases[-1] != "Slow Start":
                    phases.append("Slow Start")
            else:
                # Congestion Avoidance: linear growth
                cwnd += 1
                if "Avoidance" not in phases[-1]:
                    phases.append("Cong. Avoidance")
        
        cwnd_history.append(cwnd)
        ssthresh_history.append(ssthresh)
    
    return cwnd_history, ssthresh_history, phases

# Generate data
cwnd_data, ssthresh_data, phases = simulate_tcp_congestion_control()

print("TCP Congestion Control Simulation (TCP Reno)")
print("=" * 60)
print(f"{'Round':<8} {'cwnd':<8} {'ssthresh':<10} {'Phase'}")
print("-" * 60)

phase_idx = 0
for i in range(0, len(cwnd_data), 3):  # Print every 3rd round
    phase = phases[min(phase_idx, len(phases)-1)]
    print(f"{i:<8} {cwnd_data[i]:<8} {ssthresh_data[i]:<10} {phase}")
    phase_idx += 1

print("\n" + "=" * 60)
print("Key Events:")
print("  Round 12: 3 Duplicate ACKs → Fast Retransmit/Recovery")
print("  Round 22: Timeout → Back to Slow Start")
</code></pre>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-teal text-white">Modern Algorithms</span>
                        </div>
                        <h4>Modern Congestion Control Algorithms</h4>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Algorithm</th>
                                    <th>Type</th>
                                    <th>Key Feature</th>
                                    <th>Used By</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td>Reno</td><td>Loss-based</td><td>Fast Retransmit/Recovery</td><td>Classic default</td></tr>
                                <tr><td>CUBIC</td><td>Loss-based</td><td>Cubic function growth</td><td>Linux default</td></tr>
                                <tr><td>BBR</td><td>Model-based</td><td>Bandwidth & RTT estimation</td><td>Google, YouTube</td></tr>
                                <tr><td>BBR v2</td><td>Model-based</td><td>Better fairness</td><td>Google (newer)</td></tr>
                                <tr><td>DCTCP</td><td>ECN-based</td><td>For data centers</td><td>Azure, AWS</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-rocket"></i>
                        <strong>BBR (Bottleneck Bandwidth and RTT):</strong> Developed by Google, BBR doesn't wait for packet loss to detect congestion. Instead, it continuously estimates the bottleneck bandwidth and minimum RTT, achieving higher throughput on lossy links (like satellite) and reducing bufferbloat.
                    </div>
                </div>

                <!-- TCP States Section -->
                <div id="tcp-states" class="blog-content mt-5">
                    <h2><i class="fas fa-project-diagram me-2 text-teal"></i>TCP Connection States</h2>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">State Machine</span>
                        </div>
                        <h4>TCP State Diagram</h4>
<pre><code class="language-bash">                              ┌──────────┐
                              │  CLOSED  │
                              └────┬─────┘
                    Passive Open   │   Active Open
                    (listen)       │   (connect)
                         ┌─────────┴────────┐
                         ▼                  ▼
                   ┌──────────┐        ┌──────────┐
                   │  LISTEN  │        │ SYN_SENT │
                   └────┬─────┘        └────┬─────┘
              Recv SYN  │                   │ Recv SYN-ACK
              Send SYN-ACK                  │ Send ACK
                         │                  │
                         ▼                  │
                   ┌──────────────┐         │
                   │ SYN_RECEIVED │         │
                   └──────┬───────┘         │
                 Recv ACK │                 │
                          ▼                 ▼
                   ┌─────────────────────────┐
                   │      ESTABLISHED        │
                   │   (Data Transfer)       │
                   └───────────┬─────────────┘
                               │
            ┌──────────────────┼──────────────────┐
            │ Active Close     │                  │ Passive Close
            │ Send FIN         │                  │ Recv FIN
            ▼                  │                  ▼
      ┌───────────┐           │            ┌───────────┐
      │ FIN_WAIT_1│           │            │CLOSE_WAIT │
      └─────┬─────┘           │            └─────┬─────┘
   Recv ACK │                 │                  │ Send FIN
            ▼                 │                  ▼
      ┌───────────┐           │            ┌───────────┐
      │ FIN_WAIT_2│           │            │ LAST_ACK  │
      └─────┬─────┘           │            └─────┬─────┘
   Recv FIN │                 │                  │ Recv ACK
   Send ACK │                 │                  │
            ▼                 │                  ▼
      ┌───────────┐           │            ┌──────────┐
      │ TIME_WAIT │───────────┴────────────│  CLOSED  │
      └─────┬─────┘  2*MSL timeout         └──────────┘
            │
            ▼
      ┌──────────┐
      │  CLOSED  │
      └──────────┘
</code></pre>
                    </div>

<pre><code class="language-bash"># View TCP connection states on your system

# Linux - All TCP connections with states
ss -tan
# or
netstat -tan

# Example output:
# State      Recv-Q Send-Q Local Address:Port  Peer Address:Port
# LISTEN     0      128    0.0.0.0:22          0.0.0.0:*
# ESTABLISHED 0      0     192.168.1.100:22    192.168.1.50:54321
# TIME_WAIT  0      0      192.168.1.100:80    10.0.0.5:45678

# Count connections by state
ss -tan | awk '{print $1}' | sort | uniq -c | sort -rn

# Windows
netstat -an | findstr TCP

# Watch connections in real-time (Linux)
watch -n 1 'ss -tan | head -20'
</code></pre>

                    <h3 id="tcp-timers">TCP Timers</h3>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-teal text-white">TCP Timers</span>
                        </div>
                        <h4>Important TCP Timers</h4>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Timer</th>
                                    <th>Purpose</th>
                                    <th>Typical Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Retransmission (RTO)</strong></td>
                                    <td>When to retransmit unacked segment</td>
                                    <td>Dynamic (based on RTT)</td>
                                </tr>
                                <tr>
                                    <td><strong>Persist</strong></td>
                                    <td>Probe zero-window receiver</td>
                                    <td>5-60 seconds</td>
                                </tr>
                                <tr>
                                    <td><strong>Keepalive</strong></td>
                                    <td>Check if idle connection alive</td>
                                    <td>2 hours (default)</td>
                                </tr>
                                <tr>
                                    <td><strong>TIME_WAIT (2MSL)</strong></td>
                                    <td>Ensure final ACK delivered</td>
                                    <td>60-120 seconds</td>
                                </tr>
                                <tr>
                                    <td><strong>FIN_WAIT_2</strong></td>
                                    <td>Wait for peer's FIN</td>
                                    <td>60 seconds (Linux)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle"></i>
                        <strong>TIME_WAIT Accumulation:</strong> High-traffic servers can accumulate thousands of TIME_WAIT connections. Solutions:
                        <ul class="mb-0 mt-2">
                            <li><code>tcp_tw_reuse</code>: Allow reusing TIME_WAIT sockets for outgoing connections</li>
                            <li>Connection pooling: Reuse established connections</li>
                            <li>Load balancing: Distribute connections across servers</li>
                        </ul>
                    </div>
                </div>

                <!-- UDP Section -->
                <div id="udp" class="blog-content mt-5">
                    <h2><i class="fas fa-bolt me-2 text-teal"></i>UDP: User Datagram Protocol</h2>

                    <p><strong>UDP</strong> is a <strong>connectionless, unreliable</strong> protocol that trades reliability for speed and simplicity.</p>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">UDP Characteristics</span>
                        </div>
                        <h4>UDP Key Features</h4>
                        <ul>
                            <li><strong>Connectionless:</strong> No handshake, just send</li>
                            <li><strong>Unreliable:</strong> No delivery guarantee, no retransmission</li>
                            <li><strong>Unordered:</strong> Packets may arrive out of order</li>
                            <li><strong>No flow/congestion control:</strong> Sender can blast data</li>
                            <li><strong>Message-oriented:</strong> Preserves message boundaries</li>
                            <li><strong>Low overhead:</strong> Only 8-byte header</li>
                            <li><strong>Supports multicast/broadcast:</strong> One-to-many delivery</li>
                        </ul>
                    </div>

                    <h3 id="udp-header">UDP Header Structure</h3>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-teal text-white">UDP Header</span>
                        </div>
                        <h4>UDP Datagram Header (8 bytes)</h4>
<pre><code class="language-bash"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |           Checksum            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Only 4 fields (compare to TCP's 10+):
- Source Port (16 bits): Sending application
- Destination Port (16 bits): Receiving application
- Length (16 bits): Header + Data length
- Checksum (16 bits): Optional in IPv4, mandatory in IPv6

Maximum UDP payload: 65,535 - 8 (UDP) - 20 (IP) = 65,507 bytes
Practical limit (MTU): ~1472 bytes (to avoid fragmentation)
</code></pre>
                    </div>

                    <h3 id="udp-use-cases">When to Use UDP</h3>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">Use Cases</span>
                        </div>
                        <h4>UDP is Perfect For:</h4>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Application</th>
                                    <th>Why UDP?</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>DNS</strong></td>
                                    <td>Small queries, fast responses needed. TCP fallback for large responses.</td>
                                </tr>
                                <tr>
                                    <td><strong>DHCP</strong></td>
                                    <td>Client doesn't have IP yet, needs broadcast.</td>
                                </tr>
                                <tr>
                                    <td><strong>VoIP/Video Calls</strong></td>
                                    <td>Real-time; late packets are useless. Better to skip than wait.</td>
                                </tr>
                                <tr>
                                    <td><strong>Online Gaming</strong></td>
                                    <td>Low latency critical. Old positions don't matter.</td>
                                </tr>
                                <tr>
                                    <td><strong>Live Streaming</strong></td>
                                    <td>Buffering > retransmission. Occasional drops acceptable.</td>
                                </tr>
                                <tr>
                                    <td><strong>IoT/Sensors</strong></td>
                                    <td>Simple devices, frequent updates. Loss of one reading okay.</td>
                                </tr>
                                <tr>
                                    <td><strong>SNMP</strong></td>
                                    <td>Network monitoring should be lightweight.</td>
                                </tr>
                                <tr>
                                    <td><strong>TFTP</strong></td>
                                    <td>Simple file transfer with app-level ACKs.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

<pre><code class="language-python"># Simple UDP client and server in Python
import socket

# UDP Server
def udp_server(host='127.0.0.1', port=12345):
    """Simple UDP echo server"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((host, port))
    
    print(f"UDP Server listening on {host}:{port}")
    
    while True:
        data, addr = sock.recvfrom(1024)
        print(f"Received from {addr}: {data.decode()}")
        
        # Echo back
        response = f"Echo: {data.decode()}"
        sock.sendto(response.encode(), addr)

# UDP Client
def udp_client(message, host='127.0.0.1', port=12345):
    """Simple UDP client"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    try:
        # No connection needed - just send!
        sock.sendto(message.encode(), (host, port))
        print(f"Sent: {message}")
        
        # Wait for response (with timeout)
        sock.settimeout(2.0)
        data, addr = sock.recvfrom(1024)
        print(f"Received: {data.decode()}")
        
    except socket.timeout:
        print("No response (timeout)")
    finally:
        sock.close()

# Example usage (run server in one terminal, client in another):
print("UDP Example Code")
print("=" * 50)
print("Server: udp_server()")
print("Client: udp_client('Hello UDP!')")
print("\nNote: UDP is fire-and-forget - no connection setup!")
</code></pre>
                </div>

                <!-- QUIC Section -->
                <div id="quic" class="blog-content mt-5">
                    <h2><i class="fas fa-rocket me-2 text-teal"></i>QUIC: The Future of Transport</h2>

                    <p><strong>QUIC (Quick UDP Internet Connections)</strong> is a modern transport protocol developed by Google and standardized by the IETF. It runs over UDP but provides TCP-like reliability with better performance.</p>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">Why QUIC?</span>
                        </div>
                        <h4>Problems QUIC Solves</h4>
                        <ul>
                            <li><strong>Head-of-line blocking:</strong> In TCP, one lost packet blocks all streams. QUIC multiplexes independent streams.</li>
                            <li><strong>Slow connection setup:</strong> TCP + TLS = 2-3 RTTs. QUIC combines them into 1 RTT (0-RTT for repeat visits).</li>
                            <li><strong>Ossification:</strong> TCP can't evolve because middleboxes expect specific formats. QUIC is encrypted and flexible.</li>
                            <li><strong>Connection migration:</strong> TCP connections break on IP change. QUIC uses connection IDs for seamless mobility.</li>
                        </ul>
                    </div>

                    <h3 id="quic-features">QUIC Features</h3>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-teal text-white">Key Features</span>
                        </div>
                        <h4>QUIC Architecture</h4>
<pre><code class="language-bash">Traditional Stack vs QUIC Stack:

Traditional:              QUIC:
┌─────────────┐          ┌─────────────┐
│    HTTP/2   │          │   HTTP/3    │
├─────────────┤          ├─────────────┤
│     TLS     │          │    QUIC     │ ← Combines transport + 
├─────────────┤          │  (over UDP) │   encryption + multiplexing
│     TCP     │          ├─────────────┤
├─────────────┤          │     UDP     │
│     IP      │          ├─────────────┤
└─────────────┘          │     IP      │
                         └─────────────┘

QUIC Advantages:
┌────────────────────────────────────────────────────────────┐
│ Feature              │ TCP+TLS         │ QUIC             │
├──────────────────────┼─────────────────┼──────────────────┤
│ Connection setup     │ 2-3 RTT         │ 1 RTT (0-RTT)    │
│ Encryption           │ Optional        │ Always on        │
│ Stream multiplexing  │ App layer       │ Native           │
│ Head-of-line block   │ Yes             │ Per-stream only  │
│ Connection migration │ No              │ Yes              │
│ Packet pacing        │ Kernel          │ User space       │
└──────────────────────┴─────────────────┴──────────────────┘
</code></pre>
                    </div>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">Connection Setup</span>
                        </div>
                        <h4>QUIC 0-RTT and 1-RTT Connection</h4>
<pre><code class="language-bash">First Connection (1-RTT):

Client                              Server
   |                                   |
   | INITIAL (ClientHello + QUIC)      |
   |---------------------------------->| 
   |                                   |
   | INITIAL (ServerHello + QUIC)      |
   | HANDSHAKE (Encrypted Extensions)  |
   |<----------------------------------|
   |                                   |
   | HANDSHAKE (Finished)              |
   | + APPLICATION DATA                | ← Data in 1 RTT!
   |---------------------------------->|
   |                                   |

Repeat Connection (0-RTT):

Client                              Server
   |                                   |
   | INITIAL + 0-RTT DATA              | ← Data immediately!
   |---------------------------------->| (using cached keys)
   |                                   |
   | INITIAL + HANDSHAKE + 1-RTT DATA  |
   |<----------------------------------|
   |                                   |

0-RTT allows sending data before handshake completes
(slight replay attack risk, use for idempotent requests)
</code></pre>
                    </div>

                    <h3 id="quic-vs-tcp">QUIC vs TCP Comparison</h3>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-teal text-white">Comparison</span>
                        </div>
                        <h4>Detailed QUIC vs TCP</h4>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>TCP</th>
                                    <th>QUIC</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Underlying Protocol</td>
                                    <td>Native (kernel)</td>
                                    <td>Over UDP (user space)</td>
                                </tr>
                                <tr>
                                    <td>Encryption</td>
                                    <td>Separate (TLS)</td>
                                    <td>Integrated (TLS 1.3)</td>
                                </tr>
                                <tr>
                                    <td>Streams</td>
                                    <td>Single ordered stream</td>
                                    <td>Multiple independent streams</td>
                                </tr>
                                <tr>
                                    <td>Connection ID</td>
                                    <td>4-tuple (IPs + ports)</td>
                                    <td>Connection ID (survives IP change)</td>
                                </tr>
                                <tr>
                                    <td>Header</td>
                                    <td>Visible to middleboxes</td>
                                    <td>Encrypted (prevents ossification)</td>
                                </tr>
                                <tr>
                                    <td>Congestion Control</td>
                                    <td>Kernel implementation</td>
                                    <td>User space (easy to update)</td>
                                </tr>
                                <tr>
                                    <td>Deployment</td>
                                    <td>Universal</td>
                                    <td>Growing (Google, Cloudflare, Meta)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

<pre><code class="language-bash"># Check if a website supports HTTP/3 (QUIC)

# Using curl (if compiled with HTTP/3 support)
curl --http3 -I https://www.google.com

# Using online tools:
# https://http3check.net/
# https://www.http3check.com/

# Check Alt-Svc header (advertises HTTP/3 support)
curl -sI https://www.google.com | grep -i alt-svc
# Output: alt-svc: h3=":443"; ma=2592000

# In browser DevTools:
# Network tab → Protocol column shows "h3" for HTTP/3

# Chrome flags to enable/test QUIC:
# chrome://flags/#enable-quic
</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-globe"></i>
                        <strong>HTTP/3 Adoption:</strong> As of 2024, ~30% of web traffic uses HTTP/3 (QUIC). Major adopters include Google (YouTube, Search), Facebook, Cloudflare, and most CDNs. Check your favorite sites with the tools above!
                    </div>
                </div>

                <!-- Comparison Section -->
                <div id="comparison" class="blog-content mt-5">
                    <h2><i class="fas fa-balance-scale me-2 text-teal"></i>Protocol Comparison</h2>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">Summary</span>
                        </div>
                        <h4>TCP vs UDP vs QUIC</h4>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Feature</th>
                                    <th>TCP</th>
                                    <th>UDP</th>
                                    <th>QUIC</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Connection</td>
                                    <td>Required (3-way)</td>
                                    <td>None</td>
                                    <td>Required (1-RTT)</td>
                                </tr>
                                <tr>
                                    <td>Reliability</td>
                                    <td>✅ Guaranteed</td>
                                    <td>❌ None</td>
                                    <td>✅ Guaranteed</td>
                                </tr>
                                <tr>
                                    <td>Ordering</td>
                                    <td>✅ Ordered</td>
                                    <td>❌ Unordered</td>
                                    <td>✅ Per-stream</td>
                                </tr>
                                <tr>
                                    <td>Flow Control</td>
                                    <td>✅ Yes</td>
                                    <td>❌ No</td>
                                    <td>✅ Yes</td>
                                </tr>
                                <tr>
                                    <td>Congestion Control</td>
                                    <td>✅ Yes</td>
                                    <td>❌ No</td>
                                    <td>✅ Yes (pluggable)</td>
                                </tr>
                                <tr>
                                    <td>Header Size</td>
                                    <td>20-60 bytes</td>
                                    <td>8 bytes</td>
                                    <td>Variable (encrypted)</td>
                                </tr>
                                <tr>
                                    <td>Encryption</td>
                                    <td>Optional (TLS)</td>
                                    <td>None built-in</td>
                                    <td>✅ Mandatory</td>
                                </tr>
                                <tr>
                                    <td>Multiplexing</td>
                                    <td>Application layer</td>
                                    <td>None</td>
                                    <td>✅ Native streams</td>
                                </tr>
                                <tr>
                                    <td>Best For</td>
                                    <td>Web, email, files</td>
                                    <td>Gaming, VoIP, DNS</td>
                                    <td>Modern web, mobile</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb"></i>
                        <strong>Choosing a Protocol:</strong>
                        <ul class="mb-0 mt-2">
                            <li><strong>Use TCP</strong> when you need reliable, ordered delivery and broad compatibility</li>
                            <li><strong>Use UDP</strong> when speed matters more than reliability (real-time, lossy-tolerant)</li>
                            <li><strong>Use QUIC</strong> for modern web applications needing fast, encrypted, multiplexed connections</li>
                        </ul>
                    </div>
                </div>

                <!-- Hands-On Section -->
                <div id="hands-on" class="blog-content mt-5">
                    <h2><i class="fas fa-laptop-code me-2 text-teal"></i>Hands-On Exercises</h2>

                    <h3>Exercise 1: TCP Socket Programming</h3>

<pre><code class="language-python"># Complete TCP client-server example
import socket
import threading

def tcp_server(host='127.0.0.1', port=9999):
    """TCP Echo Server with connection handling"""
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((host, port))
    server.listen(5)
    
    print(f"TCP Server listening on {host}:{port}")
    print("States: CLOSED → LISTEN")
    
    while True:
        client_socket, addr = server.accept()
        print(f"\nConnection from {addr}")
        print("States: LISTEN → SYN_RECEIVED → ESTABLISHED")
        
        # Handle client in thread
        thread = threading.Thread(
            target=handle_client, 
            args=(client_socket, addr)
        )
        thread.start()

def handle_client(client_socket, addr):
    """Handle individual client connection"""
    try:
        while True:
            data = client_socket.recv(1024)
            if not data:
                break
            
            message = data.decode()
            print(f"Received from {addr}: {message}")
            
            # Echo back with modification
            response = f"Server received: {message}"
            client_socket.send(response.encode())
    except ConnectionResetError:
        print(f"Connection reset by {addr}")
    finally:
        print(f"Closing connection with {addr}")
        print("States: ESTABLISHED → FIN_WAIT/CLOSE_WAIT → CLOSED")
        client_socket.close()

def tcp_client(messages, host='127.0.0.1', port=9999):
    """TCP Client with multiple messages"""
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    print(f"Connecting to {host}:{port}")
    print("States: CLOSED → SYN_SENT → ESTABLISHED")
    
    client.connect((host, port))
    
    try:
        for msg in messages:
            print(f"\nSending: {msg}")
            client.send(msg.encode())
            
            response = client.recv(1024)
            print(f"Received: {response.decode()}")
    finally:
        print("\nClosing connection")
        print("States: ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED")
        client.close()

# Example usage
print("TCP Socket Programming Example")
print("=" * 50)
print("1. Run server:  tcp_server()")
print("2. Run client:  tcp_client(['Hello', 'World', 'TCP'])")
print("\nThe server handles multiple clients concurrently.")
</code></pre>

                    <h3 id="packet-analysis">Exercise 2: Packet Analysis with Scapy</h3>

<pre><code class="language-python"># Analyze TCP packets with Scapy (requires: pip install scapy)
# Note: Requires root/admin privileges

try:
    from scapy.all import IP, TCP, UDP, sr1, send, sniff
    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False
    print("Scapy not installed. Install with: pip install scapy")

def analyze_tcp_flags(packet):
    """Analyze TCP flags in a packet"""
    if not SCAPY_AVAILABLE:
        return
    
    flags = {
        'F': 'FIN',
        'S': 'SYN', 
        'R': 'RST',
        'P': 'PSH',
        'A': 'ACK',
        'U': 'URG',
        'E': 'ECE',
        'C': 'CWR'
    }
    
    if TCP in packet:
        tcp = packet[TCP]
        print(f"Source Port: {tcp.sport}")
        print(f"Dest Port: {tcp.dport}")
        print(f"Seq: {tcp.seq}")
        print(f"Ack: {tcp.ack}")
        print(f"Window: {tcp.window}")
        
        # Parse flags
        flag_str = str(tcp.flags)
        active_flags = [flags.get(f, f) for f in flag_str]
        print(f"Flags: {', '.join(active_flags)}")

def craft_syn_packet(target_ip, target_port):
    """Craft a TCP SYN packet (educational purposes)"""
    if not SCAPY_AVAILABLE:
        print("Example SYN packet structure:")
        print("  IP(dst='target') / TCP(dport=80, flags='S')")
        return None
    
    # Create IP layer
    ip = IP(dst=target_ip)
    
    # Create TCP layer with SYN flag
    tcp = TCP(dport=target_port, flags='S', seq=1000)
    
    # Combine layers
    packet = ip / tcp
    
    print("Crafted SYN Packet:")
    print(f"  Destination: {target_ip}:{target_port}")
    print(f"  Flags: SYN")
    print(f"  Seq: 1000")
    
    return packet

# Example without running (for safety)
print("TCP Packet Crafting Example (Scapy)")
print("=" * 50)
print("Note: Actually sending packets requires root privileges")
print("\nExample code to send SYN and receive SYN-ACK:")
print("""
from scapy.all import IP, TCP, sr1

# Craft SYN packet
syn = IP(dst='example.com') / TCP(dport=80, flags='S')

# Send and wait for response
syn_ack = sr1(syn, timeout=2)

# Analyze response
if syn_ack and syn_ack[TCP].flags == 'SA':
    print('Received SYN-ACK!')
    print(f'Server seq: {syn_ack[TCP].seq}')
""")
</code></pre>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-crimson text-white">Self-Assessment</span>
                        </div>
                        <h4>Quiz: Test Your Knowledge</h4>
                        <ol>
                            <li>What are the three steps in TCP connection establishment? <em>(SYN, SYN-ACK, ACK)</em></li>
                            <li>What's the size of UDP header? <em>(8 bytes)</em></li>
                            <li>What TCP flag gracefully closes a connection? <em>(FIN)</em></li>
                            <li>What port range is "well-known"? <em>(0-1023)</em></li>
                            <li>What does cwnd stand for? <em>(Congestion Window)</em></li>
                            <li>Why does QUIC use UDP underneath? <em>(To bypass middlebox ossification)</em></li>
                            <li>What timer keeps TCP from sending to a full buffer? <em>(Persist timer)</em></li>
                            <li>What's the TIME_WAIT duration formula? <em>(2 × MSL)</em></li>
                        </ol>
                    </div>
                </div>

                <!-- Summary Section -->
                <div id="summary" class="blog-content mt-5">
                    <h2><i class="fas fa-check-circle me-2 text-teal"></i>Summary & Next Steps</h2>

                    <div class="highlight-box">
                        <i class="fas fa-graduation-cap"></i>
                        <strong>Key Takeaways:</strong>
                        <ul class="mt-2 mb-0">
                            <li><strong>Ports</strong> identify applications; <strong>sockets</strong> = IP + port</li>
                            <li><strong>TCP</strong> provides reliable, ordered, connection-oriented delivery</li>
                            <li><strong>Three-way handshake:</strong> SYN → SYN-ACK → ACK establishes connection</li>
                            <li><strong>Flow control</strong> prevents overwhelming receiver; <strong>congestion control</strong> protects network</li>
                            <li><strong>UDP</strong> is fast and simple but unreliable—great for real-time apps</li>
                            <li><strong>QUIC</strong> combines TCP reliability with UDP flexibility, built-in encryption</li>
                            <li><strong>HTTP/3</strong> uses QUIC—the future of web transport</li>
                        </ul>
                    </div>

                    <div class="experiment-card">
                        <div class="card-meta mb-2">
                            <span class="badge bg-teal text-white">Quick Reference</span>
                        </div>
                        <h4>Transport Layer Cheat Sheet</h4>
                        <ul>
                            <li><strong>TCP:</strong> Reliable, ordered, connection-oriented (HTTP, SSH, email)</li>
                            <li><strong>UDP:</strong> Fast, simple, connectionless (DNS, VoIP, gaming)</li>
                            <li><strong>QUIC:</strong> Modern, encrypted, multiplexed (HTTP/3)</li>
                            <li><strong>Well-known ports:</strong> 0-1023 (HTTP=80, HTTPS=443, SSH=22)</li>
                            <li><strong>Ephemeral ports:</strong> 49152-65535 (client connections)</li>
                        </ul>
                    </div>

                    <div class="series-next">
                        <h4><i class="fas fa-arrow-right me-2"></i>Next in the Series</h4>
                        <p>In <a href="protocols-master-session-presentation.html"><strong>Part 5: Session & Presentation Layers</strong></a>, we'll explore TLS/SSL encryption, the TLS handshake, certificates, data serialization formats (JSON, XML, Protocol Buffers), and compression—everything between transport and application.</p>
                    </div>
                </div>

                <!-- Related Articles -->
                <div id="related" class="blog-content mt-5">
                    <h2><i class="fas fa-book-reader me-2 text-teal"></i>Continue the Series</h2>

                    <div class="related-posts">
                        <h3><i class="fas fa-arrow-right me-2"></i>Navigation</h3>
                        <div class="related-post-item">
                            <h5>Part 3: Network Layer & IP</h5>
                            <p>Review IPv4, IPv6, subnetting, and routing fundamentals.</p>
                            <a href="protocols-master-network-layer.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5>Part 5: Session & Presentation Layers</h5>
                            <p>Explore TLS, encryption, certificates, and data formats.</p>
                            <a href="protocols-master-session-presentation.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5>Part 6: Web Protocols</h5>
                            <p>Deep dive into HTTP/1.1, HTTP/2, HTTP/3, and WebSockets.</p>
                            <a href="protocols-master-web-protocols.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">
                        I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.
                    </p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest"><i class="fab fa-pinterest-p"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small">
                        <i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a>
                    </p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">
                        Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!
                    </p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Scroll-to-Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    <div id="categoryIndicator" class="category-indicator"></div>
    
    <!-- Cookie Consent JS -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>

    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
</body>
</html>
