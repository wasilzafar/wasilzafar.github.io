<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master Binary Search Trees, AVL Trees, and Red-Black Trees for FAANG interviews. Complete guide with Python implementations, rotations, balancing algorithms, and LeetCode problems.">
    <meta name="keywords" content="binary search tree, BST, AVL tree, red-black tree, tree rotations, self-balancing trees, Python BST, data structures, FAANG interview, LeetCode">
    <meta name="author" content="Wasil Zafar">
    
    <!-- Open Graph / Social Media -->
    <meta property="og:title" content="DSA Part 10: BST & Balanced Trees - AVL & Red-Black | Wasil Zafar">
    <meta property="og:description" content="Complete guide to Binary Search Trees and self-balancing trees for technical interviews.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://wasilzafar.com/pag../series/data-structures/dsa-bst-avl-redblack.html">
    <meta property="article:published_time" content="2026-01-28">
    <meta property="article:author" content="Wasil Zafar">
    <meta property="article:section" content="Technology">
    
    <title>DSA Part 10: BST & Balanced Trees - AVL & Red-Black | Wasil Zafar</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../../../images/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Prism.js Syntax Highlighting - Multiple Themes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css">
    
    <!-- Main CSS -->
    <link rel="stylesheet" href="../../../css/main.css">

    <!-- Google tag (gtag.js) - Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        
        // Set default consent state BEFORE loading GTM
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'functionality_storage': 'granted',
            'personalization_storage': 'denied',
            'security_storage': 'granted',
            'wait_for_update': 500
        });
        
        // Set ads_data_redaction when ad_storage is denied
        gtag('set', 'ads_data_redaction', true);
        
        // Set URL passthrough for conversion modeling
        gtag('set', 'url_passthrough', true);
    </script>
    
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-PBS8M2JR');</script>
    
    <style>
        :root {
            --color-crimson: #BF092F;
            --color-navy: #132440;
            --color-blue: #16476A;
            --color-teal: #3B9797;
            --color-light: #f8f9fa;
            --color-white: #ffffff;
        }
        
        /* Blog Hero Section */
        .blog-hero {
            background: linear-gradient(135deg, var(--color-navy) 0%, var(--color-blue) 100%);
            color: white;
            padding: 80px 0;
        }
        
        .blog-meta {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            font-size: 0.95rem;
            color: var(--color-teal);
            margin-bottom: 1rem;
        }
        
        .reading-time {
            display: inline-block;
            background: var(--color-crimson);
            color: white;
            padding: 0.3rem 0.8rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .back-link {
            display: inline-block;
            color: white;
            text-decoration: none;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
            opacity: 0.9;
        }
        .back-link:hover {
            color: var(--color-teal);
            opacity: 1;
            transform: translateX(-5px);
        }
        
        .print-btn {
            background: var(--color-teal);
            color: white;
            border: none;
            padding: 0.4rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .print-btn:hover {
            background: var(--color-crimson);
            transform: translateY(-1px);
        }
        
        /* Blog Content */
        .blog-content {
            max-width: 900px;
            margin: 0 auto;
            font-size: 1.05rem;
            line-height: 1.8;
            color: #333;
        }
        .blog-content h2 {
            font-size: 1.8rem;
            font-weight: 700;
            margin-top: 2.5rem;
            margin-bottom: 1.5rem;
            color: var(--color-navy);
            border-bottom: 3px solid var(--color-teal);
            padding-bottom: 0.5rem;
        }
        .blog-content h3 {
            font-size: 1.3rem;
            font-weight: 600;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: var(--color-blue);
        }
        .blog-content h4 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--color-crimson);
        }
        .blog-content p {
            margin-bottom: 1.2rem;
            text-align: justify;
        }
        .blog-content strong {
            color: var(--color-crimson);
        }
        
        .highlight-box {
            background: linear-gradient(135deg, rgba(59, 151, 151, 0.1) 0%, rgba(22, 71, 106, 0.1) 100%);
            border-left: 4px solid var(--color-teal);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        .highlight-box h4 {
            color: var(--color-navy);
            margin-top: 0;
            margin-bottom: 0.75rem;
        }
        
        .experiment-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            border: 1px solid #e0e0e0;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .experiment-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
        }
        
        .experiment-card h4 {
            color: var(--color-crimson);
            margin-top: 0;
        }
        
        /* Code Block Styling */
        pre[class*="language-"] {
            border-radius: 8px;
            margin: 1.5rem 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        code:not([class*="language-"]) {
            background: rgba(59, 151, 151, 0.15);
            color: var(--color-navy);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
        }
        
        /* Toolbar styling */
        div.code-toolbar > .toolbar {
            opacity: 1;
            display: flex;
            gap: 0.5rem;
        }
        
        div.code-toolbar > .toolbar > .toolbar-item > button {
            background: var(--color-teal);
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        div.code-toolbar > .toolbar > .toolbar-item > button:hover {
            background: var(--color-blue);
            transform: translateY(-1px);
        }
        
        div.code-toolbar > .toolbar > .toolbar-item > select {
            background: var(--color-navy);
            color: white;
            border: 1px solid var(--color-teal);
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        div.code-toolbar > .toolbar > .toolbar-item > select:hover {
            background: var(--color-blue);
            border-color: var(--color-crimson);
        }
        
        div.code-toolbar > .toolbar > .toolbar-item > select option {
            background: var(--color-navy);
            color: white;
        }
        
        /* Side Navigation TOC */
        .toc-toggle-btn {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            width: 50px;
            height: 50px;
            background: var(--color-teal);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 151, 151, 0.4);
            transition: all 0.3s ease;
            z-index: 1049;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .toc-toggle-btn:hover {
            background: var(--color-crimson);
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(191, 9, 47, 0.5);
        }

        .toc-toggle-btn:active {
            transform: scale(0.95);
        }
        
        .sidenav-toc {
            height: calc(100% - 64px);
            width: 0;
            position: fixed;
            z-index: 1050;
            top: 64px;
            left: 0;
            background: linear-gradient(135deg, var(--color-navy) 0%, var(--color-blue) 100%);
            overflow-x: hidden;
            overflow-y: auto;
            transition: width 0.4s ease;
            padding-top: 30px;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3);
        }
        
        .sidenav-toc.open {
            width: 350px;
        }
        
        .sidenav-toc .toc-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 30px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--color-teal);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .sidenav-toc.open .toc-header {
            opacity: 1;
            visibility: visible;
        }
        
        .sidenav-toc .closebtn {
            font-size: 32px;
            color: white;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .sidenav-toc .closebtn:hover {
            color: var(--color-crimson);
            transform: rotate(90deg);
        }
        
        .sidenav-toc h3 {
            color: white;
            margin: 0;
            font-weight: 700;
            font-size: 1.3rem;
        }
        
        .sidenav-toc ol {
            list-style: decimal;
            padding: 0 30px;
            margin: 0;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .sidenav-toc ol li {
            margin-bottom: 8px;
        }
        
        .sidenav-toc a {
            padding: 12px 30px;
            text-decoration: none;
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.85);
            display: block;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
        }
        
        .sidenav-toc a:hover {
            color: white;
            background: rgba(59, 151, 151, 0.2);
            border-left-color: var(--color-teal);
            padding-left: 35px;
        }
        
        .sidenav-toc a.active {
            color: white;
            background: rgba(191, 9, 47, 0.3);
            border-left-color: var(--color-crimson);
            font-weight: 600;
        }
        
        .sidenav-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1049;
        }
        
        .sidenav-overlay.show {
            display: block;
        }
        
        /* Scroll to Top Button */
        .scroll-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            background: var(--color-teal);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(59, 151, 151, 0.3);
            z-index: 999;
        }
        
        .scroll-to-top.show {
            opacity: 1;
            visibility: visible;
        }
        
        .scroll-to-top:hover {
            background: var(--color-crimson);
            transform: translateY(-3px);
        }
        
        /* Related Posts / Continue the Series */
        .related-posts {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 2rem;
            margin-top: 3rem;
        }
        .related-posts h3 { color: var(--color-navy); margin-bottom: 1.5rem; }
        .related-post-item {
            padding: 1rem;
            border-left: 3px solid var(--color-teal);
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }
        .related-post-item:hover { background: white; border-left-color: var(--color-crimson); }
        .related-post-item a { color: var(--color-blue); text-decoration: none; font-weight: 600; }
        .related-post-item a:hover { color: var(--color-crimson); }
        
        /* Badge Styles */
        .badge-easy {
            background: #28a745;
            color: white;
        }
        
        .badge-medium {
            background: #ffc107;
            color: #333;
        }
        
        .badge-hard {
            background: #dc3545;
            color: white;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .sidenav-toc.open {
                width: 280px;
            }
            
            .toc-toggle-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
                left: 1rem;
                bottom: 1rem;
            }
            
            .scroll-to-top {
                bottom: 1rem;
                right: 1rem;
                width: 45px;
                height: 45px;
            }
        }
        
        html {
            scroll-behavior: smooth;
        }
        
        /* Print Styles */
        @media print {
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            nav, .navbar, footer, .back-link, .related-posts,
            .scroll-to-top, .print-btn, .toc-toggle-btn,
            .sidenav-toc, .sidenav-overlay {
                display: none !important;
            }
            
            body {
                font-size: 12pt;
                line-height: 1.6;
            }
            
            .container {
                max-width: 100%;
                padding: 0;
            }
            
            h1, h2, h3, h4, h5, h6 {
                page-break-after: avoid;
            }
            
            pre {
                page-break-inside: avoid;
                border: 1px solid #ddd !important;
            }
            
            .highlight-box, .experiment-card {
                page-break-inside: avoid;
            }
        }
        /* Category Indicator */
        .category-indicator {
            position: fixed;
            bottom: 2rem;
            right: 6.5rem;
            background: var(--color-navy);
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 600;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(19, 36, 64, 0.3);
            z-index: 998;
            max-width: 150px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .category-indicator.show {
            opacity: 1;
            visibility: visible;
        }

        .category-indicator i {
            margin-right: 0.5rem;
            color: var(--color-teal);
        }

        @media (max-width: 768px) {
            .category-indicator {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/">
                <span class="gradient-text">Wasil Zafar</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#about">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#skills">Skills</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#certifications">Certifications</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#interests">Interests</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- TOC Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation TOC -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close">&times;</button>
        </div>
        <ol>
            <li><a href="#introduction" onclick="closeNav()">Introduction to BST</a></li>
            <li><a href="#bst-operations" onclick="closeNav()">BST Operations</a></li>
            <li><a href="#bst-validation" onclick="closeNav()">BST Validation</a></li>
            <li><a href="#avl-trees" onclick="closeNav()">AVL Trees</a></li>
            <li><a href="#avl-rotations" onclick="closeNav()">AVL Rotations</a></li>
            <li><a href="#red-black-trees" onclick="closeNav()">Red-Black Trees</a></li>
            <li><a href="#comparison" onclick="closeNav()">Tree Comparison</a></li>
            <li><a href="#interview-patterns" onclick="closeNav()">Interview Patterns</a></li>
            <li><a href="#leetcode" onclick="closeNav()">LeetCode Problems</a></li>
            <li><a href="#series-nav" onclick="closeNav()">Complete Series</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link">
                    <i class="fas fa-arrow-left me-2"></i>Back to Technology
                </a>
                <h1 class="display-4 fw-bold mb-3">DSA Part 10: BST & Balanced Trees</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>January 28, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>25 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
                <p class="lead">Master Binary Search Trees, AVL Trees, and Red-Black Trees with complete Python implementations, rotation algorithms, and balancing strategies for FAANG interviews.</p>
            </div>
        </div>
    </section>

    <!-- Blog Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">
                    <div class="blog-content">
                        
                        <!-- Introduction -->
                        <h2 id="introduction"><i class="fas fa-tree me-2"></i>Introduction to Binary Search Trees</h2>
                        
                        <p>A <strong>Binary Search Tree (BST)</strong> is a binary tree with an ordering property: for every node, all values in the left subtree are smaller, and all values in the right subtree are larger. This property enables efficient O(log n) average-case operations.</p>
                        
                        <div class="highlight-box">
                            <h4><i class="fas fa-lightbulb me-2"></i>BST Property</h4>
                            <p>For every node N: <code>left_subtree_values < N.val < right_subtree_values</code></p>
                            <p>This invariant must hold for the entire subtree, not just immediate children!</p>
                        </div>

                        <div class="experiment-card">
                            <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                            <div class="mb-2">
                                <span class="badge bg-teal me-2">12-Part Series</span>
                                <span class="badge bg-crimson">FAANG Interview Prep</span>
                            </div>
                            <ol>
                                <li><a href="dsa-foundations-memory-complexity.html">Foundations, Memory & Complexity</a></li>
                                <li><a href="dsa-recursion-complete-guide.html">Recursion Complete Guide</a></li>
                                <li><a href="dsa-arrays-adt-operations.html">Arrays & Array ADT</a></li>
                                <li><a href="dsa-strings-manipulation.html">Strings</a></li>
                                <li><a href="dsa-matrices-special-sparse.html">Matrices</a></li>
                                <li><a href="dsa-linked-lists-guide.html">Linked Lists</a></li>
                                <li><a href="dsa-stack-applications.html">Stack</a></li>
                                <li><a href="dsa-queue-implementations.html">Queue</a></li>
                                <li><a href="dsa-trees-fundamentals.html">Trees</a></li>
                                <li><strong>BST & Balanced Trees (This Guide)</strong></li>
                                <li><a href="dsa-heaps-sorting-hashing.html">Heaps, Sorting & Hashing</a></li>
                                <li><a href="dsa-graphs-dp-greedy-backtracking.html">Graphs, DP, Greedy & Backtracking</a></li>
                            </ol>
                        </div>

                        <h3>BST Node Structure</h3>
                        
<pre><code class="language-python">class TreeNode:
    """Binary Search Tree Node"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BinarySearchTree:
    """Binary Search Tree implementation"""
    def __init__(self):
        self.root = None
    
    def insert(self, val):
        """Insert a value into the BST"""
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert_recursive(self.root, val)
    
    def _insert_recursive(self, node, val):
        """Helper for recursive insertion"""
        if val < node.val:
            if node.left is None:
                node.left = TreeNode(val)
            else:
                self._insert_recursive(node.left, val)
        else:
            if node.right is None:
                node.right = TreeNode(val)
            else:
                self._insert_recursive(node.right, val)
    
    def inorder(self):
        """Return inorder traversal (sorted order)"""
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, node, result):
        if node:
            self._inorder_recursive(node.left, result)
            result.append(node.val)
            self._inorder_recursive(node.right, result)

# Example usage
bst = BinarySearchTree()
for val in [50, 30, 70, 20, 40, 60, 80]:
    bst.insert(val)

print("Inorder traversal:", bst.inorder())
# Output: [20, 30, 40, 50, 60, 70, 80]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Binary Search Tree Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class BinarySearchTree {
private:
    TreeNode* root;
    
    void insertRecursive(TreeNode* node, int val) {
        if (val &lt; node-&gt;val) {
            if (!node-&gt;left) node-&gt;left = new TreeNode(val);
            else insertRecursive(node-&gt;left, val);
        } else {
            if (!node-&gt;right) node-&gt;right = new TreeNode(val);
            else insertRecursive(node-&gt;right, val);
        }
    }
    
    void inorderRecursive(TreeNode* node, std::vector&lt;int&gt;&amp; result) {
        if (node) {
            inorderRecursive(node-&gt;left, result);
            result.push_back(node-&gt;val);
            inorderRecursive(node-&gt;right, result);
        }
    }
    
public:
    BinarySearchTree() : root(nullptr) {}
    
    void insert(int val) {
        if (!root) root = new TreeNode(val);
        else insertRecursive(root, val);
    }
    
    std::vector&lt;int&gt; inorder() {
        std::vector&lt;int&gt; result;
        inorderRecursive(root, result);
        return result;
    }
};

// Usage: BinarySearchTree bst;
// for (int v : {50, 30, 70, 20, 40, 60, 80}) bst.insert(v);
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Binary Search Tree Implementation
import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int x) { val = x; }
}

class BinarySearchTree {
    private TreeNode root;
    
    public void insert(int val) {
        if (root == null) root = new TreeNode(val);
        else insertRecursive(root, val);
    }
    
    private void insertRecursive(TreeNode node, int val) {
        if (val &lt; node.val) {
            if (node.left == null) node.left = new TreeNode(val);
            else insertRecursive(node.left, val);
        } else {
            if (node.right == null) node.right = new TreeNode(val);
            else insertRecursive(node.right, val);
        }
    }
    
    public List&lt;Integer&gt; inorder() {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        inorderRecursive(root, result);
        return result;
    }
    
    private void inorderRecursive(TreeNode node, List&lt;Integer&gt; result) {
        if (node != null) {
            inorderRecursive(node.left, result);
            result.add(node.val);
            inorderRecursive(node.right, result);
        }
    }
}

// Usage: BinarySearchTree bst = new BinarySearchTree();
// for (int v : new int[]{50, 30, 70, 20, 40, 60, 80}) bst.insert(v);
</code></pre>

                        <!-- BST Operations -->
                        <h2 id="bst-operations"><i class="fas fa-cogs me-2"></i>BST Operations</h2>
                        
                        <h3>Search Operation</h3>
                        
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def search_bst(root, target):
    """
    Search for a value in BST
    Time: O(h) where h is height, O(log n) average, O(n) worst
    Space: O(1) iterative
    """
    current = root
    while current:
        if target == current.val:
            return current
        elif target < current.val:
            current = current.left
        else:
            current = current.right
    return None

def search_bst_recursive(root, target):
    """Recursive search implementation"""
    if not root or root.val == target:
        return root
    
    if target < root.val:
        return search_bst_recursive(root.left, target)
    else:
        return search_bst_recursive(root.right, target)

# Build BST: [50, 30, 70, 20, 40, 60, 80]
root = TreeNode(50)
root.left = TreeNode(30)
root.right = TreeNode(70)
root.left.left = TreeNode(20)
root.left.right = TreeNode(40)
root.right.left = TreeNode(60)
root.right.right = TreeNode(80)

# Search for values
result = search_bst(root, 40)
print("Found 40:", result.val if result else "Not found")

result = search_bst(root, 55)
print("Found 55:", result.val if result else "Not found")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// BST Search Operation
// Time: O(h), Space: O(1) iterative
#include &lt;iostream&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* searchBST(TreeNode* root, int target) {
    TreeNode* current = root;
    while (current) {
        if (target == current-&gt;val) return current;
        else if (target &lt; current-&gt;val) current = current-&gt;left;
        else current = current-&gt;right;
    }
    return nullptr;
}

TreeNode* searchBSTRecursive(TreeNode* root, int target) {
    if (!root || root-&gt;val == target) return root;
    if (target &lt; root-&gt;val) return searchBSTRecursive(root-&gt;left, target);
    return searchBSTRecursive(root-&gt;right, target);
}

// Usage:
// TreeNode* result = searchBST(root, 40);
// std::cout &lt;&lt; (result ? result-&gt;val : -1);
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// BST Search Operation
// Time: O(h), Space: O(1) iterative

class Solution {
    public TreeNode searchBST(TreeNode root, int target) {
        TreeNode current = root;
        while (current != null) {
            if (target == current.val) return current;
            else if (target &lt; current.val) current = current.left;
            else current = current.right;
        }
        return null;
    }
    
    public TreeNode searchBSTRecursive(TreeNode root, int target) {
        if (root == null || root.val == target) return root;
        if (target &lt; root.val) return searchBSTRecursive(root.left, target);
        return searchBSTRecursive(root.right, target);
    }
}

// Usage:
// TreeNode result = solution.searchBST(root, 40);
// System.out.println(result != null ? result.val : "Not found");
</code></pre>

                        <h3>Insert Operation</h3>
                        
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def insert_bst(root, val):
    """
    Insert a value into BST
    Time: O(h), Space: O(h) for recursion
    Returns: root of the tree
    """
    if not root:
        return TreeNode(val)
    
    if val < root.val:
        root.left = insert_bst(root.left, val)
    else:
        root.right = insert_bst(root.right, val)
    
    return root

def insert_bst_iterative(root, val):
    """Iterative insertion - O(1) space"""
    new_node = TreeNode(val)
    
    if not root:
        return new_node
    
    current = root
    while True:
        if val < current.val:
            if current.left is None:
                current.left = new_node
                break
            current = current.left
        else:
            if current.right is None:
                current.right = new_node
                break
            current = current.right
    
    return root

# Example: Build BST from scratch
root = None
values = [50, 30, 70, 20, 40, 60, 80, 35]

for val in values:
    root = insert_bst(root, val)

# Verify with inorder traversal
def inorder(node, result=None):
    if result is None:
        result = []
    if node:
        inorder(node.left, result)
        result.append(node.val)
        inorder(node.right, result)
    return result

print("BST inorder:", inorder(root))
# Output: [20, 30, 35, 40, 50, 60, 70, 80]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// BST Insert Operation
// Time: O(h), Space: O(h) recursive, O(1) iterative
#include &lt;iostream&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* insertBST(TreeNode* root, int val) {
    if (!root) return new TreeNode(val);
    
    if (val &lt; root-&gt;val) 
        root-&gt;left = insertBST(root-&gt;left, val);
    else 
        root-&gt;right = insertBST(root-&gt;right, val);
    
    return root;
}

TreeNode* insertBSTIterative(TreeNode* root, int val) {
    TreeNode* newNode = new TreeNode(val);
    if (!root) return newNode;
    
    TreeNode* current = root;
    while (true) {
        if (val &lt; current-&gt;val) {
            if (!current-&gt;left) { current-&gt;left = newNode; break; }
            current = current-&gt;left;
        } else {
            if (!current-&gt;right) { current-&gt;right = newNode; break; }
            current = current-&gt;right;
        }
    }
    return root;
}

// Usage:
// TreeNode* root = nullptr;
// for (int v : {50, 30, 70, 20, 40}) root = insertBST(root, v);
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// BST Insert Operation
// Time: O(h), Space: O(h) recursive, O(1) iterative

class Solution {
    public TreeNode insertBST(TreeNode root, int val) {
        if (root == null) return new TreeNode(val);
        
        if (val &lt; root.val)
            root.left = insertBST(root.left, val);
        else
            root.right = insertBST(root.right, val);
        
        return root;
    }
    
    public TreeNode insertBSTIterative(TreeNode root, int val) {
        TreeNode newNode = new TreeNode(val);
        if (root == null) return newNode;
        
        TreeNode current = root;
        while (true) {
            if (val &lt; current.val) {
                if (current.left == null) { current.left = newNode; break; }
                current = current.left;
            } else {
                if (current.right == null) { current.right = newNode; break; }
                current = current.right;
            }
        }
        return root;
    }
}

// Usage:
// TreeNode root = null;
// for (int v : new int[]{50, 30, 70, 20, 40}) root = solution.insertBST(root, v);
</code></pre>

                        <h3>Delete Operation</h3>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-trash me-2"></i>BST Deletion Cases</h4>
                            <ul>
                                <li><strong>Case 1 - Leaf node:</strong> Simply remove the node</li>
                                <li><strong>Case 2 - One child:</strong> Replace node with its child</li>
                                <li><strong>Case 3 - Two children:</strong> Replace with inorder successor (or predecessor)</li>
                            </ul>
                        </div>
                        
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_min(node):
    """Find minimum value node (leftmost)"""
    current = node
    while current.left:
        current = current.left
    return current

def delete_bst(root, key):
    """
    Delete a node from BST
    Time: O(h), Space: O(h)
    LeetCode 450: Delete Node in a BST
    """
    if not root:
        return None
    
    # Find the node to delete
    if key < root.val:
        root.left = delete_bst(root.left, key)
    elif key > root.val:
        root.right = delete_bst(root.right, key)
    else:
        # Found the node to delete
        
        # Case 1 & 2: Node has 0 or 1 child
        if not root.left:
            return root.right
        elif not root.right:
            return root.left
        
        # Case 3: Node has two children
        # Find inorder successor (smallest in right subtree)
        successor = find_min(root.right)
        
        # Copy successor's value to this node
        root.val = successor.val
        
        # Delete the successor
        root.right = delete_bst(root.right, successor.val)
    
    return root

# Build BST
def build_bst(values):
    root = None
    for val in values:
        if not root:
            root = TreeNode(val)
        else:
            curr = root
            while True:
                if val < curr.val:
                    if not curr.left:
                        curr.left = TreeNode(val)
                        break
                    curr = curr.left
                else:
                    if not curr.right:
                        curr.right = TreeNode(val)
                        break
                    curr = curr.right
    return root

def inorder(node):
    if not node:
        return []
    return inorder(node.left) + [node.val] + inorder(node.right)

root = build_bst([50, 30, 70, 20, 40, 60, 80])
print("Before delete:", inorder(root))

root = delete_bst(root, 30)  # Delete node with two children
print("After delete 30:", inorder(root))

root = delete_bst(root, 20)  # Delete leaf
print("After delete 20:", inorder(root))
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// BST Delete Operation - LeetCode 450
// Time: O(h), Space: O(h)
#include &lt;iostream&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* findMin(TreeNode* node) {
    while (node-&gt;left) node = node-&gt;left;
    return node;
}

TreeNode* deleteBST(TreeNode* root, int key) {
    if (!root) return nullptr;
    
    if (key &lt; root-&gt;val) {
        root-&gt;left = deleteBST(root-&gt;left, key);
    } else if (key &gt; root-&gt;val) {
        root-&gt;right = deleteBST(root-&gt;right, key);
    } else {
        // Case 1 &amp; 2: Node has 0 or 1 child
        if (!root-&gt;left) return root-&gt;right;
        if (!root-&gt;right) return root-&gt;left;
        
        // Case 3: Two children - find inorder successor
        TreeNode* successor = findMin(root-&gt;right);
        root-&gt;val = successor-&gt;val;
        root-&gt;right = deleteBST(root-&gt;right, successor-&gt;val);
    }
    return root;
}

// Usage:
// root = deleteBST(root, 30);  // Delete node with two children
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// BST Delete Operation - LeetCode 450
// Time: O(h), Space: O(h)

class Solution {
    private TreeNode findMin(TreeNode node) {
        while (node.left != null) node = node.left;
        return node;
    }
    
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;
        
        if (key &lt; root.val) {
            root.left = deleteNode(root.left, key);
        } else if (key &gt; root.val) {
            root.right = deleteNode(root.right, key);
        } else {
            // Case 1 &amp; 2: Node has 0 or 1 child
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            
            // Case 3: Two children - find inorder successor
            TreeNode successor = findMin(root.right);
            root.val = successor.val;
            root.right = deleteNode(root.right, successor.val);
        }
        return root;
    }
}

// Usage:
// root = solution.deleteNode(root, 30);  // Delete node with two children
</code></pre>

                        <h3>Inorder Successor & Predecessor</h3>
                        
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder_successor(root, target):
    """
    Find inorder successor of a node with given value
    Time: O(h), Space: O(1)
    """
    successor = None
    current = root
    
    while current:
        if target < current.val:
            successor = current  # Potential successor
            current = current.left
        else:
            current = current.right
    
    return successor

def inorder_predecessor(root, target):
    """
    Find inorder predecessor of a node with given value
    Time: O(h), Space: O(1)
    """
    predecessor = None
    current = root
    
    while current:
        if target > current.val:
            predecessor = current  # Potential predecessor
            current = current.right
        else:
            current = current.left
    
    return predecessor

# Build BST: [20, 30, 40, 50, 60, 70, 80]
root = TreeNode(50)
root.left = TreeNode(30, TreeNode(20), TreeNode(40))
root.right = TreeNode(70, TreeNode(60), TreeNode(80))

# Find successor of 40 (should be 50)
succ = inorder_successor(root, 40)
print(f"Successor of 40: {succ.val if succ else None}")

# Find predecessor of 60 (should be 50)
pred = inorder_predecessor(root, 60)
print(f"Predecessor of 60: {pred.val if pred else None}")

# Find successor of 80 (should be None)
succ = inorder_successor(root, 80)
print(f"Successor of 80: {succ.val if succ else None}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Inorder Successor and Predecessor in BST
// Time: O(h), Space: O(1)
#include &lt;iostream&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* inorderSuccessor(TreeNode* root, int target) {
    TreeNode* successor = nullptr;
    TreeNode* current = root;
    
    while (current) {
        if (target &lt; current-&gt;val) {
            successor = current;  // Potential successor
            current = current-&gt;left;
        } else {
            current = current-&gt;right;
        }
    }
    return successor;
}

TreeNode* inorderPredecessor(TreeNode* root, int target) {
    TreeNode* predecessor = nullptr;
    TreeNode* current = root;
    
    while (current) {
        if (target &gt; current-&gt;val) {
            predecessor = current;  // Potential predecessor
            current = current-&gt;right;
        } else {
            current = current-&gt;left;
        }
    }
    return predecessor;
}

// Usage:
// TreeNode* succ = inorderSuccessor(root, 40);  // Returns node with value 50
// TreeNode* pred = inorderPredecessor(root, 60); // Returns node with value 50
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Inorder Successor and Predecessor in BST
// Time: O(h), Space: O(1)

class Solution {
    public TreeNode inorderSuccessor(TreeNode root, int target) {
        TreeNode successor = null;
        TreeNode current = root;
        
        while (current != null) {
            if (target &lt; current.val) {
                successor = current;  // Potential successor
                current = current.left;
            } else {
                current = current.right;
            }
        }
        return successor;
    }
    
    public TreeNode inorderPredecessor(TreeNode root, int target) {
        TreeNode predecessor = null;
        TreeNode current = root;
        
        while (current != null) {
            if (target &gt; current.val) {
                predecessor = current;  // Potential predecessor
                current = current.right;
            } else {
                current = current.left;
            }
        }
        return predecessor;
    }
}

// Usage:
// TreeNode succ = solution.inorderSuccessor(root, 40);  // Returns node with value 50
// TreeNode pred = solution.inorderPredecessor(root, 60); // Returns node with value 50
</code></pre>

                        <!-- BST Validation -->
                        <h2 id="bst-validation"><i class="fas fa-check-circle me-2"></i>BST Validation</h2>
                        
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_valid_bst(root):
    """
    Validate Binary Search Tree
    LeetCode 98: Validate Binary Search Tree
    Time: O(n), Space: O(h)
    """
    def validate(node, min_val, max_val):
        if not node:
            return True
        
        # Check current node's value against bounds
        if node.val <= min_val or node.val >= max_val:
            return False
        
        # Recursively validate left and right subtrees
        # Left subtree: all values must be < current node's value
        # Right subtree: all values must be > current node's value
        return (validate(node.left, min_val, node.val) and
                validate(node.right, node.val, max_val))
    
    return validate(root, float('-inf'), float('inf'))

def is_valid_bst_inorder(root):
    """
    Validate BST using inorder traversal
    Inorder of BST should be strictly increasing
    """
    prev = float('-inf')
    
    def inorder(node):
        nonlocal prev
        if not node:
            return True
        
        # Check left subtree
        if not inorder(node.left):
            return False
        
        # Check current node
        if node.val <= prev:
            return False
        prev = node.val
        
        # Check right subtree
        return inorder(node.right)
    
    return inorder(root)

# Test cases
# Valid BST
valid_root = TreeNode(5, TreeNode(3, TreeNode(1), TreeNode(4)),
                         TreeNode(7, TreeNode(6), TreeNode(8)))
print("Valid BST:", is_valid_bst(valid_root))  # True

# Invalid BST (4 is in right subtree but < 5)
invalid_root = TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))
print("Invalid BST:", is_valid_bst(invalid_root))  # False
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 98 - Validate Binary Search Tree
// Time: O(n), Space: O(h)
#include &lt;climits&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
private:
    bool validate(TreeNode* node, long minVal, long maxVal) {
        if (!node) return true;
        
        if (node-&gt;val &lt;= minVal || node-&gt;val &gt;= maxVal)
            return false;
        
        return validate(node-&gt;left, minVal, node-&gt;val) &amp;&amp;
               validate(node-&gt;right, node-&gt;val, maxVal);
    }
    
public:
    bool isValidBST(TreeNode* root) {
        return validate(root, LONG_MIN, LONG_MAX);
    }
    
    // Alternative: Inorder traversal approach
    bool isValidBSTInorder(TreeNode* root) {
        long prev = LONG_MIN;
        return inorder(root, prev);
    }
    
    bool inorder(TreeNode* node, long&amp; prev) {
        if (!node) return true;
        if (!inorder(node-&gt;left, prev)) return false;
        if (node-&gt;val &lt;= prev) return false;
        prev = node-&gt;val;
        return inorder(node-&gt;right, prev);
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 98 - Validate Binary Search Tree
// Time: O(n), Space: O(h)

class Solution {
    public boolean isValidBST(TreeNode root) {
        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    
    private boolean validate(TreeNode node, long minVal, long maxVal) {
        if (node == null) return true;
        
        if (node.val &lt;= minVal || node.val &gt;= maxVal)
            return false;
        
        return validate(node.left, minVal, node.val) &amp;&amp;
               validate(node.right, node.val, maxVal);
    }
    
    // Alternative: Inorder traversal approach
    private long prev = Long.MIN_VALUE;
    
    public boolean isValidBSTInorder(TreeNode root) {
        prev = Long.MIN_VALUE;
        return inorder(root);
    }
    
    private boolean inorder(TreeNode node) {
        if (node == null) return true;
        if (!inorder(node.left)) return false;
        if (node.val &lt;= prev) return false;
        prev = node.val;
        return inorder(node.right);
    }
}
</code></pre>

                        <!-- AVL Trees -->
                        <h2 id="avl-trees"><i class="fas fa-balance-scale me-2"></i>AVL Trees</h2>
                        
                        <p><strong>AVL Tree</strong> is a self-balancing BST where the height difference between left and right subtrees (balance factor) is at most 1 for every node. Named after inventors Adelson-Velsky and Landis.</p>
                        
                        <div class="highlight-box">
                            <h4><i class="fas fa-ruler me-2"></i>AVL Property</h4>
                            <p><strong>Balance Factor = height(left subtree) - height(right subtree)</strong></p>
                            <p>Valid balance factors: -1, 0, +1</p>
                            <p>If |balance factor| > 1, tree needs rebalancing via rotations.</p>
                        </div>

                        <h3>AVL Node Structure</h3>
                        
<pre><code class="language-python">class AVLNode:
    """AVL Tree Node with height tracking"""
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1  # Height of node (leaf = 1)

class AVLTree:
    """AVL Tree implementation"""
    
    def __init__(self):
        self.root = None
    
    def get_height(self, node):
        """Get height of node (None has height 0)"""
        if not node:
            return 0
        return node.height
    
    def get_balance(self, node):
        """Get balance factor of node"""
        if not node:
            return 0
        return self.get_height(node.left) - self.get_height(node.right)
    
    def update_height(self, node):
        """Update height of node based on children"""
        if node:
            node.height = 1 + max(self.get_height(node.left),
                                   self.get_height(node.right))
    
    def inorder(self):
        """Return inorder traversal"""
        result = []
        self._inorder(self.root, result)
        return result
    
    def _inorder(self, node, result):
        if node:
            self._inorder(node.left, result)
            result.append(node.val)
            self._inorder(node.right, result)

# Example
tree = AVLTree()
root = AVLNode(10)
root.left = AVLNode(5)
root.right = AVLNode(15)
root.left.left = AVLNode(2)

tree.root = root
tree.update_height(root.left)
tree.update_height(root)

print(f"Root height: {root.height}")
print(f"Root balance: {tree.get_balance(root)}")
print(f"Left child balance: {tree.get_balance(root.left)}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// AVL Tree Node Structure
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

struct AVLNode {
    int val;
    AVLNode* left;
    AVLNode* right;
    int height;
    AVLNode(int x) : val(x), left(nullptr), right(nullptr), height(1) {}
};

class AVLTree {
private:
    AVLNode* root;
    
    int getHeight(AVLNode* node) {
        return node ? node-&gt;height : 0;
    }
    
    int getBalance(AVLNode* node) {
        return node ? getHeight(node-&gt;left) - getHeight(node-&gt;right) : 0;
    }
    
    void updateHeight(AVLNode* node) {
        if (node) {
            node-&gt;height = 1 + std::max(getHeight(node-&gt;left), 
                                         getHeight(node-&gt;right));
        }
    }
    
public:
    AVLTree() : root(nullptr) {}
    
    void printInfo(AVLNode* node) {
        if (node) {
            std::cout &lt;&lt; "Value: " &lt;&lt; node-&gt;val 
                      &lt;&lt; ", Height: " &lt;&lt; node-&gt;height
                      &lt;&lt; ", Balance: " &lt;&lt; getBalance(node) &lt;&lt; std::endl;
        }
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// AVL Tree Node Structure

class AVLNode {
    int val;
    AVLNode left, right;
    int height;
    
    AVLNode(int x) {
        val = x;
        height = 1;
    }
}

class AVLTree {
    private AVLNode root;
    
    private int getHeight(AVLNode node) {
        return node != null ? node.height : 0;
    }
    
    private int getBalance(AVLNode node) {
        return node != null ? getHeight(node.left) - getHeight(node.right) : 0;
    }
    
    private void updateHeight(AVLNode node) {
        if (node != null) {
            node.height = 1 + Math.max(getHeight(node.left), 
                                        getHeight(node.right));
        }
    }
    
    public void printInfo(AVLNode node) {
        if (node != null) {
            System.out.println("Value: " + node.val + 
                             ", Height: " + node.height +
                             ", Balance: " + getBalance(node));
        }
    }
}
</code></pre>

                        <!-- AVL Rotations -->
                        <h2 id="avl-rotations"><i class="fas fa-sync-alt me-2"></i>AVL Rotations</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-redo me-2"></i>Four Types of Rotations</h4>
                            <table class="table table-bordered">
                                <thead>
                                    <tr>
                                        <th>Imbalance</th>
                                        <th>Rotation</th>
                                        <th>When to Use</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Left-Left (LL)</td>
                                        <td>Right Rotation</td>
                                        <td>balance > 1 AND left balance >= 0</td>
                                    </tr>
                                    <tr>
                                        <td>Right-Right (RR)</td>
                                        <td>Left Rotation</td>
                                        <td>balance < -1 AND right balance <= 0</td>
                                    </tr>
                                    <tr>
                                        <td>Left-Right (LR)</td>
                                        <td>Left then Right</td>
                                        <td>balance > 1 AND left balance < 0</td>
                                    </tr>
                                    <tr>
                                        <td>Right-Left (RL)</td>
                                        <td>Right then Left</td>
                                        <td>balance < -1 AND right balance > 0</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

<pre><code class="language-python">class AVLNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1

class AVLTree:
    def get_height(self, node):
        return node.height if node else 0
    
    def get_balance(self, node):
        return self.get_height(node.left) - self.get_height(node.right) if node else 0
    
    def update_height(self, node):
        if node:
            node.height = 1 + max(self.get_height(node.left),
                                   self.get_height(node.right))
    
    def right_rotate(self, y):
        """
        Right rotation (LL case)
        
             y                x
            / \             /   \
           x   T3   -->    T1    y
          / \                   / \
         T1  T2               T2  T3
        """
        x = y.left
        T2 = x.right
        
        # Perform rotation
        x.right = y
        y.left = T2
        
        # Update heights (y first, then x)
        self.update_height(y)
        self.update_height(x)
        
        return x  # New root
    
    def left_rotate(self, x):
        """
        Left rotation (RR case)
        
           x                    y
          / \                 /   \
         T1  y      -->      x    T3
            / \             / \
           T2  T3          T1  T2
        """
        y = x.right
        T2 = y.left
        
        # Perform rotation
        y.left = x
        x.right = T2
        
        # Update heights (x first, then y)
        self.update_height(x)
        self.update_height(y)
        
        return y  # New root
    
    def insert(self, root, val):
        """Insert value and rebalance"""
        # Step 1: Normal BST insertion
        if not root:
            return AVLNode(val)
        
        if val < root.val:
            root.left = self.insert(root.left, val)
        else:
            root.right = self.insert(root.right, val)
        
        # Step 2: Update height
        self.update_height(root)
        
        # Step 3: Get balance factor
        balance = self.get_balance(root)
        
        # Step 4: Rebalance if needed
        
        # Left Left Case (LL)
        if balance > 1 and val < root.left.val:
            return self.right_rotate(root)
        
        # Right Right Case (RR)
        if balance < -1 and val > root.right.val:
            return self.left_rotate(root)
        
        # Left Right Case (LR)
        if balance > 1 and val > root.left.val:
            root.left = self.left_rotate(root.left)
            return self.right_rotate(root)
        
        # Right Left Case (RL)
        if balance < -1 and val < root.right.val:
            root.right = self.right_rotate(root.right)
            return self.left_rotate(root)
        
        return root

# Example: Insert values and observe balancing
avl = AVLTree()
root = None

values = [10, 20, 30, 40, 50, 25]
for val in values:
    root = avl.insert(root, val)
    print(f"Inserted {val}, root = {root.val}, balance = {avl.get_balance(root)}")

def inorder(node):
    return inorder(node.left) + [node.val] + inorder(node.right) if node else []

print("Inorder:", inorder(root))
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// AVL Tree with Rotations
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

struct AVLNode {
    int val, height;
    AVLNode *left, *right;
    AVLNode(int x) : val(x), height(1), left(nullptr), right(nullptr) {}
};

class AVLTree {
private:
    int getHeight(AVLNode* n) { return n ? n-&gt;height : 0; }
    int getBalance(AVLNode* n) { return n ? getHeight(n-&gt;left) - getHeight(n-&gt;right) : 0; }
    void updateHeight(AVLNode* n) { 
        if (n) n-&gt;height = 1 + std::max(getHeight(n-&gt;left), getHeight(n-&gt;right)); 
    }
    
    AVLNode* rightRotate(AVLNode* y) {
        AVLNode* x = y-&gt;left;
        y-&gt;left = x-&gt;right;
        x-&gt;right = y;
        updateHeight(y); updateHeight(x);
        return x;
    }
    
    AVLNode* leftRotate(AVLNode* x) {
        AVLNode* y = x-&gt;right;
        x-&gt;right = y-&gt;left;
        y-&gt;left = x;
        updateHeight(x); updateHeight(y);
        return y;
    }
    
public:
    AVLNode* insert(AVLNode* root, int val) {
        if (!root) return new AVLNode(val);
        if (val &lt; root-&gt;val) root-&gt;left = insert(root-&gt;left, val);
        else root-&gt;right = insert(root-&gt;right, val);
        
        updateHeight(root);
        int bal = getBalance(root);
        
        if (bal &gt; 1 &amp;&amp; val &lt; root-&gt;left-&gt;val) return rightRotate(root);  // LL
        if (bal &lt; -1 &amp;&amp; val &gt; root-&gt;right-&gt;val) return leftRotate(root);  // RR
        if (bal &gt; 1 &amp;&amp; val &gt; root-&gt;left-&gt;val) {                           // LR
            root-&gt;left = leftRotate(root-&gt;left);
            return rightRotate(root);
        }
        if (bal &lt; -1 &amp;&amp; val &lt; root-&gt;right-&gt;val) {                         // RL
            root-&gt;right = rightRotate(root-&gt;right);
            return leftRotate(root);
        }
        return root;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// AVL Tree with Rotations

class AVLNode {
    int val, height;
    AVLNode left, right;
    AVLNode(int x) { val = x; height = 1; }
}

class AVLTree {
    private int getHeight(AVLNode n) { return n != null ? n.height : 0; }
    private int getBalance(AVLNode n) { 
        return n != null ? getHeight(n.left) - getHeight(n.right) : 0; 
    }
    private void updateHeight(AVLNode n) { 
        if (n != null) n.height = 1 + Math.max(getHeight(n.left), getHeight(n.right)); 
    }
    
    private AVLNode rightRotate(AVLNode y) {
        AVLNode x = y.left;
        y.left = x.right;
        x.right = y;
        updateHeight(y); updateHeight(x);
        return x;
    }
    
    private AVLNode leftRotate(AVLNode x) {
        AVLNode y = x.right;
        x.right = y.left;
        y.left = x;
        updateHeight(x); updateHeight(y);
        return y;
    }
    
    public AVLNode insert(AVLNode root, int val) {
        if (root == null) return new AVLNode(val);
        if (val &lt; root.val) root.left = insert(root.left, val);
        else root.right = insert(root.right, val);
        
        updateHeight(root);
        int bal = getBalance(root);
        
        if (bal &gt; 1 &amp;&amp; val &lt; root.left.val) return rightRotate(root);  // LL
        if (bal &lt; -1 &amp;&amp; val &gt; root.right.val) return leftRotate(root); // RR
        if (bal &gt; 1 &amp;&amp; val &gt; root.left.val) {                          // LR
            root.left = leftRotate(root.left);
            return rightRotate(root);
        }
        if (bal &lt; -1 &amp;&amp; val &lt; root.right.val) {                        // RL
            root.right = rightRotate(root.right);
            return leftRotate(root);
        }
        return root;
    }
}
</code></pre>

                        <h3>Complete AVL Insert with All Cases</h3>
                        
<pre><code class="language-python">class AVLNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1

class AVLTree:
    def __init__(self):
        self.root = None
    
    def height(self, node):
        return node.height if node else 0
    
    def balance(self, node):
        return self.height(node.left) - self.height(node.right) if node else 0
    
    def right_rotate(self, y):
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = 1 + max(self.height(y.left), self.height(y.right))
        x.height = 1 + max(self.height(x.left), self.height(x.right))
        return x
    
    def left_rotate(self, x):
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        x.height = 1 + max(self.height(x.left), self.height(x.right))
        y.height = 1 + max(self.height(y.left), self.height(y.right))
        return y
    
    def insert(self, val):
        self.root = self._insert(self.root, val)
    
    def _insert(self, node, val):
        # BST insert
        if not node:
            return AVLNode(val)
        if val < node.val:
            node.left = self._insert(node.left, val)
        else:
            node.right = self._insert(node.right, val)
        
        # Update height
        node.height = 1 + max(self.height(node.left), self.height(node.right))
        
        # Get balance
        bal = self.balance(node)
        
        # LL Case
        if bal > 1 and val < node.left.val:
            return self.right_rotate(node)
        
        # RR Case
        if bal < -1 and val > node.right.val:
            return self.left_rotate(node)
        
        # LR Case
        if bal > 1 and val > node.left.val:
            node.left = self.left_rotate(node.left)
            return self.right_rotate(node)
        
        # RL Case
        if bal < -1 and val < node.right.val:
            node.right = self.right_rotate(node.right)
            return self.left_rotate(node)
        
        return node
    
    def delete(self, val):
        self.root = self._delete(self.root, val)
    
    def _delete(self, node, val):
        if not node:
            return node
        
        # BST delete
        if val < node.val:
            node.left = self._delete(node.left, val)
        elif val > node.val:
            node.right = self._delete(node.right, val)
        else:
            # Node to delete found
            if not node.left:
                return node.right
            elif not node.right:
                return node.left
            
            # Two children: get inorder successor
            temp = self._min_node(node.right)
            node.val = temp.val
            node.right = self._delete(node.right, temp.val)
        
        if not node:
            return node
        
        # Update height
        node.height = 1 + max(self.height(node.left), self.height(node.right))
        
        # Rebalance
        bal = self.balance(node)
        
        # LL
        if bal > 1 and self.balance(node.left) >= 0:
            return self.right_rotate(node)
        
        # LR
        if bal > 1 and self.balance(node.left) < 0:
            node.left = self.left_rotate(node.left)
            return self.right_rotate(node)
        
        # RR
        if bal < -1 and self.balance(node.right) <= 0:
            return self.left_rotate(node)
        
        # RL
        if bal < -1 and self.balance(node.right) > 0:
            node.right = self.right_rotate(node.right)
            return self.left_rotate(node)
        
        return node
    
    def _min_node(self, node):
        while node.left:
            node = node.left
        return node
    
    def levelorder(self):
        if not self.root:
            return []
        from collections import deque
        result = []
        queue = deque([self.root])
        while queue:
            node = queue.popleft()
            result.append(f"{node.val}(h={node.height})")
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        return result

# Example usage
avl = AVLTree()
for val in [10, 20, 30, 15, 25, 5, 1]:
    avl.insert(val)
    print(f"After insert {val}: {avl.levelorder()}")

print("\nDeleting 20...")
avl.delete(20)
print(f"After delete: {avl.levelorder()}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Complete AVL Tree with Insert and Delete
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;string&gt;

struct AVLNode {
    int val, height;
    AVLNode *left, *right;
    AVLNode(int x) : val(x), height(1), left(nullptr), right(nullptr) {}
};

class AVLTree {
private:
    AVLNode* root = nullptr;
    int h(AVLNode* n) { return n ? n-&gt;height : 0; }
    int bal(AVLNode* n) { return n ? h(n-&gt;left) - h(n-&gt;right) : 0; }
    void upd(AVLNode* n) { if (n) n-&gt;height = 1 + std::max(h(n-&gt;left), h(n-&gt;right)); }
    
    AVLNode* rr(AVLNode* y) { AVLNode* x = y-&gt;left; y-&gt;left = x-&gt;right; x-&gt;right = y; upd(y); upd(x); return x; }
    AVLNode* lr(AVLNode* x) { AVLNode* y = x-&gt;right; x-&gt;right = y-&gt;left; y-&gt;left = x; upd(x); upd(y); return y; }
    AVLNode* minNode(AVLNode* n) { while (n-&gt;left) n = n-&gt;left; return n; }
    
    AVLNode* rebalance(AVLNode* n, int val, bool isInsert) {
        upd(n); int b = bal(n);
        if (isInsert) {
            if (b &gt; 1 &amp;&amp; val &lt; n-&gt;left-&gt;val) return rr(n);
            if (b &lt; -1 &amp;&amp; val &gt; n-&gt;right-&gt;val) return lr(n);
            if (b &gt; 1 &amp;&amp; val &gt; n-&gt;left-&gt;val) { n-&gt;left = lr(n-&gt;left); return rr(n); }
            if (b &lt; -1 &amp;&amp; val &lt; n-&gt;right-&gt;val) { n-&gt;right = rr(n-&gt;right); return lr(n); }
        } else {
            if (b &gt; 1 &amp;&amp; bal(n-&gt;left) &gt;= 0) return rr(n);
            if (b &gt; 1 &amp;&amp; bal(n-&gt;left) &lt; 0) { n-&gt;left = lr(n-&gt;left); return rr(n); }
            if (b &lt; -1 &amp;&amp; bal(n-&gt;right) &lt;= 0) return lr(n);
            if (b &lt; -1 &amp;&amp; bal(n-&gt;right) &gt; 0) { n-&gt;right = rr(n-&gt;right); return lr(n); }
        }
        return n;
    }
    
    AVLNode* ins(AVLNode* n, int val) {
        if (!n) return new AVLNode(val);
        if (val &lt; n-&gt;val) n-&gt;left = ins(n-&gt;left, val);
        else n-&gt;right = ins(n-&gt;right, val);
        return rebalance(n, val, true);
    }
    
    AVLNode* del(AVLNode* n, int val) {
        if (!n) return n;
        if (val &lt; n-&gt;val) n-&gt;left = del(n-&gt;left, val);
        else if (val &gt; n-&gt;val) n-&gt;right = del(n-&gt;right, val);
        else {
            if (!n-&gt;left) return n-&gt;right;
            if (!n-&gt;right) return n-&gt;left;
            AVLNode* temp = minNode(n-&gt;right);
            n-&gt;val = temp-&gt;val;
            n-&gt;right = del(n-&gt;right, temp-&gt;val);
        }
        return rebalance(n, val, false);
    }
    
public:
    void insert(int val) { root = ins(root, val); }
    void remove(int val) { root = del(root, val); }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Complete AVL Tree with Insert and Delete
import java.util.*;

class AVLNode {
    int val, height;
    AVLNode left, right;
    AVLNode(int x) { val = x; height = 1; }
}

class AVLTree {
    private AVLNode root;
    private int h(AVLNode n) { return n != null ? n.height : 0; }
    private int bal(AVLNode n) { return n != null ? h(n.left) - h(n.right) : 0; }
    private void upd(AVLNode n) { if (n != null) n.height = 1 + Math.max(h(n.left), h(n.right)); }
    
    private AVLNode rr(AVLNode y) { 
        AVLNode x = y.left; y.left = x.right; x.right = y; upd(y); upd(x); return x; 
    }
    private AVLNode lr(AVLNode x) { 
        AVLNode y = x.right; x.right = y.left; y.left = x; upd(x); upd(y); return y; 
    }
    private AVLNode minNode(AVLNode n) { while (n.left != null) n = n.left; return n; }
    
    private AVLNode rebalance(AVLNode n, int val, boolean isInsert) {
        upd(n); int b = bal(n);
        if (isInsert) {
            if (b &gt; 1 &amp;&amp; val &lt; n.left.val) return rr(n);
            if (b &lt; -1 &amp;&amp; val &gt; n.right.val) return lr(n);
            if (b &gt; 1 &amp;&amp; val &gt; n.left.val) { n.left = lr(n.left); return rr(n); }
            if (b &lt; -1 &amp;&amp; val &lt; n.right.val) { n.right = rr(n.right); return lr(n); }
        } else {
            if (b &gt; 1 &amp;&amp; bal(n.left) &gt;= 0) return rr(n);
            if (b &gt; 1 &amp;&amp; bal(n.left) &lt; 0) { n.left = lr(n.left); return rr(n); }
            if (b &lt; -1 &amp;&amp; bal(n.right) &lt;= 0) return lr(n);
            if (b &lt; -1 &amp;&amp; bal(n.right) &gt; 0) { n.right = rr(n.right); return lr(n); }
        }
        return n;
    }
    
    private AVLNode ins(AVLNode n, int val) {
        if (n == null) return new AVLNode(val);
        if (val &lt; n.val) n.left = ins(n.left, val);
        else n.right = ins(n.right, val);
        return rebalance(n, val, true);
    }
    
    private AVLNode del(AVLNode n, int val) {
        if (n == null) return n;
        if (val &lt; n.val) n.left = del(n.left, val);
        else if (val &gt; n.val) n.right = del(n.right, val);
        else {
            if (n.left == null) return n.right;
            if (n.right == null) return n.left;
            AVLNode temp = minNode(n.right);
            n.val = temp.val;
            n.right = del(n.right, temp.val);
        }
        return rebalance(n, val, false);
    }
    
    public void insert(int val) { root = ins(root, val); }
    public void remove(int val) { root = del(root, val); }
}
</code></pre>

                        <!-- Red-Black Trees -->
                        <h2 id="red-black-trees"><i class="fas fa-palette me-2"></i>Red-Black Trees</h2>
                        
                        <p><strong>Red-Black Tree</strong> is another self-balancing BST with less strict balancing than AVL. It uses node coloring to maintain approximate balance, guaranteeing O(log n) operations.</p>
                        
                        <div class="highlight-box">
                            <h4><i class="fas fa-rules me-2"></i>Red-Black Properties</h4>
                            <ol>
                                <li>Every node is either RED or BLACK</li>
                                <li>Root is always BLACK</li>
                                <li>All leaves (NIL nodes) are BLACK</li>
                                <li>Red node cannot have red children (no two reds in a row)</li>
                                <li>Every path from root to leaf has same number of black nodes (black height)</li>
                            </ol>
                        </div>

<pre><code class="language-python">class Color:
    RED = True
    BLACK = False

class RBNode:
    """Red-Black Tree Node"""
    def __init__(self, val, color=Color.RED):
        self.val = val
        self.color = color
        self.left = None
        self.right = None
        self.parent = None

class RedBlackTree:
    """
    Red-Black Tree implementation
    Note: Simplified version for understanding concepts
    """
    def __init__(self):
        self.NIL = RBNode(None, Color.BLACK)  # Sentinel nil node
        self.root = self.NIL
    
    def left_rotate(self, x):
        """Left rotation around x"""
        y = x.right
        x.right = y.left
        
        if y.left != self.NIL:
            y.left.parent = x
        
        y.parent = x.parent
        
        if x.parent is None:
            self.root = y
        elif x == x.parent.left:
            x.parent.left = y
        else:
            x.parent.right = y
        
        y.left = x
        x.parent = y
    
    def right_rotate(self, y):
        """Right rotation around y"""
        x = y.left
        y.left = x.right
        
        if x.right != self.NIL:
            x.right.parent = y
        
        x.parent = y.parent
        
        if y.parent is None:
            self.root = x
        elif y == y.parent.right:
            y.parent.right = x
        else:
            y.parent.left = x
        
        x.right = y
        y.parent = x
    
    def insert(self, val):
        """Insert value into Red-Black Tree"""
        new_node = RBNode(val)
        new_node.left = self.NIL
        new_node.right = self.NIL
        
        # BST insert
        parent = None
        current = self.root
        
        while current != self.NIL:
            parent = current
            if val < current.val:
                current = current.left
            else:
                current = current.right
        
        new_node.parent = parent
        
        if parent is None:
            self.root = new_node
        elif val < parent.val:
            parent.left = new_node
        else:
            parent.right = new_node
        
        # Fix Red-Black properties
        self._fix_insert(new_node)
    
    def _fix_insert(self, k):
        """Fix Red-Black Tree after insertion"""
        while k.parent and k.parent.color == Color.RED:
            if k.parent == k.parent.parent.right:
                uncle = k.parent.parent.left
                
                if uncle.color == Color.RED:
                    # Case 1: Uncle is red - recolor
                    uncle.color = Color.BLACK
                    k.parent.color = Color.BLACK
                    k.parent.parent.color = Color.RED
                    k = k.parent.parent
                else:
                    if k == k.parent.left:
                        # Case 2: Uncle is black, k is left child
                        k = k.parent
                        self.right_rotate(k)
                    # Case 3: Uncle is black, k is right child
                    k.parent.color = Color.BLACK
                    k.parent.parent.color = Color.RED
                    self.left_rotate(k.parent.parent)
            else:
                # Mirror cases
                uncle = k.parent.parent.right
                
                if uncle.color == Color.RED:
                    uncle.color = Color.BLACK
                    k.parent.color = Color.BLACK
                    k.parent.parent.color = Color.RED
                    k = k.parent.parent
                else:
                    if k == k.parent.right:
                        k = k.parent
                        self.left_rotate(k)
                    k.parent.color = Color.BLACK
                    k.parent.parent.color = Color.RED
                    self.right_rotate(k.parent.parent)
            
            if k == self.root:
                break
        
        self.root.color = Color.BLACK
    
    def inorder(self):
        """Return inorder traversal"""
        result = []
        self._inorder(self.root, result)
        return result
    
    def _inorder(self, node, result):
        if node != self.NIL:
            self._inorder(node.left, result)
            color = "R" if node.color == Color.RED else "B"
            result.append(f"{node.val}({color})")
            self._inorder(node.right, result)

# Example usage
rbt = RedBlackTree()
values = [10, 20, 30, 15, 25, 5, 1]

for val in values:
    rbt.insert(val)
    print(f"Inserted {val}: {rbt.inorder()}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Red-Black Tree Implementation
#include &lt;iostream&gt;
#include &lt;string&gt;

enum Color { RED, BLACK };

struct RBNode {
    int val;
    Color color;
    RBNode *left, *right, *parent;
    RBNode(int v) : val(v), color(RED), left(nullptr), right(nullptr), parent(nullptr) {}
};

class RedBlackTree {
private:
    RBNode* root;
    RBNode* NIL;  // Sentinel node
    
    void leftRotate(RBNode* x) {
        RBNode* y = x-&gt;right;
        x-&gt;right = y-&gt;left;
        if (y-&gt;left != NIL) y-&gt;left-&gt;parent = x;
        y-&gt;parent = x-&gt;parent;
        if (!x-&gt;parent) root = y;
        else if (x == x-&gt;parent-&gt;left) x-&gt;parent-&gt;left = y;
        else x-&gt;parent-&gt;right = y;
        y-&gt;left = x;
        x-&gt;parent = y;
    }
    
    void rightRotate(RBNode* y) {
        RBNode* x = y-&gt;left;
        y-&gt;left = x-&gt;right;
        if (x-&gt;right != NIL) x-&gt;right-&gt;parent = y;
        x-&gt;parent = y-&gt;parent;
        if (!y-&gt;parent) root = x;
        else if (y == y-&gt;parent-&gt;right) y-&gt;parent-&gt;right = x;
        else y-&gt;parent-&gt;left = x;
        x-&gt;right = y;
        y-&gt;parent = x;
    }
    
    void fixInsert(RBNode* k) {
        while (k-&gt;parent &amp;&amp; k-&gt;parent-&gt;color == RED) {
            if (k-&gt;parent == k-&gt;parent-&gt;parent-&gt;right) {
                RBNode* uncle = k-&gt;parent-&gt;parent-&gt;left;
                if (uncle-&gt;color == RED) {
                    uncle-&gt;color = BLACK;
                    k-&gt;parent-&gt;color = BLACK;
                    k-&gt;parent-&gt;parent-&gt;color = RED;
                    k = k-&gt;parent-&gt;parent;
                } else {
                    if (k == k-&gt;parent-&gt;left) { k = k-&gt;parent; rightRotate(k); }
                    k-&gt;parent-&gt;color = BLACK;
                    k-&gt;parent-&gt;parent-&gt;color = RED;
                    leftRotate(k-&gt;parent-&gt;parent);
                }
            } else {
                RBNode* uncle = k-&gt;parent-&gt;parent-&gt;right;
                if (uncle-&gt;color == RED) {
                    uncle-&gt;color = BLACK;
                    k-&gt;parent-&gt;color = BLACK;
                    k-&gt;parent-&gt;parent-&gt;color = RED;
                    k = k-&gt;parent-&gt;parent;
                } else {
                    if (k == k-&gt;parent-&gt;right) { k = k-&gt;parent; leftRotate(k); }
                    k-&gt;parent-&gt;color = BLACK;
                    k-&gt;parent-&gt;parent-&gt;color = RED;
                    rightRotate(k-&gt;parent-&gt;parent);
                }
            }
            if (k == root) break;
        }
        root-&gt;color = BLACK;
    }
    
public:
    RedBlackTree() {
        NIL = new RBNode(0);
        NIL-&gt;color = BLACK;
        root = NIL;
    }
    
    void insert(int val) {
        RBNode* node = new RBNode(val);
        node-&gt;left = node-&gt;right = NIL;
        RBNode* parent = nullptr, *current = root;
        while (current != NIL) {
            parent = current;
            current = (val &lt; current-&gt;val) ? current-&gt;left : current-&gt;right;
        }
        node-&gt;parent = parent;
        if (!parent) root = node;
        else if (val &lt; parent-&gt;val) parent-&gt;left = node;
        else parent-&gt;right = node;
        fixInsert(node);
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Red-Black Tree Implementation

enum Color { RED, BLACK }

class RBNode {
    int val;
    Color color;
    RBNode left, right, parent;
    RBNode(int v) { val = v; color = Color.RED; }
}

class RedBlackTree {
    private RBNode root;
    private RBNode NIL;  // Sentinel node
    
    public RedBlackTree() {
        NIL = new RBNode(0);
        NIL.color = Color.BLACK;
        root = NIL;
    }
    
    private void leftRotate(RBNode x) {
        RBNode y = x.right;
        x.right = y.left;
        if (y.left != NIL) y.left.parent = x;
        y.parent = x.parent;
        if (x.parent == null) root = y;
        else if (x == x.parent.left) x.parent.left = y;
        else x.parent.right = y;
        y.left = x;
        x.parent = y;
    }
    
    private void rightRotate(RBNode y) {
        RBNode x = y.left;
        y.left = x.right;
        if (x.right != NIL) x.right.parent = y;
        x.parent = y.parent;
        if (y.parent == null) root = x;
        else if (y == y.parent.right) y.parent.right = x;
        else y.parent.left = x;
        x.right = y;
        y.parent = x;
    }
    
    private void fixInsert(RBNode k) {
        while (k.parent != null &amp;&amp; k.parent.color == Color.RED) {
            if (k.parent == k.parent.parent.right) {
                RBNode uncle = k.parent.parent.left;
                if (uncle.color == Color.RED) {
                    uncle.color = Color.BLACK;
                    k.parent.color = Color.BLACK;
                    k.parent.parent.color = Color.RED;
                    k = k.parent.parent;
                } else {
                    if (k == k.parent.left) { k = k.parent; rightRotate(k); }
                    k.parent.color = Color.BLACK;
                    k.parent.parent.color = Color.RED;
                    leftRotate(k.parent.parent);
                }
            } else {
                RBNode uncle = k.parent.parent.right;
                if (uncle.color == Color.RED) {
                    uncle.color = Color.BLACK;
                    k.parent.color = Color.BLACK;
                    k.parent.parent.color = Color.RED;
                    k = k.parent.parent;
                } else {
                    if (k == k.parent.right) { k = k.parent; leftRotate(k); }
                    k.parent.color = Color.BLACK;
                    k.parent.parent.color = Color.RED;
                    rightRotate(k.parent.parent);
                }
            }
            if (k == root) break;
        }
        root.color = Color.BLACK;
    }
    
    public void insert(int val) {
        RBNode node = new RBNode(val);
        node.left = node.right = NIL;
        RBNode parent = null, current = root;
        while (current != NIL) {
            parent = current;
            current = (val &lt; current.val) ? current.left : current.right;
        }
        node.parent = parent;
        if (parent == null) root = node;
        else if (val &lt; parent.val) parent.left = node;
        else parent.right = node;
        fixInsert(node);
    }
}
</code></pre>

                        <!-- Comparison -->
                        <h2 id="comparison"><i class="fas fa-chart-bar me-2"></i>Tree Comparison</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-table me-2"></i>BST vs AVL vs Red-Black</h4>
                            <table class="table table-bordered">
                                <thead>
                                    <tr>
                                        <th>Property</th>
                                        <th>BST</th>
                                        <th>AVL</th>
                                        <th>Red-Black</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Search</td>
                                        <td>O(h) - O(n) worst</td>
                                        <td>O(log n)</td>
                                        <td>O(log n)</td>
                                    </tr>
                                    <tr>
                                        <td>Insert</td>
                                        <td>O(h)</td>
                                        <td>O(log n)</td>
                                        <td>O(log n)</td>
                                    </tr>
                                    <tr>
                                        <td>Delete</td>
                                        <td>O(h)</td>
                                        <td>O(log n)</td>
                                        <td>O(log n)</td>
                                    </tr>
                                    <tr>
                                        <td>Balance</td>
                                        <td>None</td>
                                        <td>Strict (1)</td>
                                        <td>Relaxed</td>
                                    </tr>
                                    <tr>
                                        <td>Rotations</td>
                                        <td>None</td>
                                        <td>More frequent</td>
                                        <td>Less frequent</td>
                                    </tr>
                                    <tr>
                                        <td>Best for</td>
                                        <td>Static data</td>
                                        <td>Lookups</td>
                                        <td>Insert/Delete heavy</td>
                                    </tr>
                                    <tr>
                                        <td>Used in</td>
                                        <td>Simple apps</td>
                                        <td>Databases</td>
                                        <td>Java TreeMap, C++ map</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Interview Patterns -->
                        <h2 id="interview-patterns"><i class="fas fa-brain me-2"></i>Interview Patterns</h2>
                        
                        <h3>Kth Smallest Element in BST</h3>
                        
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def kth_smallest(root, k):
    """
    LeetCode 230: Kth Smallest Element in a BST
    Time: O(H + k) where H is height
    Space: O(H) for stack
    """
    stack = []
    current = root
    count = 0
    
    while stack or current:
        # Go to leftmost node
        while current:
            stack.append(current)
            current = current.left
        
        # Process node
        current = stack.pop()
        count += 1
        
        if count == k:
            return current.val
        
        # Move to right subtree
        current = current.right
    
    return -1  # k is larger than tree size

# Build BST: [3, 1, 4, null, 2]
root = TreeNode(3)
root.left = TreeNode(1)
root.right = TreeNode(4)
root.left.right = TreeNode(2)

print(f"1st smallest: {kth_smallest(root, 1)}")  # 1
print(f"3rd smallest: {kth_smallest(root, 3)}")  # 3
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 230 - Kth Smallest Element in a BST
// Time: O(H + k), Space: O(H)
#include &lt;stack&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        std::stack&lt;TreeNode*&gt; stk;
        TreeNode* current = root;
        int count = 0;
        
        while (!stk.empty() || current) {
            // Go to leftmost node
            while (current) {
                stk.push(current);
                current = current-&gt;left;
            }
            
            // Process node
            current = stk.top(); stk.pop();
            count++;
            
            if (count == k) return current-&gt;val;
            
            // Move to right subtree
            current = current-&gt;right;
        }
        return -1;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 230 - Kth Smallest Element in a BST
// Time: O(H + k), Space: O(H)
import java.util.*;

class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        TreeNode current = root;
        int count = 0;
        
        while (!stack.isEmpty() || current != null) {
            // Go to leftmost node
            while (current != null) {
                stack.push(current);
                current = current.left;
            }
            
            // Process node
            current = stack.pop();
            count++;
            
            if (count == k) return current.val;
            
            // Move to right subtree
            current = current.right;
        }
        return -1;
    }
}
</code></pre>

                        <h3>Lowest Common Ancestor in BST</h3>
                        
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def lowest_common_ancestor_bst(root, p, q):
    """
    LeetCode 235: Lowest Common Ancestor of a BST
    Exploit BST property for O(h) solution
    Time: O(h), Space: O(1) iterative
    """
    # Ensure p.val < q.val for easier comparison
    if p.val > q.val:
        p, q = q, p
    
    current = root
    while current:
        if current.val > q.val:
            # Both p and q are in left subtree
            current = current.left
        elif current.val < p.val:
            # Both p and q are in right subtree
            current = current.right
        else:
            # Split point found: p <= current <= q
            return current
    
    return None

# Build BST: [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5]
root = TreeNode(6)
root.left = TreeNode(2, TreeNode(0), TreeNode(4, TreeNode(3), TreeNode(5)))
root.right = TreeNode(8, TreeNode(7), TreeNode(9))

p = root.left       # Node 2
q = root.left.right  # Node 4

lca = lowest_common_ancestor_bst(root, p, q)
print(f"LCA of {p.val} and {q.val}: {lca.val}")  # 2

p = root.left   # Node 2
q = root.right  # Node 8
lca = lowest_common_ancestor_bst(root, p, q)
print(f"LCA of {p.val} and {q.val}: {lca.val}")  # 6
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 235 - Lowest Common Ancestor of a BST
// Time: O(h), Space: O(1)

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // Ensure p-&gt;val &lt; q-&gt;val
        if (p-&gt;val &gt; q-&gt;val) std::swap(p, q);
        
        TreeNode* current = root;
        while (current) {
            if (current-&gt;val &gt; q-&gt;val) {
                current = current-&gt;left;  // Both in left subtree
            } else if (current-&gt;val &lt; p-&gt;val) {
                current = current-&gt;right; // Both in right subtree
            } else {
                return current;  // Split point: p &lt;= current &lt;= q
            }
        }
        return nullptr;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 235 - Lowest Common Ancestor of a BST
// Time: O(h), Space: O(1)

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // Ensure p.val &lt; q.val
        if (p.val &gt; q.val) {
            TreeNode temp = p; p = q; q = temp;
        }
        
        TreeNode current = root;
        while (current != null) {
            if (current.val &gt; q.val) {
                current = current.left;  // Both in left subtree
            } else if (current.val &lt; p.val) {
                current = current.right; // Both in right subtree
            } else {
                return current;  // Split point: p &lt;= current &lt;= q
            }
        }
        return null;
    }
}
</code></pre>

                        <h3>Convert Sorted Array to BST</h3>
                        
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def sorted_array_to_bst(nums):
    """
    LeetCode 108: Convert Sorted Array to BST
    Build height-balanced BST from sorted array
    Time: O(n), Space: O(log n) recursion
    """
    def build(left, right):
        if left > right:
            return None
        
        # Choose middle element as root for balance
        mid = (left + right) // 2
        
        node = TreeNode(nums[mid])
        node.left = build(left, mid - 1)
        node.right = build(mid + 1, right)
        
        return node
    
    return build(0, len(nums) - 1)

def get_height(root):
    if not root:
        return 0
    return 1 + max(get_height(root.left), get_height(root.right))

def levelorder(root):
    if not root:
        return []
    from collections import deque
    result = []
    queue = deque([root])
    while queue:
        node = queue.popleft()
        result.append(node.val)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return result

# Example
nums = [-10, -3, 0, 5, 9]
root = sorted_array_to_bst(nums)

print("Level order:", levelorder(root))  # [0, -3, 9, -10, 5] or similar balanced
print("Tree height:", get_height(root))  # Should be ~3 for 5 elements
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 108 - Convert Sorted Array to BST
// Time: O(n), Space: O(log n) recursion
#include &lt;vector&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
private:
    TreeNode* build(std::vector&lt;int&gt;&amp; nums, int left, int right) {
        if (left &gt; right) return nullptr;
        
        int mid = left + (right - left) / 2;
        TreeNode* node = new TreeNode(nums[mid]);
        node-&gt;left = build(nums, left, mid - 1);
        node-&gt;right = build(nums, mid + 1, right);
        
        return node;
    }
    
public:
    TreeNode* sortedArrayToBST(std::vector&lt;int&gt;&amp; nums) {
        return build(nums, 0, nums.size() - 1);
    }
};

// Usage:
// std::vector&lt;int&gt; nums = {-10, -3, 0, 5, 9};
// TreeNode* root = solution.sortedArrayToBST(nums);
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 108 - Convert Sorted Array to BST
// Time: O(n), Space: O(log n) recursion

class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return build(nums, 0, nums.length - 1);
    }
    
    private TreeNode build(int[] nums, int left, int right) {
        if (left &gt; right) return null;
        
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = build(nums, left, mid - 1);
        node.right = build(nums, mid + 1, right);
        
        return node;
    }
}

// Usage:
// int[] nums = {-10, -3, 0, 5, 9};
// TreeNode root = solution.sortedArrayToBST(nums);
</code></pre>

                        <h3>Search in BST</h3>
                        
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def search_bst(root, val):
    """
    LeetCode 700: Search in a Binary Search Tree
    Time: O(h), Space: O(1)
    """
    while root:
        if val == root.val:
            return root
        elif val < root.val:
            root = root.left
        else:
            root = root.right
    return None

def count_nodes_in_range(root, low, high):
    """
    Count nodes in BST within range [low, high]
    Time: O(h + k) where k is number of nodes in range
    """
    if not root:
        return 0
    
    # If current node is in range
    if low <= root.val <= high:
        return (1 + count_nodes_in_range(root.left, low, high) +
                count_nodes_in_range(root.right, low, high))
    
    # If current node is too small, search right
    if root.val < low:
        return count_nodes_in_range(root.right, low, high)
    
    # If current node is too large, search left
    return count_nodes_in_range(root.left, low, high)

# Build BST: [10, 5, 15, 3, 7, null, 18]
root = TreeNode(10)
root.left = TreeNode(5, TreeNode(3), TreeNode(7))
root.right = TreeNode(15, None, TreeNode(18))

# Search
found = search_bst(root, 7)
print(f"Found 7: {found.val if found else None}")

# Count in range
count = count_nodes_in_range(root, 5, 15)
print(f"Nodes in range [5, 15]: {count}")  # 4: 5, 7, 10, 15
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 700 - Search in a Binary Search Tree
// Time: O(h), Space: O(1)

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root) {
            if (val == root-&gt;val) return root;
            else if (val &lt; root-&gt;val) root = root-&gt;left;
            else root = root-&gt;right;
        }
        return nullptr;
    }
    
    // Count nodes in BST within range [low, high]
    int countNodesInRange(TreeNode* root, int low, int high) {
        if (!root) return 0;
        
        if (low &lt;= root-&gt;val &amp;&amp; root-&gt;val &lt;= high) {
            return 1 + countNodesInRange(root-&gt;left, low, high) +
                       countNodesInRange(root-&gt;right, low, high);
        }
        if (root-&gt;val &lt; low) return countNodesInRange(root-&gt;right, low, high);
        return countNodesInRange(root-&gt;left, low, high);
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 700 - Search in a Binary Search Tree
// Time: O(h), Space: O(1)

class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while (root != null) {
            if (val == root.val) return root;
            else if (val &lt; root.val) root = root.left;
            else root = root.right;
        }
        return null;
    }
    
    // Count nodes in BST within range [low, high]
    public int countNodesInRange(TreeNode root, int low, int high) {
        if (root == null) return 0;
        
        if (low &lt;= root.val &amp;&amp; root.val &lt;= high) {
            return 1 + countNodesInRange(root.left, low, high) +
                       countNodesInRange(root.right, low, high);
        }
        if (root.val &lt; low) return countNodesInRange(root.right, low, high);
        return countNodesInRange(root.left, low, high);
    }
}
</code></pre>

                        <!-- LeetCode Problems -->
                        <h2 id="leetcode"><i class="fas fa-code me-2"></i>LeetCode Practice Problems</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-tasks me-2"></i>Essential BST Problems</h4>
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>#</th>
                                        <th>Problem</th>
                                        <th>Difficulty</th>
                                        <th>Key Concept</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>98</td>
                                        <td>Validate Binary Search Tree</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>BST validation with bounds</td>
                                    </tr>
                                    <tr>
                                        <td>700</td>
                                        <td>Search in a Binary Search Tree</td>
                                        <td><span class="badge badge-easy">Easy</span></td>
                                        <td>Basic BST search</td>
                                    </tr>
                                    <tr>
                                        <td>701</td>
                                        <td>Insert into a Binary Search Tree</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>BST insertion</td>
                                    </tr>
                                    <tr>
                                        <td>450</td>
                                        <td>Delete Node in a BST</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>BST deletion with 3 cases</td>
                                    </tr>
                                    <tr>
                                        <td>230</td>
                                        <td>Kth Smallest Element in a BST</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Inorder traversal</td>
                                    </tr>
                                    <tr>
                                        <td>235</td>
                                        <td>Lowest Common Ancestor of a BST</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>BST property for LCA</td>
                                    </tr>
                                    <tr>
                                        <td>108</td>
                                        <td>Convert Sorted Array to BST</td>
                                        <td><span class="badge badge-easy">Easy</span></td>
                                        <td>Balanced BST construction</td>
                                    </tr>
                                    <tr>
                                        <td>109</td>
                                        <td>Convert Sorted List to BST</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Two pointers + recursion</td>
                                    </tr>
                                    <tr>
                                        <td>653</td>
                                        <td>Two Sum IV - Input is a BST</td>
                                        <td><span class="badge badge-easy">Easy</span></td>
                                        <td>BST + Hash Set</td>
                                    </tr>
                                    <tr>
                                        <td>1382</td>
                                        <td>Balance a Binary Search Tree</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Inorder + rebuild balanced</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Series Navigation -->
                        <h2 id="series-nav"><i class="fas fa-book me-2"></i>Complete DSA Series</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-graduation-cap me-2"></i>FAANG Interview Preparation</h4>
                            <div class="row">
                                <div class="col-md-6">
                                    <ol>
                                        <li><a href="dsa-foundations-memory-complexity.html">Foundations & Complexity</a></li>
                                        <li><a href="dsa-recursion-complete-guide.html">Recursion Deep Dive</a></li>
                                        <li><a href="dsa-arrays-adt-operations.html">Arrays & ADT</a></li>
                                        <li><a href="dsa-strings-manipulation.html">Strings & Manipulation</a></li>
                                        <li><a href="dsa-matrices-special-sparse.html">Matrices & Sparse</a></li>
                                        <li><a href="dsa-linked-lists-guide.html">Linked Lists</a></li>
                                    </ol>
                                </div>
                                <div class="col-md-6">
                                    <ol start="7">
                                        <li><a href="dsa-stack-applications.html">Stack & Applications</a></li>
                                        <li><a href="dsa-queue-implementations.html">Queue & Variants</a></li>
                                        <li><a href="dsa-trees-fundamentals.html">Trees & Traversals</a></li>
                                        <li><strong>BST & Balanced Trees (You are here)</strong></li>
                                        <li><a href="dsa-heaps-sorting-hashing.html">Heaps, Sorting & Hashing</a></li>
                                        <li><a href="dsa-graphs-dp-greedy-backtracking.html">Graphs, DP & Greedy</a></li>
                                    </ol>
                                </div>
                            </div>
                        </div>

                        <!-- Related Posts -->
                        <div class="related-posts">
                            <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 9: Trees & Traversals</h5>
                                <p class="text-muted small mb-2">Binary tree fundamentals, DFS, BFS, and classic tree problems.</p>
                                <a href="dsa-trees-fundamentals.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 11: Heaps, Sorting & Hashing</h5>
                                <p class="text-muted small mb-2">Priority queues, sorting algorithms, and hash table implementations.</p>
                                <a href="dsa-heaps-sorting-hashing.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 12: Graphs, DP, Greedy & Backtracking</h5>
                                <p class="text-muted small mb-2">Graph algorithms, dynamic programming, greedy algorithms, and backtracking patterns.</p>
                                <a href="dsa-graphs-dp-greedy-backtracking.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest"><i class="fab fa-pinterest-p"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content?  <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Scroll to Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Cookie Consent -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>
    
    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    
    <!-- Custom Scripts -->
    <script>
        // Scroll to Top
        document.addEventListener('DOMContentLoaded', function() {
            const scrollBtn = document.getElementById('scrollToTop');
            
            window.addEventListener('scroll', function() {
                if (window.scrollY > 300) {
                    scrollBtn.classList.add('show');
                } else {
                    scrollBtn.classList.remove('show');
                }
            });
            
            scrollBtn.addEventListener('click', function() {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });
        
        // TOC Navigation
        function openNav() {
            document.getElementById('tocSidenav').classList.add('open');
            document.getElementById('tocOverlay').classList.add('show');
            document.body.style.overflow = 'hidden';
        }
        
        function closeNav() {
            document.getElementById('tocSidenav').classList.remove('open');
            document.getElementById('tocOverlay').classList.remove('show');
            document.body.style.overflow = 'auto';
        }
        
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeNav();
        });
        
        // Active section highlighting
        document.addEventListener('DOMContentLoaded', function() {
            const sections = document.querySelectorAll('[id]');
            const tocLinks = document.querySelectorAll('.sidenav-toc a');
            
            function highlightActive() {
                let current = '';
                sections.forEach(section => {
                    if (window.scrollY >= section.offsetTop - 200) {
                        current = section.getAttribute('id');
                    }
                });
                
                tocLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === '#' + current) {
                        link.classList.add('active');
                    }
                });
            }
            
            window.addEventListener('scroll', highlightActive);
            highlightActive();
        });
        
        // Prism Theme Switcher
        const themes = {
            'prism-theme': 'Tomorrow Night',
            'prism-default': 'Default',
            'prism-dark': 'Dark',
            'prism-twilight': 'Twilight',
            'prism-okaidia': 'Okaidia',
            'prism-solarizedlight': 'Solarized Light'
        };
        
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        
        function switchTheme(themeId) {
            Object.keys(themes).forEach(id => {
                const link = document.getElementById(id);
                if (link) link.disabled = true;
            });
            
            const selectedLink = document.getElementById(themeId);
            if (selectedLink) {
                selectedLink.disabled = false;
                localStorage.setItem('prism-theme', themeId);
            }
            
            document.querySelectorAll('select.prism-theme-selector').forEach(dropdown => {
                dropdown.value = themeId;
            });
            
            setTimeout(() => Prism.highlightAll(), 10);
        }
        
        document.addEventListener('DOMContentLoaded', () => switchTheme(savedTheme));
        
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) {
            const select = document.createElement('select');
            select.className = 'prism-theme-selector';
            select.setAttribute('aria-label', 'Select code theme');
            
            Object.keys(themes).forEach(themeId => {
                const option = document.createElement('option');
                option.value = themeId;
                option.textContent = themes[themeId];
                if (themeId === savedTheme) option.selected = true;
                select.appendChild(option);
            });
            
            select.addEventListener('change', e => switchTheme(e.target.value));
            return select;
        });
    </script>

    
    <!-- Category Indicator -->
    <div id="categoryIndicator" class="category-indicator" title="Current Section">
        <i class="fas fa-tag"></i><span id="categoryText">Technology</span>
    </div>

            <!-- Scroll-to-Top and Category Indicator Script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const scrollToTopBtn = document.getElementById('scrollToTop');
            const categoryIndicator = document.getElementById('categoryIndicator');
            const categoryText = document.getElementById('categoryText');
            
            // Auto-detect H2 sections in the article (works with or without id)
            const h2Elements = document.querySelectorAll('.blog-content h2');
            const sections = [];
            h2Elements.forEach(function(h2, index) {
                // Get text without icon
                let text = h2.textContent.trim().replace(/^\d+\.\s*/, '');
                // Truncate to 25 chars
                if (text.length > 25) text = text.substring(0, 22) + '...';
                sections.push({ element: h2, name: text });
            });
            
            // Fallback to article category if no sections found
            const articleCategory = categoryText ? categoryText.textContent : 'Article';
            
            // Show/hide button on scroll and update section
            window.addEventListener('scroll', function() {
                if (window.scrollY > 300) {
                    if (scrollToTopBtn) scrollToTopBtn.classList.add('show');
                    if (categoryIndicator) categoryIndicator.classList.add('show');
                } else {
                    if (scrollToTopBtn) scrollToTopBtn.classList.remove('show');
                    if (categoryIndicator) categoryIndicator.classList.remove('show');
                }
                
                // Update current section
                updateCurrentSection();
            });
            
            // Update section based on viewport position
            function updateCurrentSection() {
                if (!categoryText || sections.length === 0) return;
                
                let currentSection = articleCategory;
                
                for (let section of sections) {
                    const rect = section.element.getBoundingClientRect();
                    if (rect.top <= window.innerHeight / 2) {
                        currentSection = section.name;
                    }
                }
                
                categoryText.textContent = currentSection;
            }
            
            // Smooth scroll to top on click
            if (scrollToTopBtn) {
                scrollToTopBtn.addEventListener('click', function() {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
            }
        });
    </script>
</body>
</html>
