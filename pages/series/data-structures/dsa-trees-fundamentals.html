<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 9 of the Complete DSA Series: Master tree data structures with binary trees, tree traversals (inorder, preorder, postorder, level-order), tree properties, and FAANG interview problems." />
    <meta name="author" content="Wasil Zafar" />
    <meta name="keywords" content="Trees, Binary Tree, Tree Traversal, DSA, Data Structures, Inorder, Preorder, Postorder, FAANG Interview, LeetCode" />
    <meta property="og:title" content="Complete DSA Series Part 9: Trees" />
    <meta property="og:description" content="Master binary trees, tree traversals, tree properties, construction from traversals, and FAANG interview problems." />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2026-01-28" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />
    
    <title>Complete DSA Series Part 9: Trees - Wasil Zafar</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />

    <!-- Prism.js Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <!-- Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE']
        });
        gtag('consent', 'default', {
            'ad_storage': 'granted',
            'ad_user_data': 'granted',
            'ad_personalization': 'granted',
            'analytics_storage': 'granted'
        });
        gtag('set', 'url_passthrough', true);
    </script>

    <!-- Google Tag Manager -->
    <script>
        (function(w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s),
                dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>

    </head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link">
                    <i class="fas fa-arrow-left me-2"></i>Back to Technology
                </a>
                <h1 class="display-4 fw-bold mb-3">Complete DSA Series Part 9: Trees</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>January 28, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>40 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
                <p class="lead">Master binary trees with all traversal methods (DFS and BFS), tree properties, construction from traversals, and essential FAANG interview problems.</p>
            </div>
        </div>
    </section>

    <!-- TOC Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close">&times;</button>
        </div>
        <ol>
            <li>
                <a href="#introduction" onclick="closeNav()">Introduction</a>
                <ul>
                    <li><a href="#terminology" onclick="closeNav()">Terminology</a></li>
                    <li><a href="#types" onclick="closeNav()">Tree Types</a></li>
                </ul>
            </li>
            <li>
                <a href="#representation" onclick="closeNav()">Tree Representation</a>
            </li>
            <li>
                <a href="#traversals" onclick="closeNav()">Tree Traversals</a>
                <ul>
                    <li><a href="#dfs" onclick="closeNav()">DFS (Inorder, Preorder, Postorder)</a></li>
                    <li><a href="#bfs" onclick="closeNav()">BFS (Level Order)</a></li>
                </ul>
            </li>
            <li>
                <a href="#properties" onclick="closeNav()">Tree Properties</a>
            </li>
            <li>
                <a href="#construction" onclick="closeNav()">Tree Construction</a>
            </li>
            <li>
                <a href="#leetcode" onclick="closeNav()">LeetCode Problems</a>
            </li>
        </ol>
    </div>

    <!-- Overlay -->
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Main Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">
                    <div class="blog-content">

                        <!-- Introduction -->
                        <h2 id="introduction"><i class="fas fa-tree me-2" style="color: var(--color-teal);"></i>Introduction to Trees</h2>
                        
                        <p>A tree is a hierarchical data structure consisting of nodes connected by edges. Unlike linear structures (arrays, linked lists), trees represent hierarchical relationships with a single <strong>root</strong> node and zero or more <strong>child</strong> nodes forming subtrees. Trees are fundamental in computer science, used in file systems, databases, compilers, and many algorithms.</p>

                        <div class="highlight-box">
                            <i class="fas fa-lightbulb"></i>
                            <strong>Key Insight:</strong> Trees are recursive structures - every subtree is itself a tree. This recursive nature makes them perfect for divide-and-conquer algorithms. A binary tree with n nodes has n-1 edges and can have up to 2^h - 1 nodes at height h.
                        </div>

                        <div class="experiment-card">
                            <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                            <div class="mb-2">
                                <span class="badge bg-teal me-2">12-Part Series</span>
                                <span class="badge bg-crimson">FAANG Interview Prep</span>
                            </div>
                            <ol>
                                <li><a href="dsa-foundations-memory-complexity.html">Foundations, Memory & Complexity</a></li>
                                <li><a href="dsa-recursion-complete-guide.html">Recursion Complete Guide</a></li>
                                <li><a href="dsa-arrays-adt-operations.html">Arrays & Array ADT</a></li>
                                <li><a href="dsa-strings-manipulation.html">Strings</a></li>
                                <li><a href="dsa-matrices-special-sparse.html">Matrices</a></li>
                                <li><a href="dsa-linked-lists-guide.html">Linked Lists</a></li>
                                <li><a href="dsa-stack-applications.html">Stack</a></li>
                                <li><a href="dsa-queue-implementations.html">Queue</a></li>
                                <li><strong>Trees (This Guide)</strong></li>
                                <li><a href="dsa-bst-avl-redblack.html">BST & Balanced Trees</a></li>
                                <li><a href="dsa-heaps-sorting-hashing.html">Heaps, Sorting & Hashing</a></li>
                                <li><a href="dsa-graphs-dp-greedy-backtracking.html">Graphs, DP, Greedy & Backtracking</a></li>
                            </ol>
                        </div>

                        <!-- Terminology -->
                        <h3 id="terminology">Tree Terminology</h3>

                        <div class="highlight-box">
                            <h4><i class="fas fa-book me-2"></i>Key Terms</h4>
                            <table class="complexity-table">
                                <thead>
                                    <tr>
                                        <th>Term</th>
                                        <th>Definition</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Root</strong></td>
                                        <td>Topmost node with no parent</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Leaf</strong></td>
                                        <td>Node with no children</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Internal Node</strong></td>
                                        <td>Node with at least one child</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Height</strong></td>
                                        <td>Longest path from node to leaf</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Depth</strong></td>
                                        <td>Path length from root to node</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Level</strong></td>
                                        <td>Depth + 1 (root is level 1)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Degree</strong></td>
                                        <td>Number of children of a node</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Ancestor/Descendant</strong></td>
                                        <td>Nodes in the path from root</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Types -->
                        <h3 id="types">Types of Binary Trees</h3>

                        <div class="highlight-box">
                            <h4><i class="fas fa-sitemap me-2"></i>Binary Tree Types</h4>
                            <ul>
                                <li><strong>Full Binary Tree:</strong> Every node has 0 or 2 children</li>
                                <li><strong>Complete Binary Tree:</strong> All levels filled except possibly the last, filled left to right</li>
                                <li><strong>Perfect Binary Tree:</strong> All internal nodes have 2 children, all leaves at same level</li>
                                <li><strong>Balanced Binary Tree:</strong> Height of left and right subtrees differ by at most 1</li>
                                <li><strong>Degenerate/Skewed:</strong> Each node has only one child (like a linked list)</li>
                            </ul>
                        </div>

                        <!-- Representation -->
                        <h2 id="representation"><i class="fas fa-code me-2" style="color: var(--color-teal);"></i>Tree Representation</h2>

<pre><code class="language-python"># Binary Tree Node Class
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
    
    def __repr__(self):
        return f"TreeNode({self.val})"

# Build a simple tree
#       1
#      / \
#     2   3
#    / \   \
#   4   5   6

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.right = TreeNode(6)

print(f"Root: {root.val}")
print(f"Left child: {root.left.val}")
print(f"Right child: {root.right.val}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Binary Tree Node Class
#include &lt;iostream&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* l, TreeNode* r) : val(x), left(l), right(r) {}
};

int main() {
    // Build a simple tree
    //       1
    //      / \
    //     2   3
    //    / \   \
    //   4   5   6
    
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;left-&gt;left = new TreeNode(4);
    root-&gt;left-&gt;right = new TreeNode(5);
    root-&gt;right-&gt;right = new TreeNode(6);
    
    std::cout &lt;&lt; "Root: " &lt;&lt; root-&gt;val &lt;&lt; std::endl;
    std::cout &lt;&lt; "Left child: " &lt;&lt; root-&gt;left-&gt;val &lt;&lt; std::endl;
    std::cout &lt;&lt; "Right child: " &lt;&lt; root-&gt;right-&gt;val &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Binary Tree Node Class

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode(int val) {
        this.val = val;
    }
    
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
    
    @Override
    public String toString() {
        return "TreeNode(" + val + ")";
    }
}

public class TreeDemo {
    public static void main(String[] args) {
        // Build a simple tree
        //       1
        //      / \
        //     2   3
        //    / \   \
        //   4   5   6
        
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.right = new TreeNode(6);
        
        System.out.println("Root: " + root.val);
        System.out.println("Left child: " + root.left.val);
        System.out.println("Right child: " + root.right.val);
    }
}
</code></pre>

<pre><code class="language-python"># Array Representation (for Complete Binary Trees)
# Parent at index i: children at 2i+1 and 2i+2
# Child at index i: parent at (i-1)//2

class ArrayBinaryTree:
    def __init__(self, capacity=100):
        self.tree = [None] * capacity
        self.size = 0
    
    def insert(self, val):
        """Insert into complete binary tree"""
        if self.size >= len(self.tree):
            raise OverflowError("Tree is full")
        self.tree[self.size] = val
        self.size += 1
    
    def get_parent(self, i):
        """Get parent index"""
        if i == 0:
            return None
        return (i - 1) // 2
    
    def get_left_child(self, i):
        """Get left child index"""
        left = 2 * i + 1
        return left if left < self.size else None
    
    def get_right_child(self, i):
        """Get right child index"""
        right = 2 * i + 2
        return right if right < self.size else None
    
    def display(self):
        print("Array representation:", self.tree[:self.size])

# Build complete binary tree
arr_tree = ArrayBinaryTree()
for val in [1, 2, 3, 4, 5, 6, 7]:
    arr_tree.insert(val)

arr_tree.display()  # [1, 2, 3, 4, 5, 6, 7]
print(f"Parent of index 3: {arr_tree.get_parent(3)}")  # 1
print(f"Left child of index 1: {arr_tree.get_left_child(1)}")  # 3
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Array Representation (for Complete Binary Trees)
// Parent at index i: children at 2i+1 and 2i+2
// Child at index i: parent at (i-1)/2
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;optional&gt;

template &lt;typename T&gt;
class ArrayBinaryTree {
private:
    std::vector&lt;std::optional&lt;T&gt;&gt; tree;
    size_t _size;

public:
    ArrayBinaryTree(int capacity = 100) : tree(capacity), _size(0) {}
    
    void insert(const T&amp; val) {
        if (_size &gt;= tree.size()) {
            throw std::overflow_error("Tree is full");
        }
        tree[_size++] = val;
    }
    
    std::optional&lt;int&gt; getParent(int i) const {
        if (i == 0) return std::nullopt;
        return (i - 1) / 2;
    }
    
    std::optional&lt;int&gt; getLeftChild(int i) const {
        int left = 2 * i + 1;
        return (left &lt; _size) ? std::optional&lt;int&gt;(left) : std::nullopt;
    }
    
    std::optional&lt;int&gt; getRightChild(int i) const {
        int right = 2 * i + 2;
        return (right &lt; _size) ? std::optional&lt;int&gt;(right) : std::nullopt;
    }
    
    void display() const {
        std::cout &lt;&lt; "Array representation: [";
        for (size_t i = 0; i &lt; _size; i++) {
            std::cout &lt;&lt; tree[i].value();
            if (i &lt; _size - 1) std::cout &lt;&lt; ", ";
        }
        std::cout &lt;&lt; "]" &lt;&lt; std::endl;
    }
};

int main() {
    ArrayBinaryTree&lt;int&gt; arrTree;
    for (int val : {1, 2, 3, 4, 5, 6, 7}) {
        arrTree.insert(val);
    }
    
    arrTree.display();  // [1, 2, 3, 4, 5, 6, 7]
    auto parent = arrTree.getParent(3);
    std::cout &lt;&lt; "Parent of index 3: " &lt;&lt; (parent ? std::to_string(*parent) : "None") &lt;&lt; std::endl;  // 1
    auto left = arrTree.getLeftChild(1);
    std::cout &lt;&lt; "Left child of index 1: " &lt;&lt; (left ? std::to_string(*left) : "None") &lt;&lt; std::endl;  // 3
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Array Representation (for Complete Binary Trees)
// Parent at index i: children at 2i+1 and 2i+2
// Child at index i: parent at (i-1)/2
import java.util.*;

public class ArrayBinaryTree&lt;T&gt; {
    private Object[] tree;
    private int size;
    
    public ArrayBinaryTree(int capacity) {
        tree = new Object[capacity];
        size = 0;
    }
    
    public void insert(T val) {
        if (size &gt;= tree.length) {
            throw new IllegalStateException("Tree is full");
        }
        tree[size++] = val;
    }
    
    public Integer getParent(int i) {
        if (i == 0) return null;
        return (i - 1) / 2;
    }
    
    public Integer getLeftChild(int i) {
        int left = 2 * i + 1;
        return (left &lt; size) ? left : null;
    }
    
    public Integer getRightChild(int i) {
        int right = 2 * i + 2;
        return (right &lt; size) ? right : null;
    }
    
    public void display() {
        System.out.print("Array representation: [");
        for (int i = 0; i &lt; size; i++) {
            System.out.print(tree[i]);
            if (i &lt; size - 1) System.out.print(", ");
        }
        System.out.println("]");
    }
    
    public static void main(String[] args) {
        ArrayBinaryTree&lt;Integer&gt; arrTree = new ArrayBinaryTree&lt;&gt;(100);
        for (int val : new int[]{1, 2, 3, 4, 5, 6, 7}) {
            arrTree.insert(val);
        }
        
        arrTree.display();  // [1, 2, 3, 4, 5, 6, 7]
        System.out.println("Parent of index 3: " + arrTree.getParent(3));  // 1
        System.out.println("Left child of index 1: " + arrTree.getLeftChild(1));  // 3
    }
}
</code></pre>

                        <!-- Traversals -->
                        <h2 id="traversals"><i class="fas fa-route me-2" style="color: var(--color-teal);"></i>Tree Traversals</h2>

                        <h3 id="dfs">DFS Traversals (Depth-First)</h3>

<pre><code class="language-python"># DFS Traversals - Recursive Implementation
# Time: O(n), Space: O(h) where h is height

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder_recursive(root):
    """Inorder: Left -> Root -> Right (gives sorted order for BST)"""
    result = []
    
    def traverse(node):
        if not node:
            return
        traverse(node.left)
        result.append(node.val)
        traverse(node.right)
    
    traverse(root)
    return result

def preorder_recursive(root):
    """Preorder: Root -> Left -> Right (useful for copying tree)"""
    result = []
    
    def traverse(node):
        if not node:
            return
        result.append(node.val)
        traverse(node.left)
        traverse(node.right)
    
    traverse(root)
    return result

def postorder_recursive(root):
    """Postorder: Left -> Right -> Root (useful for deletion)"""
    result = []
    
    def traverse(node):
        if not node:
            return
        traverse(node.left)
        traverse(node.right)
        result.append(node.val)
    
    traverse(root)
    return result

# Test
#       1
#      / \
#     2   3
#    / \
#   4   5

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print("Inorder:   ", inorder_recursive(root))    # [4, 2, 5, 1, 3]
print("Preorder:  ", preorder_recursive(root))   # [1, 2, 4, 5, 3]
print("Postorder: ", postorder_recursive(root))  # [4, 5, 2, 3, 1]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// DFS Traversals - Recursive Implementation
// Time: O(n), Space: O(h) where h is height
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

void inorderHelper(TreeNode* node, std::vector&lt;int&gt;&amp; result) {
    if (!node) return;
    inorderHelper(node-&gt;left, result);
    result.push_back(node-&gt;val);
    inorderHelper(node-&gt;right, result);
}

void preorderHelper(TreeNode* node, std::vector&lt;int&gt;&amp; result) {
    if (!node) return;
    result.push_back(node-&gt;val);
    preorderHelper(node-&gt;left, result);
    preorderHelper(node-&gt;right, result);
}

void postorderHelper(TreeNode* node, std::vector&lt;int&gt;&amp; result) {
    if (!node) return;
    postorderHelper(node-&gt;left, result);
    postorderHelper(node-&gt;right, result);
    result.push_back(node-&gt;val);
}

std::vector&lt;int&gt; inorderRecursive(TreeNode* root) {
    std::vector&lt;int&gt; result;
    inorderHelper(root, result);
    return result;
}

std::vector&lt;int&gt; preorderRecursive(TreeNode* root) {
    std::vector&lt;int&gt; result;
    preorderHelper(root, result);
    return result;
}

std::vector&lt;int&gt; postorderRecursive(TreeNode* root) {
    std::vector&lt;int&gt; result;
    postorderHelper(root, result);
    return result;
}

int main() {
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;left-&gt;left = new TreeNode(4);
    root-&gt;left-&gt;right = new TreeNode(5);
    
    auto printVec = [](const std::vector&lt;int&gt;&amp; v) {
        for (int x : v) std::cout &lt;&lt; x &lt;&lt; " ";
        std::cout &lt;&lt; std::endl;
    };
    
    std::cout &lt;&lt; "Inorder:   "; printVec(inorderRecursive(root));    // 4 2 5 1 3
    std::cout &lt;&lt; "Preorder:  "; printVec(preorderRecursive(root));   // 1 2 4 5 3
    std::cout &lt;&lt; "Postorder: "; printVec(postorderRecursive(root));  // 4 5 2 3 1
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// DFS Traversals - Recursive Implementation
// Time: O(n), Space: O(h) where h is height
import java.util.*;

public class TreeTraversals {
    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) { this.val = val; }
    }
    
    public static List&lt;Integer&gt; inorderRecursive(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        inorderHelper(root, result);
        return result;
    }
    
    private static void inorderHelper(TreeNode node, List&lt;Integer&gt; result) {
        if (node == null) return;
        inorderHelper(node.left, result);
        result.add(node.val);
        inorderHelper(node.right, result);
    }
    
    public static List&lt;Integer&gt; preorderRecursive(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        preorderHelper(root, result);
        return result;
    }
    
    private static void preorderHelper(TreeNode node, List&lt;Integer&gt; result) {
        if (node == null) return;
        result.add(node.val);
        preorderHelper(node.left, result);
        preorderHelper(node.right, result);
    }
    
    public static List&lt;Integer&gt; postorderRecursive(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        postorderHelper(root, result);
        return result;
    }
    
    private static void postorderHelper(TreeNode node, List&lt;Integer&gt; result) {
        if (node == null) return;
        postorderHelper(node.left, result);
        postorderHelper(node.right, result);
        result.add(node.val);
    }
    
    public static void main(String[] args) {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        
        System.out.println("Inorder:   " + inorderRecursive(root));    // [4, 2, 5, 1, 3]
        System.out.println("Preorder:  " + preorderRecursive(root));   // [1, 2, 4, 5, 3]
        System.out.println("Postorder: " + postorderRecursive(root));  // [4, 5, 2, 3, 1]
    }
}
</code></pre>

<pre><code class="language-python"># DFS Traversals - Iterative Implementation using Stack
# Eliminates recursion stack, explicit control

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder_iterative(root):
    """Inorder using stack - O(n) time, O(h) space"""
    result = []
    stack = []
    current = root
    
    while current or stack:
        # Go to leftmost node
        while current:
            stack.append(current)
            current = current.left
        
        # Process current node
        current = stack.pop()
        result.append(current.val)
        
        # Move to right subtree
        current = current.right
    
    return result

def preorder_iterative(root):
    """Preorder using stack - O(n) time, O(h) space"""
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        # Push right first so left is processed first
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result

def postorder_iterative(root):
    """Postorder using two stacks - O(n) time, O(n) space"""
    if not root:
        return []
    
    result = []
    stack1 = [root]
    stack2 = []
    
    while stack1:
        node = stack1.pop()
        stack2.append(node)
        
        if node.left:
            stack1.append(node.left)
        if node.right:
            stack1.append(node.right)
    
    while stack2:
        result.append(stack2.pop().val)
    
    return result

# Test
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print("Iterative Inorder:   ", inorder_iterative(root))    # [4, 2, 5, 1, 3]
print("Iterative Preorder:  ", preorder_iterative(root))   # [1, 2, 4, 5, 3]
print("Iterative Postorder: ", postorder_iterative(root))  # [4, 5, 2, 3, 1]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// DFS Traversals - Iterative Implementation using Stack
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

std::vector&lt;int&gt; inorderIterative(TreeNode* root) {
    std::vector&lt;int&gt; result;
    std::stack&lt;TreeNode*&gt; stk;
    TreeNode* current = root;
    
    while (current || !stk.empty()) {
        while (current) {
            stk.push(current);
            current = current-&gt;left;
        }
        current = stk.top(); stk.pop();
        result.push_back(current-&gt;val);
        current = current-&gt;right;
    }
    return result;
}

std::vector&lt;int&gt; preorderIterative(TreeNode* root) {
    if (!root) return {};
    std::vector&lt;int&gt; result;
    std::stack&lt;TreeNode*&gt; stk;
    stk.push(root);
    
    while (!stk.empty()) {
        TreeNode* node = stk.top(); stk.pop();
        result.push_back(node-&gt;val);
        if (node-&gt;right) stk.push(node-&gt;right);
        if (node-&gt;left) stk.push(node-&gt;left);
    }
    return result;
}

std::vector&lt;int&gt; postorderIterative(TreeNode* root) {
    if (!root) return {};
    std::vector&lt;int&gt; result;
    std::stack&lt;TreeNode*&gt; stk1, stk2;
    stk1.push(root);
    
    while (!stk1.empty()) {
        TreeNode* node = stk1.top(); stk1.pop();
        stk2.push(node);
        if (node-&gt;left) stk1.push(node-&gt;left);
        if (node-&gt;right) stk1.push(node-&gt;right);
    }
    
    while (!stk2.empty()) {
        result.push_back(stk2.top()-&gt;val);
        stk2.pop();
    }
    return result;
}

int main() {
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;left-&gt;left = new TreeNode(4);
    root-&gt;left-&gt;right = new TreeNode(5);
    
    auto printVec = [](const std::vector&lt;int&gt;&amp; v) {
        for (int x : v) std::cout &lt;&lt; x &lt;&lt; " ";
        std::cout &lt;&lt; std::endl;
    };
    
    std::cout &lt;&lt; "Iterative Inorder:   "; printVec(inorderIterative(root));
    std::cout &lt;&lt; "Iterative Preorder:  "; printVec(preorderIterative(root));
    std::cout &lt;&lt; "Iterative Postorder: "; printVec(postorderIterative(root));
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// DFS Traversals - Iterative Implementation using Stack
import java.util.*;

public class IterativeTraversals {
    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) { this.val = val; }
    }
    
    public static List&lt;Integer&gt; inorderIterative(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();
        TreeNode current = root;
        
        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.left;
            }
            current = stack.pop();
            result.add(current.val);
            current = current.right;
        }
        return result;
    }
    
    public static List&lt;Integer&gt; preorderIterative(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if (root == null) return result;
        
        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();
        stack.push(root);
        
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.right != null) stack.push(node.right);
            if (node.left != null) stack.push(node.left);
        }
        return result;
    }
    
    public static List&lt;Integer&gt; postorderIterative(TreeNode root) {
        LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;();
        if (root == null) return result;
        
        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();
        stack.push(root);
        
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            result.addFirst(node.val);  // Add to front
            if (node.left != null) stack.push(node.left);
            if (node.right != null) stack.push(node.right);
        }
        return result;
    }
    
    public static void main(String[] args) {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        
        System.out.println("Iterative Inorder:   " + inorderIterative(root));
        System.out.println("Iterative Preorder:  " + preorderIterative(root));
        System.out.println("Iterative Postorder: " + postorderIterative(root));
    }
}
</code></pre>

                        <h3 id="bfs">BFS Traversal (Level Order)</h3>

<pre><code class="language-python"># Level Order Traversal (BFS) using Queue
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def level_order(root):
    """Standard level order - returns flat list"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        result.append(node.val)
        
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    
    return result

def level_order_by_level(root):
    """Level order - returns list of lists (each level separate)"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level)
    
    return result

# Test
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.right = TreeNode(6)

print("Level Order (flat):", level_order(root))  # [1, 2, 3, 4, 5, 6]
print("Level Order (by level):", level_order_by_level(root))  # [[1], [2, 3], [4, 5, 6]]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Level Order Traversal (BFS) using Queue
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

std::vector&lt;int&gt; levelOrder(TreeNode* root) {
    std::vector&lt;int&gt; result;
    if (!root) return result;
    
    std::queue&lt;TreeNode*&gt; q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        result.push_back(node-&gt;val);
        
        if (node-&gt;left) q.push(node-&gt;left);
        if (node-&gt;right) q.push(node-&gt;right);
    }
    return result;
}

std::vector&lt;std::vector&lt;int&gt;&gt; levelOrderByLevel(TreeNode* root) {
    std::vector&lt;std::vector&lt;int&gt;&gt; result;
    if (!root) return result;
    
    std::queue&lt;TreeNode*&gt; q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        std::vector&lt;int&gt; level;
        
        for (int i = 0; i &lt; levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            level.push_back(node-&gt;val);
            
            if (node-&gt;left) q.push(node-&gt;left);
            if (node-&gt;right) q.push(node-&gt;right);
        }
        result.push_back(level);
    }
    return result;
}

int main() {
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;left-&gt;left = new TreeNode(4);
    root-&gt;left-&gt;right = new TreeNode(5);
    root-&gt;right-&gt;right = new TreeNode(6);
    
    std::cout &lt;&lt; "Level Order (flat): ";
    for (int x : levelOrder(root)) std::cout &lt;&lt; x &lt;&lt; " ";
    std::cout &lt;&lt; std::endl;  // 1 2 3 4 5 6
    
    std::cout &lt;&lt; "Level Order (by level): ";
    for (const auto&amp; level : levelOrderByLevel(root)) {
        std::cout &lt;&lt; "[";
        for (int i = 0; i &lt; level.size(); i++) {
            std::cout &lt;&lt; level[i] &lt;&lt; (i &lt; level.size()-1 ? ", " : "");
        }
        std::cout &lt;&lt; "] ";
    }
    std::cout &lt;&lt; std::endl;  // [1] [2, 3] [4, 5, 6]
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Level Order Traversal (BFS) using Queue
import java.util.*;

public class LevelOrderTraversal {
    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) { this.val = val; }
    }
    
    public static List&lt;Integer&gt; levelOrder(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if (root == null) return result;
        
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            result.add(node.val);
            
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        return result;
    }
    
    public static List&lt;List&lt;Integer&gt;&gt; levelOrderByLevel(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null) return result;
        
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();
            
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            result.add(level);
        }
        return result;
    }
    
    public static void main(String[] args) {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.right = new TreeNode(6);
        
        System.out.println("Level Order (flat): " + levelOrder(root));
        System.out.println("Level Order (by level): " + levelOrderByLevel(root));
    }
}
</code></pre>

<pre><code class="language-python"># Special Traversals

from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def zigzag_level_order(root):
    """Zigzag level order (alternating left-right, right-left)"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    left_to_right = True
    
    while queue:
        level_size = len(queue)
        level = deque()
        
        for _ in range(level_size):
            node = queue.popleft()
            
            if left_to_right:
                level.append(node.val)
            else:
                level.appendleft(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(list(level))
        left_to_right = not left_to_right
    
    return result

def vertical_order(root):
    """Vertical order traversal"""
    if not root:
        return []
    
    from collections import defaultdict
    
    column_map = defaultdict(list)
    queue = deque([(root, 0)])  # (node, column)
    
    while queue:
        node, col = queue.popleft()
        column_map[col].append(node.val)
        
        if node.left:
            queue.append((node.left, col - 1))
        if node.right:
            queue.append((node.right, col + 1))
    
    return [column_map[col] for col in sorted(column_map.keys())]

# Test
root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)

print("Zigzag:", zigzag_level_order(root))  # [[3], [20, 9], [15, 7]]
print("Vertical:", vertical_order(root))    # [[9], [3, 15], [20], [7]]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Special Traversals - Zigzag and Vertical Order
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;deque&gt;
#include &lt;map&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

std::vector&lt;std::vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
    std::vector&lt;std::vector&lt;int&gt;&gt; result;
    if (!root) return result;
    
    std::queue&lt;TreeNode*&gt; q;
    q.push(root);
    bool leftToRight = true;
    
    while (!q.empty()) {
        int levelSize = q.size();
        std::deque&lt;int&gt; level;
        
        for (int i = 0; i &lt; levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            if (leftToRight) level.push_back(node-&gt;val);
            else level.push_front(node-&gt;val);
            
            if (node-&gt;left) q.push(node-&gt;left);
            if (node-&gt;right) q.push(node-&gt;right);
        }
        result.push_back(std::vector&lt;int&gt;(level.begin(), level.end()));
        leftToRight = !leftToRight;
    }
    return result;
}

std::vector&lt;std::vector&lt;int&gt;&gt; verticalOrder(TreeNode* root) {
    std::vector&lt;std::vector&lt;int&gt;&gt; result;
    if (!root) return result;
    
    std::map&lt;int, std::vector&lt;int&gt;&gt; columnMap;
    std::queue&lt;std::pair&lt;TreeNode*, int&gt;&gt; q;
    q.push({root, 0});
    
    while (!q.empty()) {
        auto [node, col] = q.front();
        q.pop();
        columnMap[col].push_back(node-&gt;val);
        
        if (node-&gt;left) q.push({node-&gt;left, col - 1});
        if (node-&gt;right) q.push({node-&gt;right, col + 1});
    }
    
    for (auto&amp; [col, vals] : columnMap) {
        result.push_back(vals);
    }
    return result;
}

int main() {
    TreeNode* root = new TreeNode(3);
    root-&gt;left = new TreeNode(9);
    root-&gt;right = new TreeNode(20);
    root-&gt;right-&gt;left = new TreeNode(15);
    root-&gt;right-&gt;right = new TreeNode(7);
    
    std::cout &lt;&lt; "Zigzag: ";
    for (const auto&amp; level : zigzagLevelOrder(root)) {
        std::cout &lt;&lt; "[";
        for (int i = 0; i &lt; level.size(); i++) {
            std::cout &lt;&lt; level[i] &lt;&lt; (i &lt; level.size()-1 ? ", " : "");
        }
        std::cout &lt;&lt; "] ";
    }
    std::cout &lt;&lt; std::endl;  // [3] [20, 9] [15, 7]
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Special Traversals - Zigzag and Vertical Order
import java.util.*;

public class SpecialTraversals {
    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) { this.val = val; }
    }
    
    public static List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null) return result;
        
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        boolean leftToRight = true;
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            LinkedList&lt;Integer&gt; level = new LinkedList&lt;&gt;();
            
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode node = queue.poll();
                
                if (leftToRight) level.addLast(node.val);
                else level.addFirst(node.val);
                
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            result.add(level);
            leftToRight = !leftToRight;
        }
        return result;
    }
    
    public static List&lt;List&lt;Integer&gt;&gt; verticalOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null) return result;
        
        TreeMap&lt;Integer, List&lt;Integer&gt;&gt; columnMap = new TreeMap&lt;&gt;();
        Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;();
        Queue&lt;Integer&gt; colQueue = new LinkedList&lt;&gt;();
        
        nodeQueue.offer(root);
        colQueue.offer(0);
        
        while (!nodeQueue.isEmpty()) {
            TreeNode node = nodeQueue.poll();
            int col = colQueue.poll();
            
            columnMap.computeIfAbsent(col, k -&gt; new ArrayList&lt;&gt;()).add(node.val);
            
            if (node.left != null) {
                nodeQueue.offer(node.left);
                colQueue.offer(col - 1);
            }
            if (node.right != null) {
                nodeQueue.offer(node.right);
                colQueue.offer(col + 1);
            }
        }
        
        result.addAll(columnMap.values());
        return result;
    }
    
    public static void main(String[] args) {
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(9);
        root.right = new TreeNode(20);
        root.right.left = new TreeNode(15);
        root.right.right = new TreeNode(7);
        
        System.out.println("Zigzag: " + zigzagLevelOrder(root));  // [[3], [20, 9], [15, 7]]
        System.out.println("Vertical: " + verticalOrder(root));   // [[9], [3, 15], [20], [7]]
    }
}
</code></pre>

                        <!-- Properties -->
                        <h2 id="properties"><i class="fas fa-ruler me-2" style="color: var(--color-teal);"></i>Tree Properties</h2>

<pre><code class="language-python"># Tree Properties and Calculations

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def tree_height(root):
    """Calculate height of tree (edges from root to deepest leaf)"""
    if not root:
        return -1  # Empty tree has height -1
    
    return 1 + max(tree_height(root.left), tree_height(root.right))

def tree_depth(root, target, depth=0):
    """Find depth of a specific node"""
    if not root:
        return -1
    
    if root.val == target:
        return depth
    
    left_depth = tree_depth(root.left, target, depth + 1)
    if left_depth != -1:
        return left_depth
    
    return tree_depth(root.right, target, depth + 1)

def count_nodes(root):
    """Count total nodes in tree"""
    if not root:
        return 0
    return 1 + count_nodes(root.left) + count_nodes(root.right)

def count_leaves(root):
    """Count leaf nodes"""
    if not root:
        return 0
    if not root.left and not root.right:
        return 1
    return count_leaves(root.left) + count_leaves(root.right)

def is_balanced(root):
    """Check if tree is height-balanced"""
    def check(node):
        if not node:
            return 0
        
        left_height = check(node.left)
        if left_height == -1:
            return -1
        
        right_height = check(node.right)
        if right_height == -1:
            return -1
        
        if abs(left_height - right_height) > 1:
            return -1
        
        return 1 + max(left_height, right_height)
    
    return check(root) != -1

# Test
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print(f"Height: {tree_height(root)}")     # 2
print(f"Depth of 5: {tree_depth(root, 5)}")  # 2
print(f"Total nodes: {count_nodes(root)}")  # 5
print(f"Leaf nodes: {count_leaves(root)}")  # 3
print(f"Is balanced: {is_balanced(root)}")  # True
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Tree Properties and Calculations
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

int treeHeight(TreeNode* root) {
    if (!root) return -1;
    return 1 + std::max(treeHeight(root-&gt;left), treeHeight(root-&gt;right));
}

int treeDepth(TreeNode* root, int target, int depth = 0) {
    if (!root) return -1;
    if (root-&gt;val == target) return depth;
    
    int leftDepth = treeDepth(root-&gt;left, target, depth + 1);
    if (leftDepth != -1) return leftDepth;
    return treeDepth(root-&gt;right, target, depth + 1);
}

int countNodes(TreeNode* root) {
    if (!root) return 0;
    return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right);
}

int countLeaves(TreeNode* root) {
    if (!root) return 0;
    if (!root-&gt;left &amp;&amp; !root-&gt;right) return 1;
    return countLeaves(root-&gt;left) + countLeaves(root-&gt;right);
}

int checkBalanced(TreeNode* node) {
    if (!node) return 0;
    int leftH = checkBalanced(node-&gt;left);
    if (leftH == -1) return -1;
    int rightH = checkBalanced(node-&gt;right);
    if (rightH == -1) return -1;
    if (std::abs(leftH - rightH) &gt; 1) return -1;
    return 1 + std::max(leftH, rightH);
}

bool isBalanced(TreeNode* root) {
    return checkBalanced(root) != -1;
}

int main() {
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;left-&gt;left = new TreeNode(4);
    root-&gt;left-&gt;right = new TreeNode(5);
    
    std::cout &lt;&lt; "Height: " &lt;&lt; treeHeight(root) &lt;&lt; std::endl;        // 2
    std::cout &lt;&lt; "Depth of 5: " &lt;&lt; treeDepth(root, 5) &lt;&lt; std::endl;  // 2
    std::cout &lt;&lt; "Total nodes: " &lt;&lt; countNodes(root) &lt;&lt; std::endl;   // 5
    std::cout &lt;&lt; "Leaf nodes: " &lt;&lt; countLeaves(root) &lt;&lt; std::endl;   // 3
    std::cout &lt;&lt; "Is balanced: " &lt;&lt; (isBalanced(root) ? "True" : "False") &lt;&lt; std::endl;  // True
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Tree Properties and Calculations
public class TreeProperties {
    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) { this.val = val; }
    }
    
    public static int treeHeight(TreeNode root) {
        if (root == null) return -1;
        return 1 + Math.max(treeHeight(root.left), treeHeight(root.right));
    }
    
    public static int treeDepth(TreeNode root, int target, int depth) {
        if (root == null) return -1;
        if (root.val == target) return depth;
        
        int leftDepth = treeDepth(root.left, target, depth + 1);
        if (leftDepth != -1) return leftDepth;
        return treeDepth(root.right, target, depth + 1);
    }
    
    public static int countNodes(TreeNode root) {
        if (root == null) return 0;
        return 1 + countNodes(root.left) + countNodes(root.right);
    }
    
    public static int countLeaves(TreeNode root) {
        if (root == null) return 0;
        if (root.left == null &amp;&amp; root.right == null) return 1;
        return countLeaves(root.left) + countLeaves(root.right);
    }
    
    private static int checkBalanced(TreeNode node) {
        if (node == null) return 0;
        int leftH = checkBalanced(node.left);
        if (leftH == -1) return -1;
        int rightH = checkBalanced(node.right);
        if (rightH == -1) return -1;
        if (Math.abs(leftH - rightH) &gt; 1) return -1;
        return 1 + Math.max(leftH, rightH);
    }
    
    public static boolean isBalanced(TreeNode root) {
        return checkBalanced(root) != -1;
    }
    
    public static void main(String[] args) {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        
        System.out.println("Height: " + treeHeight(root));        // 2
        System.out.println("Depth of 5: " + treeDepth(root, 5, 0));  // 2
        System.out.println("Total nodes: " + countNodes(root));   // 5
        System.out.println("Leaf nodes: " + countLeaves(root));   // 3
        System.out.println("Is balanced: " + isBalanced(root));   // true
    }
}
</code></pre>

<pre><code class="language-python"># More Tree Properties

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_width(root):
    """Find maximum width (max nodes at any level)"""
    if not root:
        return 0
    
    from collections import deque
    queue = deque([root])
    max_w = 0
    
    while queue:
        level_size = len(queue)
        max_w = max(max_w, level_size)
        
        for _ in range(level_size):
            node = queue.popleft()
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    
    return max_w

def diameter(root):
    """Find diameter (longest path between any two nodes)"""
    max_diameter = [0]
    
    def height(node):
        if not node:
            return 0
        
        left_h = height(node.left)
        right_h = height(node.right)
        
        # Update diameter (path through this node)
        max_diameter[0] = max(max_diameter[0], left_h + right_h)
        
        return 1 + max(left_h, right_h)
    
    height(root)
    return max_diameter[0]

def is_symmetric(root):
    """Check if tree is symmetric (mirror of itself)"""
    def is_mirror(t1, t2):
        if not t1 and not t2:
            return True
        if not t1 or not t2:
            return False
        return (t1.val == t2.val and 
                is_mirror(t1.left, t2.right) and 
                is_mirror(t1.right, t2.left))
    
    return is_mirror(root, root)

# Test
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.left = TreeNode(6)
root.right.right = TreeNode(7)

print(f"Max width: {max_width(root)}")  # 4
print(f"Diameter: {diameter(root)}")     # 4 (path: 4-2-1-3-7 or similar)

# Symmetric tree test
sym_root = TreeNode(1)
sym_root.left = TreeNode(2)
sym_root.right = TreeNode(2)
sym_root.left.left = TreeNode(3)
sym_root.left.right = TreeNode(4)
sym_root.right.left = TreeNode(4)
sym_root.right.right = TreeNode(3)

print(f"Is symmetric: {is_symmetric(sym_root)}")  # True
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// More Tree Properties - Width, Diameter, Symmetric
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

int maxWidth(TreeNode* root) {
    if (!root) return 0;
    std::queue&lt;TreeNode*&gt; q;
    q.push(root);
    int maxW = 0;
    
    while (!q.empty()) {
        int levelSize = q.size();
        maxW = std::max(maxW, levelSize);
        
        for (int i = 0; i &lt; levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            if (node-&gt;left) q.push(node-&gt;left);
            if (node-&gt;right) q.push(node-&gt;right);
        }
    }
    return maxW;
}

int diameterHelper(TreeNode* node, int&amp; maxDiam) {
    if (!node) return 0;
    int leftH = diameterHelper(node-&gt;left, maxDiam);
    int rightH = diameterHelper(node-&gt;right, maxDiam);
    maxDiam = std::max(maxDiam, leftH + rightH);
    return 1 + std::max(leftH, rightH);
}

int diameter(TreeNode* root) {
    int maxDiam = 0;
    diameterHelper(root, maxDiam);
    return maxDiam;
}

bool isMirror(TreeNode* t1, TreeNode* t2) {
    if (!t1 &amp;&amp; !t2) return true;
    if (!t1 || !t2) return false;
    return (t1-&gt;val == t2-&gt;val &amp;&amp;
            isMirror(t1-&gt;left, t2-&gt;right) &amp;&amp;
            isMirror(t1-&gt;right, t2-&gt;left));
}

bool isSymmetric(TreeNode* root) {
    return isMirror(root, root);
}

int main() {
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;left-&gt;left = new TreeNode(4);
    root-&gt;left-&gt;right = new TreeNode(5);
    root-&gt;right-&gt;left = new TreeNode(6);
    root-&gt;right-&gt;right = new TreeNode(7);
    
    std::cout &lt;&lt; "Max width: " &lt;&lt; maxWidth(root) &lt;&lt; std::endl;  // 4
    std::cout &lt;&lt; "Diameter: " &lt;&lt; diameter(root) &lt;&lt; std::endl;   // 4
    
    // Symmetric tree
    TreeNode* symRoot = new TreeNode(1);
    symRoot-&gt;left = new TreeNode(2);
    symRoot-&gt;right = new TreeNode(2);
    symRoot-&gt;left-&gt;left = new TreeNode(3);
    symRoot-&gt;left-&gt;right = new TreeNode(4);
    symRoot-&gt;right-&gt;left = new TreeNode(4);
    symRoot-&gt;right-&gt;right = new TreeNode(3);
    
    std::cout &lt;&lt; "Is symmetric: " &lt;&lt; (isSymmetric(symRoot) ? "True" : "False") &lt;&lt; std::endl;  // True
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// More Tree Properties - Width, Diameter, Symmetric
import java.util.*;

public class MoreTreeProperties {
    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) { this.val = val; }
    }
    
    public static int maxWidth(TreeNode root) {
        if (root == null) return 0;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        int maxW = 0;
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            maxW = Math.max(maxW, levelSize);
            
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
        }
        return maxW;
    }
    
    private static int[] maxDiam = {0};
    
    private static int diameterHelper(TreeNode node) {
        if (node == null) return 0;
        int leftH = diameterHelper(node.left);
        int rightH = diameterHelper(node.right);
        maxDiam[0] = Math.max(maxDiam[0], leftH + rightH);
        return 1 + Math.max(leftH, rightH);
    }
    
    public static int diameter(TreeNode root) {
        maxDiam[0] = 0;
        diameterHelper(root);
        return maxDiam[0];
    }
    
    private static boolean isMirror(TreeNode t1, TreeNode t2) {
        if (t1 == null &amp;&amp; t2 == null) return true;
        if (t1 == null || t2 == null) return false;
        return (t1.val == t2.val &amp;&amp;
                isMirror(t1.left, t2.right) &amp;&amp;
                isMirror(t1.right, t2.left));
    }
    
    public static boolean isSymmetric(TreeNode root) {
        return isMirror(root, root);
    }
    
    public static void main(String[] args) {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);
        
        System.out.println("Max width: " + maxWidth(root));  // 4
        System.out.println("Diameter: " + diameter(root));   // 4
        
        // Symmetric tree
        TreeNode symRoot = new TreeNode(1);
        symRoot.left = new TreeNode(2);
        symRoot.right = new TreeNode(2);
        symRoot.left.left = new TreeNode(3);
        symRoot.left.right = new TreeNode(4);
        symRoot.right.left = new TreeNode(4);
        symRoot.right.right = new TreeNode(3);
        
        System.out.println("Is symmetric: " + isSymmetric(symRoot));  // true
    }
}
</code></pre>

                        <!-- Construction -->
                        <h2 id="construction"><i class="fas fa-hammer me-2" style="color: var(--color-teal);"></i>Tree Construction</h2>

<pre><code class="language-python"># Build Tree from Preorder and Inorder Traversals

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def build_tree_pre_in(preorder, inorder):
    """
    Construct binary tree from preorder and inorder traversals.
    Time: O(n), Space: O(n)
    """
    if not preorder or not inorder:
        return None
    
    # Create index map for O(1) lookup in inorder
    inorder_map = {val: idx for idx, val in enumerate(inorder)}
    
    def build(pre_start, pre_end, in_start, in_end):
        if pre_start > pre_end:
            return None
        
        # Root is first element in preorder
        root_val = preorder[pre_start]
        root = TreeNode(root_val)
        
        # Find root position in inorder
        root_idx = inorder_map[root_val]
        left_size = root_idx - in_start
        
        # Recursively build left and right subtrees
        root.left = build(pre_start + 1, pre_start + left_size,
                         in_start, root_idx - 1)
        root.right = build(pre_start + left_size + 1, pre_end,
                          root_idx + 1, in_end)
        
        return root
    
    return build(0, len(preorder) - 1, 0, len(inorder) - 1)

# Test
preorder = [3, 9, 20, 15, 7]
inorder = [9, 3, 15, 20, 7]

root = build_tree_pre_in(preorder, inorder)

# Verify
def inorder_traversal(root):
    if not root:
        return []
    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)

print("Reconstructed inorder:", inorder_traversal(root))  # [9, 3, 15, 20, 7]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Build Tree from Preorder and Inorder Traversals
// Time: O(n), Space: O(n)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
private:
    std::unordered_map&lt;int, int&gt; inorderMap;
    int preIdx = 0;
    
    TreeNode* build(std::vector&lt;int&gt;&amp; preorder, int inStart, int inEnd) {
        if (inStart &gt; inEnd) return nullptr;
        
        int rootVal = preorder[preIdx++];
        TreeNode* root = new TreeNode(rootVal);
        int mid = inorderMap[rootVal];
        
        root-&gt;left = build(preorder, inStart, mid - 1);
        root-&gt;right = build(preorder, mid + 1, inEnd);
        
        return root;
    }
    
public:
    TreeNode* buildTree(std::vector&lt;int&gt;&amp; preorder, std::vector&lt;int&gt;&amp; inorder) {
        for (int i = 0; i &lt; inorder.size(); i++) {
            inorderMap[inorder[i]] = i;
        }
        preIdx = 0;
        return build(preorder, 0, inorder.size() - 1);
    }
};

void inorderTraversal(TreeNode* root, std::vector&lt;int&gt;&amp; result) {
    if (!root) return;
    inorderTraversal(root-&gt;left, result);
    result.push_back(root-&gt;val);
    inorderTraversal(root-&gt;right, result);
}

int main() {
    std::vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};
    std::vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};
    
    Solution sol;
    TreeNode* root = sol.buildTree(preorder, inorder);
    
    std::vector&lt;int&gt; result;
    inorderTraversal(root, result);
    std::cout &lt;&lt; "Reconstructed inorder: ";
    for (int x : result) std::cout &lt;&lt; x &lt;&lt; " ";
    std::cout &lt;&lt; std::endl;  // 9 3 15 20 7
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Build Tree from Preorder and Inorder Traversals
// Time: O(n), Space: O(n)
import java.util.*;

public class BuildTreePreIn {
    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) { this.val = val; }
    }
    
    private Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;();
    private int preIdx = 0;
    
    private TreeNode build(int[] preorder, int inStart, int inEnd) {
        if (inStart &gt; inEnd) return null;
        
        int rootVal = preorder[preIdx++];
        TreeNode root = new TreeNode(rootVal);
        int mid = inorderMap.get(rootVal);
        
        root.left = build(preorder, inStart, mid - 1);
        root.right = build(preorder, mid + 1, inEnd);
        
        return root;
    }
    
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i &lt; inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        preIdx = 0;
        return build(preorder, 0, inorder.length - 1);
    }
    
    private void inorderTraversal(TreeNode root, List&lt;Integer&gt; result) {
        if (root == null) return;
        inorderTraversal(root.left, result);
        result.add(root.val);
        inorderTraversal(root.right, result);
    }
    
    public static void main(String[] args) {
        int[] preorder = {3, 9, 20, 15, 7};
        int[] inorder = {9, 3, 15, 20, 7};
        
        BuildTreePreIn sol = new BuildTreePreIn();
        TreeNode root = sol.buildTree(preorder, inorder);
        
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        sol.inorderTraversal(root, result);
        System.out.println("Reconstructed inorder: " + result);  // [9, 3, 15, 20, 7]
    }
}
</code></pre>

<pre><code class="language-python"># Build Tree from Inorder and Postorder Traversals

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def build_tree_in_post(inorder, postorder):
    """
    Construct binary tree from inorder and postorder traversals.
    Time: O(n), Space: O(n)
    """
    if not inorder or not postorder:
        return None
    
    inorder_map = {val: idx for idx, val in enumerate(inorder)}
    post_idx = [len(postorder) - 1]  # Start from last element
    
    def build(in_start, in_end):
        if in_start > in_end:
            return None
        
        # Root is last element in postorder (process right to left)
        root_val = postorder[post_idx[0]]
        post_idx[0] -= 1
        root = TreeNode(root_val)
        
        root_idx = inorder_map[root_val]
        
        # Build right subtree first (because postorder is L-R-Root)
        root.right = build(root_idx + 1, in_end)
        root.left = build(in_start, root_idx - 1)
        
        return root
    
    return build(0, len(inorder) - 1)

# Test
inorder = [9, 3, 15, 20, 7]
postorder = [9, 15, 7, 20, 3]

root = build_tree_in_post(inorder, postorder)

def preorder_traversal(root):
    if not root:
        return []
    return [root.val] + preorder_traversal(root.left) + preorder_traversal(root.right)

print("Reconstructed preorder:", preorder_traversal(root))  # [3, 9, 20, 15, 7]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Build Tree from Inorder and Postorder Traversals
// Time: O(n), Space: O(n)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
private:
    std::unordered_map&lt;int, int&gt; inorderMap;
    int postIdx;
    
    TreeNode* build(std::vector&lt;int&gt;&amp; postorder, int inStart, int inEnd) {
        if (inStart &gt; inEnd) return nullptr;
        
        int rootVal = postorder[postIdx--];
        TreeNode* root = new TreeNode(rootVal);
        int mid = inorderMap[rootVal];
        
        // Build right subtree first (postorder is L-R-Root)
        root-&gt;right = build(postorder, mid + 1, inEnd);
        root-&gt;left = build(postorder, inStart, mid - 1);
        
        return root;
    }
    
public:
    TreeNode* buildTree(std::vector&lt;int&gt;&amp; inorder, std::vector&lt;int&gt;&amp; postorder) {
        for (int i = 0; i &lt; inorder.size(); i++) {
            inorderMap[inorder[i]] = i;
        }
        postIdx = postorder.size() - 1;
        return build(postorder, 0, inorder.size() - 1);
    }
};

void preorderTraversal(TreeNode* root, std::vector&lt;int&gt;&amp; result) {
    if (!root) return;
    result.push_back(root-&gt;val);
    preorderTraversal(root-&gt;left, result);
    preorderTraversal(root-&gt;right, result);
}

int main() {
    std::vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};
    std::vector&lt;int&gt; postorder = {9, 15, 7, 20, 3};
    
    Solution sol;
    TreeNode* root = sol.buildTree(inorder, postorder);
    
    std::vector&lt;int&gt; result;
    preorderTraversal(root, result);
    std::cout &lt;&lt; "Reconstructed preorder: ";
    for (int x : result) std::cout &lt;&lt; x &lt;&lt; " ";
    std::cout &lt;&lt; std::endl;  // 3 9 20 15 7
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Build Tree from Inorder and Postorder Traversals
// Time: O(n), Space: O(n)
import java.util.*;

public class BuildTreeInPost {
    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) { this.val = val; }
    }
    
    private Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;();
    private int postIdx;
    
    private TreeNode build(int[] postorder, int inStart, int inEnd) {
        if (inStart &gt; inEnd) return null;
        
        int rootVal = postorder[postIdx--];
        TreeNode root = new TreeNode(rootVal);
        int mid = inorderMap.get(rootVal);
        
        // Build right subtree first (postorder is L-R-Root)
        root.right = build(postorder, mid + 1, inEnd);
        root.left = build(postorder, inStart, mid - 1);
        
        return root;
    }
    
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        for (int i = 0; i &lt; inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        postIdx = postorder.length - 1;
        return build(postorder, 0, inorder.length - 1);
    }
    
    private void preorderTraversal(TreeNode root, List&lt;Integer&gt; result) {
        if (root == null) return;
        result.add(root.val);
        preorderTraversal(root.left, result);
        preorderTraversal(root.right, result);
    }
    
    public static void main(String[] args) {
        int[] inorder = {9, 3, 15, 20, 7};
        int[] postorder = {9, 15, 7, 20, 3};
        
        BuildTreeInPost sol = new BuildTreeInPost();
        TreeNode root = sol.buildTree(inorder, postorder);
        
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        sol.preorderTraversal(root, result);
        System.out.println("Reconstructed preorder: " + result);  // [3, 9, 20, 15, 7]
    }
}
</code></pre>

                        <!-- LeetCode -->
                        <h2 id="leetcode"><i class="fas fa-laptop-code me-2" style="color: var(--color-teal);"></i>LeetCode Practice Problems</h2>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 104. Maximum Depth of Binary Tree</h4>
                            <p>Find the maximum depth (height) of a binary tree.</p>
<pre><code class="language-python"># LeetCode 104 - Maximum Depth of Binary Tree
# Time: O(n), Space: O(h)

def maxDepth(root):
    if not root:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))

# Iterative BFS solution
from collections import deque

def maxDepth_bfs(root):
    if not root:
        return 0
    
    depth = 0
    queue = deque([root])
    
    while queue:
        depth += 1
        for _ in range(len(queue)):
            node = queue.popleft()
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    
    return depth
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 104 - Maximum Depth of Binary Tree
// Time: O(n), Space: O(h)
#include &lt;algorithm&gt;
#include &lt;queue&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    // Recursive
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return 1 + std::max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));
    }
    
    // Iterative BFS
    int maxDepthBFS(TreeNode* root) {
        if (!root) return 0;
        int depth = 0;
        std::queue&lt;TreeNode*&gt; q;
        q.push(root);
        
        while (!q.empty()) {
            depth++;
            int levelSize = q.size();
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode* node = q.front();
                q.pop();
                if (node-&gt;left) q.push(node-&gt;left);
                if (node-&gt;right) q.push(node-&gt;right);
            }
        }
        return depth;
    }
};
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 104 - Maximum Depth of Binary Tree
// Time: O(n), Space: O(h)
import java.util.*;

class Solution {
    // Recursive
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
    
    // Iterative BFS
    public int maxDepthBFS(TreeNode root) {
        if (root == null) return 0;
        int depth = 0;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            depth++;
            int levelSize = queue.size();
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
        }
        return depth;
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 226. Invert Binary Tree</h4>
                            <p>Invert (mirror) a binary tree.</p>
<pre><code class="language-python"># LeetCode 226 - Invert Binary Tree
# Time: O(n), Space: O(h)

def invertTree(root):
    if not root:
        return None
    
    # Swap children
    root.left, root.right = root.right, root.left
    
    # Recursively invert subtrees
    invertTree(root.left)
    invertTree(root.right)
    
    return root
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 226 - Invert Binary Tree
// Time: O(n), Space: O(h)
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) return nullptr;
        
        // Swap children
        std::swap(root-&gt;left, root-&gt;right);
        
        // Recursively invert subtrees
        invertTree(root-&gt;left);
        invertTree(root-&gt;right);
        
        return root;
    }
};
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 226 - Invert Binary Tree
// Time: O(n), Space: O(h)

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;
        
        // Swap children
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        
        // Recursively invert subtrees
        invertTree(root.left);
        invertTree(root.right);
        
        return root;
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 100. Same Tree</h4>
                            <p>Check if two binary trees are identical.</p>
<pre><code class="language-python"># LeetCode 100 - Same Tree
# Time: O(n), Space: O(h)

def isSameTree(p, q):
    # Both empty
    if not p and not q:
        return True
    
    # One empty, one not
    if not p or not q:
        return False
    
    # Both non-empty - check value and children
    return (p.val == q.val and 
            isSameTree(p.left, q.left) and 
            isSameTree(p.right, q.right))
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 100 - Same Tree
// Time: O(n), Space: O(h)
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p &amp;&amp; !q) return true;
        if (!p || !q) return false;
        return (p-&gt;val == q-&gt;val &amp;&amp;
                isSameTree(p-&gt;left, q-&gt;left) &amp;&amp;
                isSameTree(p-&gt;right, q-&gt;right));
    }
};
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 100 - Same Tree
// Time: O(n), Space: O(h)

class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null &amp;&amp; q == null) return true;
        if (p == null || q == null) return false;
        return (p.val == q.val &amp;&amp;
                isSameTree(p.left, q.left) &amp;&amp;
                isSameTree(p.right, q.right));
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 236. Lowest Common Ancestor</h4>
                            <p>Find the lowest common ancestor (LCA) of two nodes.</p>
<pre><code class="language-python"># LeetCode 236 - Lowest Common Ancestor of a Binary Tree
# Time: O(n), Space: O(h)

def lowestCommonAncestor(root, p, q):
    if not root or root == p or root == q:
        return root
    
    left = lowestCommonAncestor(root.left, p, q)
    right = lowestCommonAncestor(root.right, p, q)
    
    # If both sides return non-null, root is LCA
    if left and right:
        return root
    
    # Otherwise, return the non-null side
    return left if left else right
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 236 - Lowest Common Ancestor of a Binary Tree
// Time: O(n), Space: O(h)
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q) return root;
        
        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
        
        if (left &amp;&amp; right) return root;
        return left ? left : right;
    }
};
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 236 - Lowest Common Ancestor of a Binary Tree
// Time: O(n), Space: O(h)

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) return root;
        
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        
        if (left != null &amp;&amp; right != null) return root;
        return left != null ? left : right;
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 105. Construct Binary Tree from Preorder and Inorder</h4>
                            <p>Build tree from preorder and inorder traversals.</p>
<pre><code class="language-python"># LeetCode 105 - Construct Binary Tree from Preorder and Inorder
# Time: O(n), Space: O(n)

def buildTree(preorder, inorder):
    if not preorder:
        return None
    
    inorder_map = {val: idx for idx, val in enumerate(inorder)}
    pre_idx = [0]
    
    def build(in_start, in_end):
        if in_start > in_end:
            return None
        
        root_val = preorder[pre_idx[0]]
        pre_idx[0] += 1
        root = TreeNode(root_val)
        
        mid = inorder_map[root_val]
        root.left = build(in_start, mid - 1)
        root.right = build(mid + 1, in_end)
        
        return root
    
    return build(0, len(inorder) - 1)
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 105 - Construct Binary Tree from Preorder and Inorder
// Time: O(n), Space: O(n)
#include &lt;vector&gt;
#include &lt;unordered_map&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
private:
    std::unordered_map&lt;int, int&gt; inorderMap;
    int preIdx = 0;
    
    TreeNode* build(std::vector&lt;int&gt;&amp; preorder, int inStart, int inEnd) {
        if (inStart &gt; inEnd) return nullptr;
        
        int rootVal = preorder[preIdx++];
        TreeNode* root = new TreeNode(rootVal);
        int mid = inorderMap[rootVal];
        
        root-&gt;left = build(preorder, inStart, mid - 1);
        root-&gt;right = build(preorder, mid + 1, inEnd);
        
        return root;
    }
    
public:
    TreeNode* buildTree(std::vector&lt;int&gt;&amp; preorder, std::vector&lt;int&gt;&amp; inorder) {
        for (int i = 0; i &lt; inorder.size(); i++) {
            inorderMap[inorder[i]] = i;
        }
        preIdx = 0;
        return build(preorder, 0, inorder.size() - 1);
    }
};
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 105 - Construct Binary Tree from Preorder and Inorder
// Time: O(n), Space: O(n)
import java.util.*;

class Solution {
    private Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;();
    private int preIdx = 0;
    
    private TreeNode build(int[] preorder, int inStart, int inEnd) {
        if (inStart &gt; inEnd) return null;
        
        int rootVal = preorder[preIdx++];
        TreeNode root = new TreeNode(rootVal);
        int mid = inorderMap.get(rootVal);
        
        root.left = build(preorder, inStart, mid - 1);
        root.right = build(preorder, mid + 1, inEnd);
        
        return root;
    }
    
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i &lt; inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        preIdx = 0;
        return build(preorder, 0, inorder.length - 1);
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 114. Flatten Binary Tree to Linked List</h4>
                            <p>Flatten tree to linked list in-place (preorder).</p>
<pre><code class="language-python"># LeetCode 114 - Flatten Binary Tree to Linked List
# Time: O(n), Space: O(1) - Morris-like approach

def flatten(root):
    current = root
    
    while current:
        if current.left:
            # Find rightmost node in left subtree
            rightmost = current.left
            while rightmost.right:
                rightmost = rightmost.right
            
            # Connect rightmost to current's right
            rightmost.right = current.right
            
            # Move left subtree to right
            current.right = current.left
            current.left = None
        
        current = current.right
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 114 - Flatten Binary Tree to Linked List
// Time: O(n), Space: O(1) - Morris-like approach
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* current = root;
        
        while (current) {
            if (current-&gt;left) {
                // Find rightmost node in left subtree
                TreeNode* rightmost = current-&gt;left;
                while (rightmost-&gt;right) {
                    rightmost = rightmost-&gt;right;
                }
                
                // Connect rightmost to current's right
                rightmost-&gt;right = current-&gt;right;
                
                // Move left subtree to right
                current-&gt;right = current-&gt;left;
                current-&gt;left = nullptr;
            }
            current = current-&gt;right;
        }
    }
};
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 114 - Flatten Binary Tree to Linked List
// Time: O(n), Space: O(1) - Morris-like approach

class Solution {
    public void flatten(TreeNode root) {
        TreeNode current = root;
        
        while (current != null) {
            if (current.left != null) {
                // Find rightmost node in left subtree
                TreeNode rightmost = current.left;
                while (rightmost.right != null) {
                    rightmost = rightmost.right;
                }
                
                // Connect rightmost to current's right
                rightmost.right = current.right;
                
                // Move left subtree to right
                current.right = current.left;
                current.left = null;
            }
            current = current.right;
        }
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-hard">Hard</span> 124. Binary Tree Maximum Path Sum</h4>
                            <p>Find the maximum path sum (path can start and end anywhere).</p>
<pre><code class="language-python"># LeetCode 124 - Binary Tree Maximum Path Sum
# Time: O(n), Space: O(h)

def maxPathSum(root):
    max_sum = [float('-inf')]
    
    def max_gain(node):
        if not node:
            return 0
        
        # Get max gain from left and right (ignore negative)
        left_gain = max(max_gain(node.left), 0)
        right_gain = max(max_gain(node.right), 0)
        
        # Path through this node
        path_sum = node.val + left_gain + right_gain
        max_sum[0] = max(max_sum[0], path_sum)
        
        # Return max gain including this node (can only go one way)
        return node.val + max(left_gain, right_gain)
    
    max_gain(root)
    return max_sum[0]
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 124 - Binary Tree Maximum Path Sum
// Time: O(n), Space: O(h)
#include &lt;algorithm&gt;
#include &lt;climits&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
private:
    int maxSum = INT_MIN;
    
    int maxGain(TreeNode* node) {
        if (!node) return 0;
        
        // Get max gain from left and right (ignore negative)
        int leftGain = std::max(maxGain(node-&gt;left), 0);
        int rightGain = std::max(maxGain(node-&gt;right), 0);
        
        // Path through this node
        int pathSum = node-&gt;val + leftGain + rightGain;
        maxSum = std::max(maxSum, pathSum);
        
        // Return max gain including this node (can only go one way)
        return node-&gt;val + std::max(leftGain, rightGain);
    }
    
public:
    int maxPathSum(TreeNode* root) {
        maxSum = INT_MIN;
        maxGain(root);
        return maxSum;
    }
};
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 124 - Binary Tree Maximum Path Sum
// Time: O(n), Space: O(h)

class Solution {
    private int maxSum = Integer.MIN_VALUE;
    
    private int maxGain(TreeNode node) {
        if (node == null) return 0;
        
        // Get max gain from left and right (ignore negative)
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);
        
        // Path through this node
        int pathSum = node.val + leftGain + rightGain;
        maxSum = Math.max(maxSum, pathSum);
        
        // Return max gain including this node (can only go one way)
        return node.val + Math.max(leftGain, rightGain);
    }
    
    public int maxPathSum(TreeNode root) {
        maxSum = Integer.MIN_VALUE;
        maxGain(root);
        return maxSum;
    }
}
</code></pre>
                        </div>

                        <!-- Related Posts -->
                        <div class="related-posts">
                            <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 8: Queue</h5>
                                <p class="text-muted small mb-2">Queue implementations, circular queue, deque, priority queue.</p>
                                <a href="dsa-queue-implementations.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 10: BST & Balanced Trees</h5>
                                <p class="text-muted small mb-2">Binary search trees, AVL trees, Red-Black trees, and self-balancing.</p>
                                <a href="dsa-bst-avl-redblack.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 11: Heaps, Sorting & Hashing</h5>
                                <p class="text-muted small mb-2">Heap data structure, sorting algorithms, hash tables.</p>
                                <a href="dsa-heaps-sorting-hashing.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest"><i class="fab fa-pinterest-p"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Scroll-to-Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    <!-- Category Indicator -->
    <div id="categoryIndicator" class="category-indicator" title="Current Section">
        <i class="fas fa-tag"></i><span id="categoryText">Technology</span>
    </div>
    
    <!-- Cookie Consent JS -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>

    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    <!-- Side Navigation Script -->
    <script>
        function openNav() {
            document.getElementById('tocSidenav').classList.add('open');
            document.getElementById('tocOverlay').classList.add('show');
            document.body.style.overflow = 'hidden';
        }
        function closeNav() {
            document.getElementById('tocSidenav').classList.remove('open');
            document.getElementById('tocOverlay').classList.remove('show');
            document.body.style.overflow = 'auto';
        }
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeNav();
        });
        document.addEventListener('DOMContentLoaded', function() {
            const sections = document.querySelectorAll('[id]');
            const tocLinks = document.querySelectorAll('.sidenav-toc a');
            function highlightActiveSection() {
                let currentSection = '';
                sections.forEach(section => {
                    const sectionTop = section.offsetTop;
                    if (window.scrollY >= sectionTop - 200) {
                        currentSection = section.getAttribute('id');
                    }
                });
                tocLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === '#' + currentSection) {
                        link.classList.add('active');
                    }
                });
            }
            window.addEventListener('scroll', highlightActiveSection);
            highlightActiveSection();
            tocLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetSection = document.querySelector(targetId);
                    if (targetSection) {
                        const offsetTop = targetSection.offsetTop - 80;
                        window.scrollTo({ top: offsetTop, behavior: 'smooth' });
                    }
                    setTimeout(closeNav, 300);
                });
            });
        });
    </script>

    </body>
</html>
