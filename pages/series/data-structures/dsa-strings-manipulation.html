<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master strings for FAANG interviews: string representation, pattern matching (KMP, Rabin-Karp), palindrome algorithms, anagram detection with complete Python implementations.">
    <meta name="keywords" content="strings, data structures, pattern matching, KMP algorithm, Rabin-Karp, palindrome, anagram, FAANG interview, Python, DSA">
    <meta name="author" content="Wasil Zafar">

    <!-- Open Graph -->
    <meta property="og:title" content="DSA Part 4: Strings | Complete Guide">
    <meta property="og:description" content="Master strings for FAANG interviews: pattern matching, KMP, Rabin-Karp, palindromes, anagrams with Python.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://wasilzafar.com/pag../series/data-structures/dsa-strings-manipulation.html">
    <meta property="article:published_time" content="2026-01-21">
    <meta property="article:author" content="Wasil Zafar">
    <meta property="article:section" content="Technology">

    <title>DSA Part 4: Strings | Complete Guide | Wasil Zafar</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/images/favicon_io/favicon.ico">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />

    <!-- Prism.js Themes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <!-- Main CSS -->
    <link rel="stylesheet" href="../../../css/main.css">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-EFLTENL6KY"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-EFLTENL6KY');
    </script>

    <!-- Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'wait_for_update': 500,
            'region': ['BE','BG','CZ','DK','DE','EE','IE','EL','ES','FR','HR','IT','CY','LV','LT','LU','HU','MT','NL','AT','PL','PT','RO','SI','SK','FI','SE','IS','LI','NO','CH','GB']
        });
        gtag('consent', 'default', {
            'ad_storage': 'granted',
            'ad_user_data': 'granted',
            'ad_personalization': 'granted',
            'analytics_storage': 'granted'
        });
    </script>

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-PBS8M2JR');</script>

    </head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/">
                <span class="gradient-text">Wasil Zafar</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#about">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#skills">Skills</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#certifications">Certifications</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#interests">Interests</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link">
                    <i class="fas fa-arrow-left me-2"></i>Back to Technology
                </a>
                <h1 class="display-4 fw-bold mb-3">DSA Part 4: Strings</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>January 21, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>28 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
                <p class="lead">Master strings for FAANG interviews: string representation, pattern matching algorithms (KMP, Rabin-Karp), palindrome techniques, anagram detection, and classic interview problems with Python implementations.</p>
            </div>
        </div>
    </section>

    <!-- TOC Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close">&times;</button>
        </div>
        <ol>
            <li>
                <a href="#introduction" onclick="closeNav()">String Fundamentals</a>
                <ul>
                    <li><a href="#introduction" onclick="closeNav()">What Are Strings?</a></li>
                    <li><a href="#operations" onclick="closeNav()">Basic Operations</a></li>
                </ul>
            </li>
            <li>
                <a href="#pattern-matching" onclick="closeNav()">Pattern Matching</a>
                <ul>
                    <li><a href="#naive" onclick="closeNav()">Naive Algorithm</a></li>
                    <li><a href="#kmp" onclick="closeNav()">KMP Algorithm</a></li>
                    <li><a href="#rabin-karp" onclick="closeNav()">Rabin-Karp</a></li>
                </ul>
            </li>
            <li>
                <a href="#palindrome" onclick="closeNav()">Palindromes</a>
                <ul>
                    <li><a href="#palindrome" onclick="closeNav()">Checking Palindromes</a></li>
                    <li><a href="#longest-palindrome" onclick="closeNav()">Longest Palindromic Substring</a></li>
                </ul>
            </li>
            <li>
                <a href="#anagram" onclick="closeNav()">Anagrams</a>
                <ul>
                    <li><a href="#anagram" onclick="closeNav()">Anagram Detection</a></li>
                    <li><a href="#group-anagrams" onclick="closeNav()">Group Anagrams</a></li>
                </ul>
            </li>
            <li>
                <a href="#leetcode" onclick="closeNav()">Practice & Next Steps</a>
                <ul>
                    <li><a href="#leetcode" onclick="closeNav()">LeetCode Problems</a></li>
                    <li><a href="#next-steps" onclick="closeNav()">Next in Series</a></li>
                </ul>
            </li>
        </ol>
    </div>

    <!-- Overlay -->
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Main Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">
                    <div class="blog-content">

                        <!-- Introduction -->
                        <h2 id="introduction"><i class="fas fa-font me-2" style="color: var(--color-teal);"></i>String Fundamentals</h2>
                        
                        <p>Strings are one of the most common data types in programming and appear in nearly every FAANG interview. A string is a sequence of characters—understanding their internal representation and common operations is essential.</p>

                        <div class="highlight-box">
                            <i class="fas fa-lightbulb"></i>
                            <strong>Key Insight:</strong> In Python, strings are immutable—every modification creates a new string. This has important implications for time complexity: string concatenation in a loop is O(n²), not O(n)!
                        </div>

                        <div class="experiment-card">
                            <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                            <div class="mb-2">
                                <span class="badge bg-teal me-2">12-Part Series</span>
                                <span class="badge bg-crimson">FAANG Interview Prep</span>
                            </div>
                            <ol>
                                <li><a href="dsa-foundations-memory-complexity.html">Foundations, Memory & Complexity</a></li>
                                <li><a href="dsa-recursion-complete-guide.html">Recursion Complete Guide</a></li>
                                <li><a href="dsa-arrays-adt-operations.html">Arrays & Array ADT</a></li>
                                <li><strong>Strings (This Guide)</strong></li>
                                <li><a href="dsa-matrices-special-sparse.html">Matrices</a></li>
                                <li><a href="dsa-linked-lists-guide.html">Linked Lists</a></li>
                                <li><a href="dsa-stack-applications.html">Stack</a></li>
                                <li><a href="dsa-queue-implementations.html">Queue</a></li>
                                <li><a href="dsa-trees-fundamentals.html">Trees</a></li>
                                <li><a href="dsa-bst-avl-redblack.html">BST & Balanced Trees</a></li>
                                <li><a href="dsa-heaps-sorting-hashing.html">Heaps, Sorting & Hashing</a></li>
                                <li><a href="dsa-graphs-dp-greedy-backtracking.html">Graphs, DP, Greedy & Backtracking</a></li>
                            </ol>
                        </div>

                        <h3>String Representation</h3>
                        <p>Understanding how strings are stored in memory helps optimize string-heavy algorithms.</p>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># String Representation and Character Encoding
# ASCII: 7-bit (128 chars), Extended ASCII: 8-bit (256 chars)
# Unicode: Up to 1,114,112 code points

# Character to ASCII
char = 'A'
print(f"'{char}' → ASCII: {ord(char)}")  # 65

# ASCII to Character
ascii_val = 97
print(f"{ascii_val} → Character: {chr(ascii_val)}")  # 'a'

# String to list of ASCII values
text = "Hello"
ascii_list = [ord(c) for c in text]
print(f"'{text}' → ASCII: {ascii_list}")  # [72, 101, 108, 108, 111]

# Memory demonstration
import sys

s1 = "Hello"
s2 = "Hello World"
s3 = "Hello" * 100

print(f"\nString Memory Usage:")
print(f"'{s1}' (5 chars): {sys.getsizeof(s1)} bytes")
print(f"'{s2}' (11 chars): {sys.getsizeof(s2)} bytes")
print(f"'Hello' * 100 (500 chars): {sys.getsizeof(s3)} bytes")

# String interning (Python optimizes small strings)
a = "hello"
b = "hello"
print(f"\nString Interning:")
print(f"a = 'hello', b = 'hello'")
print(f"a is b: {a is b}")  # True - same object!
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    // Character to ASCII
    char c = 'A';
    cout << "'" << c << "' → ASCII: " << (int)c << endl;  // 65
    
    // ASCII to Character
    int asciiVal = 97;
    cout << asciiVal << " → Character: " << (char)asciiVal << endl;  // 'a'
    
    // String to vector of ASCII values
    string text = "Hello";
    vector&lt;int&gt; asciiList;
    cout << "'" << text << "' → ASCII: [";
    for (int i = 0; i < text.length(); i++) {
        asciiList.push_back((int)text[i]);
        cout << (int)text[i];
        if (i < text.length() - 1) cout << ", ";
    }
    cout << "]" << endl;  // [72, 101, 108, 108, 111]
    
    // String memory - C++ strings are mutable!
    string s1 = "Hello";
    string s2 = "Hello World";
    
    cout << "\nString Sizes (C++ strings are mutable):" << endl;
    cout << "'" << s1 << "': capacity=" << s1.capacity() 
         << ", size=" << s1.size() << endl;
    cout << "'" << s2 << "': capacity=" << s2.capacity() 
         << ", size=" << s2.size() << endl;
    
    // No interning in C++ - each string is separate
    string a = "hello";
    string b = "hello";
    cout << "\nNo String Interning in C++:" << endl;
    cout << "a == b: " << (a == b ? "true" : "false") << endl;  // true (value)
    cout << "&a == &b: " << (&a == &b ? "true" : "false") << endl;  // false (different objects)
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">public class StringRepresentation {
    public static void main(String[] args) {
        // Character to ASCII
        char c = 'A';
        System.out.println("'" + c + "' → ASCII: " + (int)c);  // 65
        
        // ASCII to Character
        int asciiVal = 97;
        System.out.println(asciiVal + " → Character: " + (char)asciiVal);  // 'a'
        
        // String to array of ASCII values
        String text = "Hello";
        int[] asciiList = new int[text.length()];
        System.out.print("'" + text + "' → ASCII: [");
        for (int i = 0; i < text.length(); i++) {
            asciiList[i] = (int)text.charAt(i);
            System.out.print(asciiList[i]);
            if (i < text.length() - 1) System.out.print(", ");
        }
        System.out.println("]");  // [72, 101, 108, 108, 111]
        
        // Java strings are immutable like Python
        String s1 = "Hello";
        String s2 = "Hello World";
        StringBuilder s3 = new StringBuilder();
        for (int i = 0; i < 100; i++) s3.append("Hello");
        
        System.out.println("\nString Memory (Java strings are immutable):");
        System.out.println("'" + s1 + "' (5 chars): " + s1.length() + " chars");
        System.out.println("'" + s2 + "' (11 chars): " + s2.length() + " chars");
        
        // String interning (Java pools literal strings)
        String a = "hello";
        String b = "hello";
        String c2 = new String("hello");
        
        System.out.println("\nString Interning in Java:");
        System.out.println("a == b: " + (a == b));  // true - same pooled object
        System.out.println("a == c (new String): " + (a == c2));  // false - different objects
        System.out.println("a.equals(c): " + a.equals(c2));  // true - same value
    }
}
</code></pre>

                        <!-- Basic Operations -->
                        <h2 id="operations"><i class="fas fa-tools me-2" style="color: var(--color-teal);"></i>Basic String Operations</h2>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Common String Operations and Their Complexities

# 1. Length - O(1) in Python (stored as attribute)
s = "Hello World"
print(f"Length: {len(s)}")  # 11

# 2. Indexing - O(1)
print(f"First char: {s[0]}")   # 'H'
print(f"Last char: {s[-1]}")   # 'd'

# 3. Slicing - O(k) where k is slice length
print(f"Slice [0:5]: {s[0:5]}")     # 'Hello'
print(f"Slice [6:]: {s[6:]}")       # 'World'
print(f"Reverse: {s[::-1]}")        # 'dlroW olleH'

# 4. Concatenation - O(n+m) creates new string
s1 = "Hello"
s2 = "World"
s3 = s1 + " " + s2  # O(len(s1) + len(s2))
print(f"Concatenation: {s3}")

# 5. Membership testing - O(n)
print(f"'World' in s: {'World' in s}")  # True

# 6. Find/Index - O(n*m) worst case
text = "Hello World"
print(f"Find 'World': {text.find('World')}")    # 6
print(f"Find 'xyz': {text.find('xyz')}")        # -1

# 7. Count - O(n)
print(f"Count 'l': {text.count('l')}")  # 3

# 8. Split - O(n)
words = text.split()
print(f"Split: {words}")  # ['Hello', 'World']

# 9. Join - O(total_length)
joined = "-".join(words)
print(f"Join: {joined}")  # 'Hello-World'

# 10. Replace - O(n)
replaced = text.replace("World", "Python")
print(f"Replace: {replaced}")  # 'Hello Python'
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    // 1. Length - O(1)
    string s = "Hello World";
    cout << "Length: " << s.length() << endl;  // 11
    
    // 2. Indexing - O(1)
    cout << "First char: " << s[0] << endl;      // 'H'
    cout << "Last char: " << s[s.length()-1] << endl;  // 'd'
    
    // 3. Substring - O(k)
    cout << "Substr [0,5): " << s.substr(0, 5) << endl;  // 'Hello'
    cout << "Substr [6,]: " << s.substr(6) << endl;      // 'World'
    
    // Reverse string
    string reversed = s;
    reverse(reversed.begin(), reversed.end());
    cout << "Reverse: " << reversed << endl;  // 'dlroW olleH'
    
    // 4. Concatenation - O(n+m), but C++ strings are mutable
    string s1 = "Hello";
    string s2 = "World";
    string s3 = s1 + " " + s2;
    cout << "Concatenation: " << s3 << endl;
    
    // 5. Find substring - O(n*m) worst
    string text = "Hello World";
    size_t pos = text.find("World");
    cout << "Find 'World': " << pos << endl;  // 6
    pos = text.find("xyz");
    cout << "Find 'xyz': " << (pos == string::npos ? -1 : (int)pos) << endl;  // -1
    
    // 6. Count occurrences - O(n)
    int count = 0;
    for (char c : text) if (c == 'l') count++;
    cout << "Count 'l': " << count << endl;  // 3
    
    // 7. Split - O(n) using stringstream
    vector&lt;string&gt; words;
    istringstream iss(text);
    string word;
    while (iss >> word) words.push_back(word);
    cout << "Split: [";
    for (int i = 0; i < words.size(); i++) {
        cout << "'" << words[i] << "'";
        if (i < words.size()-1) cout << ", ";
    }
    cout << "]" << endl;  // ['Hello', 'World']
    
    // 8. Join - O(total_length)
    string joined;
    for (int i = 0; i < words.size(); i++) {
        joined += words[i];
        if (i < words.size()-1) joined += "-";
    }
    cout << "Join: " << joined << endl;  // 'Hello-World'
    
    // 9. Replace - using algorithm
    string replaced = text;
    size_t start = replaced.find("World");
    if (start != string::npos) {
        replaced.replace(start, 5, "C++");
    }
    cout << "Replace: " << replaced << endl;  // 'Hello C++'
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">import java.util.*;

public class StringOperations {
    public static void main(String[] args) {
        // 1. Length - O(1)
        String s = "Hello World";
        System.out.println("Length: " + s.length());  // 11
        
        // 2. Indexing - O(1)
        System.out.println("First char: " + s.charAt(0));  // 'H'
        System.out.println("Last char: " + s.charAt(s.length()-1));  // 'd'
        
        // 3. Substring - O(k)
        System.out.println("Substring [0,5): " + s.substring(0, 5));  // 'Hello'
        System.out.println("Substring [6,]: " + s.substring(6));      // 'World'
        
        // Reverse string
        String reversed = new StringBuilder(s).reverse().toString();
        System.out.println("Reverse: " + reversed);  // 'dlroW olleH'
        
        // 4. Concatenation - O(n+m), use StringBuilder for efficiency
        String s1 = "Hello";
        String s2 = "World";
        String s3 = s1 + " " + s2;
        System.out.println("Concatenation: " + s3);
        
        // 5. Find substring - O(n*m) worst
        String text = "Hello World";
        System.out.println("Find 'World': " + text.indexOf("World"));  // 6
        System.out.println("Find 'xyz': " + text.indexOf("xyz"));      // -1
        
        // 6. Count occurrences - O(n)
        int count = 0;
        for (char c : text.toCharArray()) {
            if (c == 'l') count++;
        }
        System.out.println("Count 'l': " + count);  // 3
        
        // 7. Split - O(n)
        String[] words = text.split(" ");
        System.out.println("Split: " + Arrays.toString(words));  // [Hello, World]
        
        // 8. Join - O(total_length)
        String joined = String.join("-", words);
        System.out.println("Join: " + joined);  // 'Hello-World'
        
        // 9. Replace - O(n)
        String replaced = text.replace("World", "Java");
        System.out.println("Replace: " + replaced);  // 'Hello Java'
    }
}
</code></pre>

                        <h3>Efficient String Building</h3>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># String Building: Wrong vs Right Way

import time

# WRONG: String concatenation in loop - O(n²)
def build_string_wrong(n):
    result = ""
    for i in range(n):
        result += str(i)  # Creates new string each time!
    return result

# RIGHT: Using list and join - O(n)
def build_string_right(n):
    parts = []
    for i in range(n):
        parts.append(str(i))
    return "".join(parts)

# ALSO RIGHT: List comprehension + join - O(n)
def build_string_comprehension(n):
    return "".join(str(i) for i in range(n))

# Performance comparison
n = 10000

start = time.time()
build_string_wrong(n)
wrong_time = time.time() - start

start = time.time()
build_string_right(n)
right_time = time.time() - start

start = time.time()
build_string_comprehension(n)
comp_time = time.time() - start

print(f"String Building Performance (n={n}):")
print(f"  Concatenation (wrong): {wrong_time:.4f}s")
print(f"  List + join (right):   {right_time:.4f}s")
print(f"  Comprehension + join:  {comp_time:.4f}s")
print(f"  Speedup: {wrong_time/right_time:.1f}x faster!")
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;chrono&gt;
using namespace std;
using namespace std::chrono;

// SLOWER: String concatenation (still O(n) due to mutable strings, but less efficient)
string buildStringConcat(int n) {
    string result = "";
    for (int i = 0; i < n; i++) {
        result += to_string(i);  // Repeated reallocations
    }
    return result;
}

// BETTER: Reserve capacity first
string buildStringReserve(int n) {
    string result;
    result.reserve(n * 4);  // Pre-allocate space
    for (int i = 0; i < n; i++) {
        result += to_string(i);
    }
    return result;
}

// BEST: Use stringstream
string buildStringStream(int n) {
    stringstream ss;
    for (int i = 0; i < n; i++) {
        ss << i;
    }
    return ss.str();
}

int main() {
    int n = 100000;
    
    auto start = high_resolution_clock::now();
    buildStringConcat(n);
    auto concatTime = duration_cast&lt;milliseconds&gt;(
        high_resolution_clock::now() - start).count();
    
    start = high_resolution_clock::now();
    buildStringReserve(n);
    auto reserveTime = duration_cast&lt;milliseconds&gt;(
        high_resolution_clock::now() - start).count();
    
    start = high_resolution_clock::now();
    buildStringStream(n);
    auto streamTime = duration_cast&lt;milliseconds&gt;(
        high_resolution_clock::now() - start).count();
    
    cout << "String Building Performance (n=" << n << "):" << endl;
    cout << "  Concatenation:  " << concatTime << "ms" << endl;
    cout << "  With reserve(): " << reserveTime << "ms" << endl;
    cout << "  StringStream:   " << streamTime << "ms" << endl;
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">public class StringBuilding {
    // WRONG: String concatenation in loop - O(n²) due to immutable strings
    static String buildStringWrong(int n) {
        String result = "";
        for (int i = 0; i < n; i++) {
            result += i;  // Creates new String each time!
        }
        return result;
    }
    
    // RIGHT: Using StringBuilder - O(n)
    static String buildStringRight(int n) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.append(i);
        }
        return sb.toString();
    }
    
    // ALSO RIGHT: With initial capacity for better performance
    static String buildStringCapacity(int n) {
        StringBuilder sb = new StringBuilder(n * 4);  // Pre-allocate
        for (int i = 0; i < n; i++) {
            sb.append(i);
        }
        return sb.toString();
    }
    
    public static void main(String[] args) {
        int n = 10000;
        
        long start = System.nanoTime();
        buildStringWrong(n);
        long wrongTime = (System.nanoTime() - start) / 1_000_000;
        
        start = System.nanoTime();
        buildStringRight(n);
        long rightTime = (System.nanoTime() - start) / 1_000_000;
        
        start = System.nanoTime();
        buildStringCapacity(n);
        long capTime = (System.nanoTime() - start) / 1_000_000;
        
        System.out.println("String Building Performance (n=" + n + "):");
        System.out.println("  Concatenation (wrong):   " + wrongTime + "ms");
        System.out.println("  StringBuilder (right):   " + rightTime + "ms");
        System.out.println("  With capacity:           " + capTime + "ms");
        if (rightTime > 0) {
            System.out.println("  Speedup: " + (wrongTime/rightTime) + "x faster!");
        }
    }
}
</code></pre>

                        <!-- Pattern Matching -->
                        <h2 id="pattern-matching"><i class="fas fa-search me-2" style="color: var(--color-teal);"></i>Pattern Matching Algorithms</h2>

                        <p>Pattern matching—finding a pattern within a text—is a fundamental problem with applications in text editors, search engines, and bioinformatics.</p>

                        <!-- Naive -->
                        <h3 id="naive">Naive (Brute Force) Algorithm</h3>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Naive Pattern Matching
# Time: O((n-m+1) × m) where n=text length, m=pattern length
# Space: O(1)

def naive_search(text, pattern):
    """
    Find all occurrences of pattern in text.
    Returns list of starting indices.
    """
    n = len(text)
    m = len(pattern)
    occurrences = []
    
    # Slide pattern over text
    for i in range(n - m + 1):
        match = True
        # Check each character
        for j in range(m):
            if text[i + j] != pattern[j]:
                match = False
                break
        if match:
            occurrences.append(i)
    
    return occurrences

# Test
text = "AABAACAADAABAAABAA"
pattern = "AABA"

result = naive_search(text, pattern)
print(f"Text: {text}")
print(f"Pattern: {pattern}")
print(f"Found at indices: {result}")  # [0, 9, 13]

# Visualize matches
for idx in result:
    print(f"  Position {idx}: {text[idx:idx+len(pattern)]}")
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

// Naive Pattern Matching
// Time: O((n-m+1) × m), Space: O(1)
vector&lt;int&gt; naiveSearch(const string& text, const string& pattern) {
    int n = text.length();
    int m = pattern.length();
    vector&lt;int&gt; occurrences;
    
    // Slide pattern over text
    for (int i = 0; i <= n - m; i++) {
        bool match = true;
        // Check each character
        for (int j = 0; j < m; j++) {
            if (text[i + j] != pattern[j]) {
                match = false;
                break;
            }
        }
        if (match) {
            occurrences.push_back(i);
        }
    }
    
    return occurrences;
}

int main() {
    string text = "AABAACAADAABAAABAA";
    string pattern = "AABA";
    
    vector&lt;int&gt; result = naiveSearch(text, pattern);
    
    cout << "Text: " << text << endl;
    cout << "Pattern: " << pattern << endl;
    cout << "Found at indices: [";
    for (int i = 0; i < result.size(); i++) {
        cout << result[i];
        if (i < result.size() - 1) cout << ", ";
    }
    cout << "]" << endl;  // [0, 9, 13]
    
    // Visualize matches
    for (int idx : result) {
        cout << "  Position " << idx << ": " 
             << text.substr(idx, pattern.length()) << endl;
    }
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">import java.util.*;

public class NaivePatternMatch {
    // Naive Pattern Matching
    // Time: O((n-m+1) × m), Space: O(1)
    static List&lt;Integer&gt; naiveSearch(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        List&lt;Integer&gt; occurrences = new ArrayList&lt;&gt;();
        
        // Slide pattern over text
        for (int i = 0; i <= n - m; i++) {
            boolean match = true;
            // Check each character
            for (int j = 0; j < m; j++) {
                if (text.charAt(i + j) != pattern.charAt(j)) {
                    match = false;
                    break;
                }
            }
            if (match) {
                occurrences.add(i);
            }
        }
        
        return occurrences;
    }
    
    public static void main(String[] args) {
        String text = "AABAACAADAABAAABAA";
        String pattern = "AABA";
        
        List&lt;Integer&gt; result = naiveSearch(text, pattern);
        
        System.out.println("Text: " + text);
        System.out.println("Pattern: " + pattern);
        System.out.println("Found at indices: " + result);  // [0, 9, 13]
        
        // Visualize matches
        for (int idx : result) {
            System.out.println("  Position " + idx + ": " + 
                             text.substring(idx, idx + pattern.length()));
        }
    }
}
</code></pre>

                        <!-- KMP -->
                        <h3 id="kmp">KMP (Knuth-Morris-Pratt) Algorithm</h3>

                        <p>KMP improves on naive search by avoiding re-examination of matched characters. It preprocesses the pattern to build a "failure function" (LPS array).</p>

                        <div class="highlight-box">
                            <i class="fas fa-info-circle"></i>
                            <strong>LPS Array:</strong> Longest Proper Prefix which is also Suffix. For pattern "AABAAC", LPS = [0, 1, 0, 1, 2, 0].
                        </div>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># KMP Pattern Matching Algorithm
# Time: O(n + m) - linear!
# Space: O(m) for LPS array

def compute_lps(pattern):
    """
    Compute Longest Proper Prefix which is also Suffix (LPS) array.
    
    LPS[i] = length of longest proper prefix of pattern[0..i]
             which is also a suffix of pattern[0..i]
    """
    m = len(pattern)
    lps = [0] * m
    
    length = 0  # Length of previous longest prefix suffix
    i = 1
    
    while i < m:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                # Try shorter prefix
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    
    return lps

def kmp_search(text, pattern):
    """
    KMP pattern matching algorithm.
    Returns list of starting indices where pattern is found.
    """
    n = len(text)
    m = len(pattern)
    
    if m == 0:
        return []
    
    # Compute LPS array
    lps = compute_lps(pattern)
    
    occurrences = []
    i = 0  # Index for text
    j = 0  # Index for pattern
    
    while i < n:
        if pattern[j] == text[i]:
            i += 1
            j += 1
        
        if j == m:
            # Found pattern
            occurrences.append(i - j)
            j = lps[j - 1]  # Use LPS to skip
        elif i < n and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]  # Use LPS to skip
            else:
                i += 1
    
    return occurrences

# Test KMP
text = "AABAACAADAABAAABAA"
pattern = "AABA"

lps = compute_lps(pattern)
print(f"Pattern: {pattern}")
print(f"LPS array: {lps}")

result = kmp_search(text, pattern)
print(f"\nText: {text}")
print(f"Pattern found at: {result}")  # [0, 9, 13]

# Step-by-step LPS example
pattern2 = "AABAACAAB"
lps2 = compute_lps(pattern2)
print(f"\nPattern: {pattern2}")
print(f"Index:   {list(range(len(pattern2)))}")
print(f"LPS:     {lps2}")
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

// Compute LPS (Longest Proper Prefix which is also Suffix) array
vector&lt;int&gt; computeLPS(const string& pattern) {
    int m = pattern.length();
    vector&lt;int&gt; lps(m, 0);
    
    int length = 0;  // Length of previous longest prefix suffix
    int i = 1;
    
    while (i < m) {
        if (pattern[i] == pattern[length]) {
            length++;
            lps[i] = length;
            i++;
        } else {
            if (length != 0) {
                // Try shorter prefix
                length = lps[length - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    
    return lps;
}

// KMP Pattern Matching - O(n + m)
vector&lt;int&gt; kmpSearch(const string& text, const string& pattern) {
    int n = text.length();
    int m = pattern.length();
    vector&lt;int&gt; occurrences;
    
    if (m == 0) return occurrences;
    
    vector&lt;int&gt; lps = computeLPS(pattern);
    
    int i = 0;  // Index for text
    int j = 0;  // Index for pattern
    
    while (i < n) {
        if (pattern[j] == text[i]) {
            i++;
            j++;
        }
        
        if (j == m) {
            // Found pattern
            occurrences.push_back(i - j);
            j = lps[j - 1];  // Use LPS to skip
        } else if (i < n && pattern[j] != text[i]) {
            if (j != 0) {
                j = lps[j - 1];  // Use LPS to skip
            } else {
                i++;
            }
        }
    }
    
    return occurrences;
}

int main() {
    string text = "AABAACAADAABAAABAA";
    string pattern = "AABA";
    
    vector&lt;int&gt; lps = computeLPS(pattern);
    cout << "Pattern: " << pattern << endl;
    cout << "LPS array: [";
    for (int i = 0; i < lps.size(); i++) {
        cout << lps[i];
        if (i < lps.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    vector&lt;int&gt; result = kmpSearch(text, pattern);
    cout << "\nText: " << text << endl;
    cout << "Pattern found at: [";
    for (int i = 0; i < result.size(); i++) {
        cout << result[i];
        if (i < result.size() - 1) cout << ", ";
    }
    cout << "]" << endl;  // [0, 9, 13]
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">import java.util.*;

public class KMPAlgorithm {
    // Compute LPS (Longest Proper Prefix which is also Suffix) array
    static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        
        int length = 0;  // Length of previous longest prefix suffix
        int i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(length)) {
                length++;
                lps[i] = length;
                i++;
            } else {
                if (length != 0) {
                    // Try shorter prefix
                    length = lps[length - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        
        return lps;
    }
    
    // KMP Pattern Matching - O(n + m)
    static List&lt;Integer&gt; kmpSearch(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        List&lt;Integer&gt; occurrences = new ArrayList&lt;&gt;();
        
        if (m == 0) return occurrences;
        
        int[] lps = computeLPS(pattern);
        
        int i = 0;  // Index for text
        int j = 0;  // Index for pattern
        
        while (i < n) {
            if (pattern.charAt(j) == text.charAt(i)) {
                i++;
                j++;
            }
            
            if (j == m) {
                // Found pattern
                occurrences.add(i - j);
                j = lps[j - 1];  // Use LPS to skip
            } else if (i < n && pattern.charAt(j) != text.charAt(i)) {
                if (j != 0) {
                    j = lps[j - 1];  // Use LPS to skip
                } else {
                    i++;
                }
            }
        }
        
        return occurrences;
    }
    
    public static void main(String[] args) {
        String text = "AABAACAADAABAAABAA";
        String pattern = "AABA";
        
        int[] lps = computeLPS(pattern);
        System.out.println("Pattern: " + pattern);
        System.out.println("LPS array: " + Arrays.toString(lps));
        
        List&lt;Integer&gt; result = kmpSearch(text, pattern);
        System.out.println("\nText: " + text);
        System.out.println("Pattern found at: " + result);  // [0, 9, 13]
    }
}
</code></pre>

                        <!-- Rabin-Karp -->
                        <h3 id="rabin-karp">Rabin-Karp Algorithm</h3>

                        <p>Rabin-Karp uses hashing to find pattern matches. It's particularly useful for multiple pattern search and plagiarism detection.</p>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Rabin-Karp Algorithm with Rolling Hash
# Average Time: O(n + m)
# Worst Time: O(n × m) - many hash collisions
# Space: O(1)

def rabin_karp(text, pattern, base=256, prime=101):
    """
    Rabin-Karp pattern matching using rolling hash.
    
    Hash function: h = (c[0]*base^(m-1) + c[1]*base^(m-2) + ... + c[m-1]) % prime
    
    Rolling hash: Remove first char, add new char
    new_hash = (base * (old_hash - text[i-1] * base^(m-1)) + text[i+m-1]) % prime
    """
    n = len(text)
    m = len(pattern)
    occurrences = []
    
    if m > n:
        return occurrences
    
    # Precompute base^(m-1) % prime
    h = pow(base, m - 1, prime)
    
    # Calculate hash of pattern and first window of text
    pattern_hash = 0
    text_hash = 0
    
    for i in range(m):
        pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime
        text_hash = (base * text_hash + ord(text[i])) % prime
    
    # Slide pattern over text
    for i in range(n - m + 1):
        # Check hash match
        if pattern_hash == text_hash:
            # Verify character by character (avoid false positives)
            if text[i:i+m] == pattern:
                occurrences.append(i)
        
        # Calculate hash for next window using rolling hash
        if i < n - m:
            # Remove leading digit, add trailing digit
            text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime
            
            # Handle negative hash
            if text_hash < 0:
                text_hash += prime
    
    return occurrences

# Test Rabin-Karp
text = "AABAACAADAABAAABAA"
pattern = "AABA"

result = rabin_karp(text, pattern)
print(f"Text: {text}")
print(f"Pattern: {pattern}")
print(f"Found at indices: {result}")  # [0, 9, 13]

# Hash collision demonstration
print("\nHash values during search:")
m = len(pattern)
for i in range(len(text) - m + 1):
    window = text[i:i+m]
    h = sum(ord(c) * (256 ** (m-1-j)) for j, c in enumerate(window)) % 101
    match = "← MATCH!" if window == pattern else ""
    print(f"  Window '{window}': hash={h} {match}")
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

// Rabin-Karp Algorithm with Rolling Hash
// Average Time: O(n + m), Worst: O(n × m)
vector&lt;int&gt; rabinKarp(const string& text, const string& pattern, 
                       int base = 256, int prime = 101) {
    int n = text.length();
    int m = pattern.length();
    vector&lt;int&gt; occurrences;
    
    if (m > n) return occurrences;
    
    // Precompute base^(m-1) % prime
    long long h = 1;
    for (int i = 0; i < m - 1; i++) {
        h = (h * base) % prime;
    }
    
    // Calculate hash of pattern and first window of text
    long long patternHash = 0;
    long long textHash = 0;
    
    for (int i = 0; i < m; i++) {
        patternHash = (base * patternHash + pattern[i]) % prime;
        textHash = (base * textHash + text[i]) % prime;
    }
    
    // Slide pattern over text
    for (int i = 0; i <= n - m; i++) {
        // Check hash match
        if (patternHash == textHash) {
            // Verify character by character
            bool match = true;
            for (int j = 0; j < m; j++) {
                if (text[i + j] != pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                occurrences.push_back(i);
            }
        }
        
        // Calculate hash for next window (rolling hash)
        if (i < n - m) {
            textHash = (base * (textHash - text[i] * h) + text[i + m]) % prime;
            
            // Handle negative hash
            if (textHash < 0) {
                textHash += prime;
            }
        }
    }
    
    return occurrences;
}

int main() {
    string text = "AABAACAADAABAAABAA";
    string pattern = "AABA";
    
    vector&lt;int&gt; result = rabinKarp(text, pattern);
    
    cout << "Text: " << text << endl;
    cout << "Pattern: " << pattern << endl;
    cout << "Found at indices: [";
    for (int i = 0; i < result.size(); i++) {
        cout << result[i];
        if (i < result.size() - 1) cout << ", ";
    }
    cout << "]" << endl;  // [0, 9, 13]
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">import java.util.*;

public class RabinKarpAlgorithm {
    // Rabin-Karp Algorithm with Rolling Hash
    // Average Time: O(n + m), Worst: O(n × m)
    static List&lt;Integer&gt; rabinKarp(String text, String pattern, 
                                     int base, int prime) {
        int n = text.length();
        int m = pattern.length();
        List&lt;Integer&gt; occurrences = new ArrayList&lt;&gt;();
        
        if (m > n) return occurrences;
        
        // Precompute base^(m-1) % prime
        long h = 1;
        for (int i = 0; i < m - 1; i++) {
            h = (h * base) % prime;
        }
        
        // Calculate hash of pattern and first window of text
        long patternHash = 0;
        long textHash = 0;
        
        for (int i = 0; i < m; i++) {
            patternHash = (base * patternHash + pattern.charAt(i)) % prime;
            textHash = (base * textHash + text.charAt(i)) % prime;
        }
        
        // Slide pattern over text
        for (int i = 0; i <= n - m; i++) {
            // Check hash match
            if (patternHash == textHash) {
                // Verify character by character
                if (text.substring(i, i + m).equals(pattern)) {
                    occurrences.add(i);
                }
            }
            
            // Calculate hash for next window (rolling hash)
            if (i < n - m) {
                textHash = (base * (textHash - text.charAt(i) * h) 
                           + text.charAt(i + m)) % prime;
                
                // Handle negative hash
                if (textHash < 0) {
                    textHash += prime;
                }
            }
        }
        
        return occurrences;
    }
    
    public static void main(String[] args) {
        String text = "AABAACAADAABAAABAA";
        String pattern = "AABA";
        
        List&lt;Integer&gt; result = rabinKarp(text, pattern, 256, 101);
        
        System.out.println("Text: " + text);
        System.out.println("Pattern: " + pattern);
        System.out.println("Found at indices: " + result);  // [0, 9, 13]
    }
}
</code></pre>

                        <h3>Pattern Matching Comparison</h3>

                        <table class="complexity-table">
                            <thead>
                                <tr>
                                    <th>Algorithm</th>
                                    <th>Preprocessing</th>
                                    <th>Search Time</th>
                                    <th>Best For</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td><strong>Naive</strong></td><td>None</td><td>O(n×m)</td><td>Short patterns, simple cases</td></tr>
                                <tr><td><strong>KMP</strong></td><td>O(m)</td><td>O(n)</td><td>Single pattern, guaranteed linear</td></tr>
                                <tr><td><strong>Rabin-Karp</strong></td><td>O(m)</td><td>O(n) average</td><td>Multiple patterns, plagiarism detection</td></tr>
                            </tbody>
                        </table>

                        <!-- Palindrome -->
                        <h2 id="palindrome"><i class="fas fa-sync me-2" style="color: var(--color-teal);"></i>Palindrome Algorithms</h2>

                        <p>Palindromes read the same forwards and backwards. They appear frequently in interviews!</p>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Palindrome Checking Methods

def is_palindrome_two_pointer(s):
    """
    Two-pointer approach.
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(s) - 1
    
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    
    return True

def is_palindrome_reverse(s):
    """
    Reverse and compare.
    Time: O(n), Space: O(n)
    """
    return s == s[::-1]

def is_palindrome_recursive(s):
    """
    Recursive approach.
    Time: O(n), Space: O(n) - call stack
    """
    if len(s) <= 1:
        return True
    if s[0] != s[-1]:
        return False
    return is_palindrome_recursive(s[1:-1])

def is_valid_palindrome(s):
    """
    Check palindrome ignoring non-alphanumeric and case.
    LeetCode 125 - Valid Palindrome
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric from left
        while left < right and not s[left].isalnum():
            left += 1
        # Skip non-alphanumeric from right
        while left < right and not s[right].isalnum():
            right -= 1
        
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True

# Test palindrome functions
test_strings = ["racecar", "hello", "A man a plan a canal Panama", "12321"]

print("Palindrome Tests:")
for s in test_strings:
    clean = ''.join(c.lower() for c in s if c.isalnum())
    result = is_palindrome_two_pointer(clean)
    print(f"  '{s}' → {result}")

# Valid palindrome (with special chars)
print("\nValid Palindrome (ignoring case/special chars):")
print(f"  'A man, a plan, a canal: Panama' → {is_valid_palindrome('A man, a plan, a canal: Panama')}")
print(f"  'race a car' → {is_valid_palindrome('race a car')}")
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
using namespace std;

// Two-pointer approach - O(n), O(1)
bool isPalindromeTwoPointer(const string& s) {
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        if (s[left] != s[right]) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}

// Reverse and compare - O(n), O(n)
bool isPalindromeReverse(const string& s) {
    string reversed = s;
    reverse(reversed.begin(), reversed.end());
    return s == reversed;
}

// Recursive approach - O(n), O(n) stack
bool isPalindromeRecursive(const string& s, int left, int right) {
    if (left >= right) return true;
    if (s[left] != s[right]) return false;
    return isPalindromeRecursive(s, left + 1, right - 1);
}

// Valid palindrome ignoring non-alphanumeric - LeetCode 125
bool isValidPalindrome(const string& s) {
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        // Skip non-alphanumeric from left
        while (left < right && !isalnum(s[left])) left++;
        // Skip non-alphanumeric from right
        while (left < right && !isalnum(s[right])) right--;
        
        if (tolower(s[left]) != tolower(s[right])) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}

int main() {
    // Test cases
    string tests[] = {"racecar", "hello", "12321"};
    
    cout << "Palindrome Tests:" << endl;
    for (const string& s : tests) {
        cout << "  '" << s << "' → " 
             << (isPalindromeTwoPointer(s) ? "true" : "false") << endl;
    }
    
    cout << "\nValid Palindrome (ignoring case/special chars):" << endl;
    cout << "  'A man, a plan, a canal: Panama' → " 
         << (isValidPalindrome("A man, a plan, a canal: Panama") ? "true" : "false") 
         << endl;
    cout << "  'race a car' → " 
         << (isValidPalindrome("race a car") ? "true" : "false") << endl;
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">public class PalindromeCheck {
    // Two-pointer approach - O(n), O(1)
    static boolean isPalindromeTwoPointer(String s) {
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    // Reverse and compare - O(n), O(n)
    static boolean isPalindromeReverse(String s) {
        String reversed = new StringBuilder(s).reverse().toString();
        return s.equals(reversed);
    }
    
    // Recursive approach - O(n), O(n) stack
    static boolean isPalindromeRecursive(String s, int left, int right) {
        if (left >= right) return true;
        if (s.charAt(left) != s.charAt(right)) return false;
        return isPalindromeRecursive(s, left + 1, right - 1);
    }
    
    // Valid palindrome ignoring non-alphanumeric - LeetCode 125
    static boolean isValidPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            // Skip non-alphanumeric from left
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            // Skip non-alphanumeric from right
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }
            
            if (Character.toLowerCase(s.charAt(left)) != 
                Character.toLowerCase(s.charAt(right))) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        String[] tests = {"racecar", "hello", "12321"};
        
        System.out.println("Palindrome Tests:");
        for (String s : tests) {
            System.out.println("  '" + s + "' → " + isPalindromeTwoPointer(s));
        }
        
        System.out.println("\nValid Palindrome (ignoring case/special chars):");
        System.out.println("  'A man, a plan, a canal: Panama' → " + 
            isValidPalindrome("A man, a plan, a canal: Panama"));
        System.out.println("  'race a car' → " + 
            isValidPalindrome("race a car"));
    }
}
</code></pre>

                        <!-- Longest Palindrome -->
                        <h3 id="longest-palindrome">Longest Palindromic Substring</h3>

                        <p>Finding the longest palindromic substring is a classic interview question. The expand-around-center approach is optimal for interviews.</p>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Longest Palindromic Substring
# Expand Around Center Approach
# Time: O(n²), Space: O(1)

def longest_palindrome(s):
    """
    Find longest palindromic substring using expand around center.
    
    Key insight: A palindrome mirrors around its center.
    There are 2n-1 such centers (n single chars + n-1 between chars).
    """
    if not s:
        return ""
    
    def expand_around_center(left, right):
        """Expand outward while characters match."""
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        # Return the palindrome (left+1 to right-1 inclusive)
        return s[left + 1:right]
    
    result = ""
    
    for i in range(len(s)):
        # Odd length palindrome (single center)
        odd = expand_around_center(i, i)
        if len(odd) > len(result):
            result = odd
        
        # Even length palindrome (two centers)
        even = expand_around_center(i, i + 1)
        if len(even) > len(result):
            result = even
    
    return result

# Test
test_strings = ["babad", "cbbd", "abcba", "ac", "a", "racecar"]

print("Longest Palindromic Substring:")
for s in test_strings:
    result = longest_palindrome(s)
    print(f"  '{s}' → '{result}' (length {len(result)})")

# Trace example
s = "babad"
print(f"\nTrace for '{s}':")
for i in range(len(s)):
    print(f"  Center at index {i} ('{s[i]}'):")
    
    # Odd expansion
    l, r = i, i
    while l >= 0 and r < len(s) and s[l] == s[r]:
        print(f"    Odd: '{s[l:r+1]}'")
        l -= 1
        r += 1
    
    # Even expansion
    l, r = i, i + 1
    while l >= 0 and r < len(s) and s[l] == s[r]:
        print(f"    Even: '{s[l:r+1]}'")
        l -= 1
        r += 1
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// Longest Palindromic Substring - Expand Around Center
// Time: O(n²), Space: O(1)
string longestPalindrome(const string& s) {
    if (s.empty()) return "";
    
    int start = 0, maxLen = 1;
    
    // Helper to expand around center
    auto expandAroundCenter = [&](int left, int right) {
        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            if (right - left + 1 > maxLen) {
                start = left;
                maxLen = right - left + 1;
            }
            left--;
            right++;
        }
    };
    
    for (int i = 0; i < s.length(); i++) {
        // Odd length palindrome
        expandAroundCenter(i, i);
        
        // Even length palindrome
        expandAroundCenter(i, i + 1);
    }
    
    return s.substr(start, maxLen);
}

int main() {
    string tests[] = {"babad", "cbbd", "abcba", "ac", "a", "racecar"};
    
    cout << "Longest Palindromic Substring:" << endl;
    for (const string& s : tests) {
        string result = longestPalindrome(s);
        cout << "  '" << s << "' → '" << result 
             << "' (length " << result.length() << ")" << endl;
    }
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">public class LongestPalindrome {
    // Longest Palindromic Substring - Expand Around Center
    // Time: O(n²), Space: O(1)
    
    static int start = 0, maxLen = 1;
    
    static void expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && 
               s.charAt(left) == s.charAt(right)) {
            if (right - left + 1 > maxLen) {
                start = left;
                maxLen = right - left + 1;
            }
            left--;
            right++;
        }
    }
    
    static String longestPalindrome(String s) {
        if (s == null || s.isEmpty()) return "";
        
        start = 0;
        maxLen = 1;
        
        for (int i = 0; i < s.length(); i++) {
            // Odd length palindrome
            expandAroundCenter(s, i, i);
            
            // Even length palindrome
            expandAroundCenter(s, i, i + 1);
        }
        
        return s.substring(start, start + maxLen);
    }
    
    public static void main(String[] args) {
        String[] tests = {"babad", "cbbd", "abcba", "ac", "a", "racecar"};
        
        System.out.println("Longest Palindromic Substring:");
        for (String s : tests) {
            String result = longestPalindrome(s);
            System.out.println("  '" + s + "' → '" + result + 
                             "' (length " + result.length() + ")");
        }
    }
}
</code></pre>

                        <!-- Anagram -->
                        <h2 id="anagram"><i class="fas fa-random me-2" style="color: var(--color-teal);"></i>Anagram Algorithms</h2>

                        <p>Anagrams are words formed by rearranging letters of another word. They're common in interview questions!</p>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Anagram Detection Methods
from collections import Counter

def is_anagram_sort(s1, s2):
    """
    Check anagram by sorting.
    Time: O(n log n), Space: O(n)
    """
    return sorted(s1) == sorted(s2)

def is_anagram_count(s1, s2):
    """
    Check anagram using character count.
    Time: O(n), Space: O(1) - fixed alphabet
    """
    if len(s1) != len(s2):
        return False
    
    # Count characters
    count = [0] * 26  # Assuming lowercase a-z
    
    for c1, c2 in zip(s1, s2):
        count[ord(c1) - ord('a')] += 1
        count[ord(c2) - ord('a')] -= 1
    
    return all(c == 0 for c in count)

def is_anagram_counter(s1, s2):
    """
    Check anagram using Counter.
    Time: O(n), Space: O(n)
    """
    return Counter(s1) == Counter(s2)

# Test anagram detection
pairs = [
    ("listen", "silent"),
    ("hello", "world"),
    ("anagram", "nagaram"),
    ("rat", "car")
]

print("Anagram Detection:")
for s1, s2 in pairs:
    result = is_anagram_count(s1, s2)
    print(f"  '{s1}' vs '{s2}': {result}")
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

// Check anagram by sorting - O(n log n), O(n)
bool isAnagramSort(string s1, string s2) {
    sort(s1.begin(), s1.end());
    sort(s2.begin(), s2.end());
    return s1 == s2;
}

// Check anagram using character count - O(n), O(1)
bool isAnagramCount(const string& s1, const string& s2) {
    if (s1.length() != s2.length()) return false;
    
    int count[26] = {0};  // Assuming lowercase a-z
    
    for (int i = 0; i < s1.length(); i++) {
        count[s1[i] - 'a']++;
        count[s2[i] - 'a']--;
    }
    
    for (int i = 0; i < 26; i++) {
        if (count[i] != 0) return false;
    }
    
    return true;
}

int main() {
    vector&lt;pair&lt;string, string&gt;&gt; pairs = {
        {"listen", "silent"},
        {"hello", "world"},
        {"anagram", "nagaram"},
        {"rat", "car"}
    };
    
    cout << "Anagram Detection:" << endl;
    for (const auto& p : pairs) {
        bool result = isAnagramCount(p.first, p.second);
        cout << "  '" << p.first << "' vs '" << p.second 
             << "': " << (result ? "true" : "false") << endl;
    }
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">import java.util.*;

public class AnagramDetection {
    // Check anagram by sorting - O(n log n), O(n)
    static boolean isAnagramSort(String s1, String s2) {
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        return Arrays.equals(arr1, arr2);
    }
    
    // Check anagram using character count - O(n), O(1)
    static boolean isAnagramCount(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        
        int[] count = new int[26];  // Assuming lowercase a-z
        
        for (int i = 0; i < s1.length(); i++) {
            count[s1.charAt(i) - 'a']++;
            count[s2.charAt(i) - 'a']--;
        }
        
        for (int c : count) {
            if (c != 0) return false;
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        String[][] pairs = {
            {"listen", "silent"},
            {"hello", "world"},
            {"anagram", "nagaram"},
            {"rat", "car"}
        };
        
        System.out.println("Anagram Detection:");
        for (String[] p : pairs) {
            boolean result = isAnagramCount(p[0], p[1]);
            System.out.println("  '" + p[0] + "' vs '" + p[1] + "': " + result);
        }
    }
}
</code></pre>

                        <!-- Group Anagrams -->
                        <h3 id="group-anagrams">Group Anagrams</h3>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Group Anagrams - LeetCode 49
# Time: O(n × k log k) where n=words, k=max word length
# Space: O(n × k)

from collections import defaultdict

def group_anagrams_sort(strs):
    """
    Group anagrams using sorted string as key.
    """
    groups = defaultdict(list)
    
    for s in strs:
        # Sorted string is the key
        key = tuple(sorted(s))
        groups[key].append(s)
    
    return list(groups.values())

def group_anagrams_count(strs):
    """
    Group anagrams using character count as key.
    Time: O(n × k) - no sorting needed
    """
    groups = defaultdict(list)
    
    for s in strs:
        # Character count tuple as key
        count = [0] * 26
        for c in s:
            count[ord(c) - ord('a')] += 1
        key = tuple(count)
        groups[key].append(s)
    
    return list(groups.values())

# Test group anagrams
words = ["eat", "tea", "tan", "ate", "nat", "bat"]

print(f"Words: {words}")
print(f"\nGrouped (sort method):")
for group in group_anagrams_sort(words):
    print(f"  {group}")

print(f"\nGrouped (count method):")
for group in group_anagrams_count(words):
    print(f"  {group}")
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;
using namespace std;

// Group Anagrams - LeetCode 49
// Using sorted string as key - O(n × k log k)
vector&lt;vector&lt;string&gt;&gt; groupAnagramsSort(vector&lt;string&gt;& strs) {
    unordered_map&lt;string, vector&lt;string&gt;&gt; groups;
    
    for (const string& s : strs) {
        string key = s;
        sort(key.begin(), key.end());
        groups[key].push_back(s);
    }
    
    vector&lt;vector&lt;string&gt;&gt; result;
    for (auto& p : groups) {
        result.push_back(move(p.second));
    }
    
    return result;
}

// Using character count as key - O(n × k)
vector&lt;vector&lt;string&gt;&gt; groupAnagramsCount(vector&lt;string&gt;& strs) {
    unordered_map&lt;string, vector&lt;string&gt;&gt; groups;
    
    for (const string& s : strs) {
        // Create count key
        int count[26] = {0};
        for (char c : s) {
            count[c - 'a']++;
        }
        
        // Convert count to string key
        string key = "";
        for (int i = 0; i < 26; i++) {
            key += "#" + to_string(count[i]);
        }
        
        groups[key].push_back(s);
    }
    
    vector&lt;vector&lt;string&gt;&gt; result;
    for (auto& p : groups) {
        result.push_back(move(p.second));
    }
    
    return result;
}

int main() {
    vector&lt;string&gt; words = {"eat", "tea", "tan", "ate", "nat", "bat"};
    
    cout << "Words: [";
    for (int i = 0; i < words.size(); i++) {
        cout << "\"" << words[i] << "\"";
        if (i < words.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    cout << "\nGrouped (sort method):" << endl;
    auto result = groupAnagramsSort(words);
    for (const auto& group : result) {
        cout << "  [";
        for (int i = 0; i < group.size(); i++) {
            cout << "\"" << group[i] << "\"";
            if (i < group.size() - 1) cout << ", ";
        }
        cout << "]" << endl;
    }
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">import java.util.*;

public class GroupAnagrams {
    // Group Anagrams - LeetCode 49
    // Using sorted string as key - O(n × k log k)
    static List&lt;List&lt;String&gt;&gt; groupAnagramsSort(String[] strs) {
        Map&lt;String, List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();
        
        for (String s : strs) {
            char[] arr = s.toCharArray();
            Arrays.sort(arr);
            String key = new String(arr);
            
            groups.computeIfAbsent(key, k -> new ArrayList&lt;&gt;()).add(s);
        }
        
        return new ArrayList&lt;&gt;(groups.values());
    }
    
    // Using character count as key - O(n × k)
    static List&lt;List&lt;String&gt;&gt; groupAnagramsCount(String[] strs) {
        Map&lt;String, List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();
        
        for (String s : strs) {
            // Create count key
            int[] count = new int[26];
            for (char c : s.toCharArray()) {
                count[c - 'a']++;
            }
            
            // Convert count to string key
            StringBuilder key = new StringBuilder();
            for (int i = 0; i < 26; i++) {
                key.append("#").append(count[i]);
            }
            
            groups.computeIfAbsent(key.toString(), k -> new ArrayList&lt;&gt;()).add(s);
        }
        
        return new ArrayList&lt;&gt;(groups.values());
    }
    
    public static void main(String[] args) {
        String[] words = {"eat", "tea", "tan", "ate", "nat", "bat"};
        
        System.out.println("Words: " + Arrays.toString(words));
        
        System.out.println("\nGrouped (sort method):");
        List&lt;List&lt;String&gt;&gt; result = groupAnagramsSort(words);
        for (List&lt;String&gt; group : result) {
            System.out.println("  " + group);
        }
    }
}
</code></pre>

                        <!-- LeetCode -->
                        <h2 id="leetcode"><i class="fas fa-code me-2" style="color: var(--color-teal);"></i>LeetCode Practice Problems</h2>

                        <p>Master these string problems for FAANG interviews:</p>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 344. Reverse String</h4>
                            <p>Reverse a string in-place using O(1) extra memory.</p>

                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 344 - Reverse String
# Time: O(n), Space: O(1)

def reverseString(s):
    """
    Reverse string in-place using two pointers.
    s is a list of characters.
    """
    left, right = 0, len(s) - 1
    
    while left < right:
        s[left], s[right] = s[right], s[left]
        left += 1
        right -= 1

s = list("hello")
reverseString(s)
print("".join(s))  # "olleh"

s = list("Hannah")
reverseString(s)
print("".join(s))  # "hannaH"
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

// LeetCode 344 - Reverse String
// Time: O(n), Space: O(1)
void reverseString(vector&lt;char&gt;& s) {
    int left = 0, right = s.size() - 1;
    
    while (left < right) {
        swap(s[left], s[right]);
        left++;
        right--;
    }
}

int main() {
    vector&lt;char&gt; s = {'h', 'e', 'l', 'l', 'o'};
    reverseString(s);
    for (char c : s) cout << c;  // "olleh"
    cout << endl;
    
    return 0;
}
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 344 - Reverse String
// Time: O(n), Space: O(1)
class Solution {
    public void reverseString(char[] s) {
        int left = 0, right = s.length - 1;
        
        while (left < right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
}

// Test: char[] s = {'h','e','l','l','o'};
// Result: ['o','l','l','e','h']
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 125. Valid Palindrome</h4>
                            <p>Check if string is palindrome considering only alphanumeric characters.</p>

                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 125 - Valid Palindrome
# Time: O(n), Space: O(1)

def isPalindrome(s):
    left, right = 0, len(s) - 1
    
    while left < right:
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True

print(isPalindrome("A man, a plan, a canal: Panama"))  # True
print(isPalindrome("race a car"))  # False
print(isPalindrome(" "))  # True
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;
using namespace std;

// LeetCode 125 - Valid Palindrome
// Time: O(n), Space: O(1)
bool isPalindrome(string s) {
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        while (left < right && !isalnum(s[left])) left++;
        while (left < right && !isalnum(s[right])) right--;
        
        if (tolower(s[left]) != tolower(s[right])) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}

int main() {
    cout << boolalpha;
    cout << isPalindrome("A man, a plan, a canal: Panama") << endl;  // true
    cout << isPalindrome("race a car") << endl;  // false
    return 0;
}
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 125 - Valid Palindrome
// Time: O(n), Space: O(1)
class Solution {
    public boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }
            
            if (Character.toLowerCase(s.charAt(left)) != 
                Character.toLowerCase(s.charAt(right))) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
}

// Test: "A man, a plan, a canal: Panama" → true
// Test: "race a car" → false
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 5. Longest Palindromic Substring</h4>
                            <p>Find the longest palindromic substring in s.</p>

                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 5 - Longest Palindromic Substring
# Time: O(n²), Space: O(1)

def longestPalindrome(s):
    def expand(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]
    
    result = ""
    for i in range(len(s)):
        # Odd length
        odd = expand(i, i)
        if len(odd) > len(result):
            result = odd
        
        # Even length
        even = expand(i, i + 1)
        if len(even) > len(result):
            result = even
    
    return result

print(longestPalindrome("babad"))  # "bab" or "aba"
print(longestPalindrome("cbbd"))   # "bb"
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// LeetCode 5 - Longest Palindromic Substring
// Time: O(n²), Space: O(1)
class Solution {
public:
    string longestPalindrome(string s) {
        int start = 0, maxLen = 1;
        
        for (int i = 0; i < s.length(); i++) {
            // Odd length
            expand(s, i, i, start, maxLen);
            // Even length
            expand(s, i, i + 1, start, maxLen);
        }
        
        return s.substr(start, maxLen);
    }
    
private:
    void expand(const string& s, int left, int right, int& start, int& maxLen) {
        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            if (right - left + 1 > maxLen) {
                start = left;
                maxLen = right - left + 1;
            }
            left--;
            right++;
        }
    }
};

// Test: "babad" → "bab" or "aba"
// Test: "cbbd" → "bb"
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 5 - Longest Palindromic Substring
// Time: O(n²), Space: O(1)
class Solution {
    int start = 0, maxLen = 1;
    
    public String longestPalindrome(String s) {
        for (int i = 0; i < s.length(); i++) {
            // Odd length
            expand(s, i, i);
            // Even length
            expand(s, i, i + 1);
        }
        
        return s.substring(start, start + maxLen);
    }
    
    private void expand(String s, int left, int right) {
        while (left >= 0 && right < s.length() && 
               s.charAt(left) == s.charAt(right)) {
            if (right - left + 1 > maxLen) {
                start = left;
                maxLen = right - left + 1;
            }
            left--;
            right++;
        }
    }
}

// Test: "babad" → "bab" or "aba"
// Test: "cbbd" → "bb"
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 49. Group Anagrams</h4>
                            <p>Group strings that are anagrams of each other.</p>

                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 49 - Group Anagrams
# Time: O(n × k), Space: O(n × k)

from collections import defaultdict

def groupAnagrams(strs):
    groups = defaultdict(list)
    
    for s in strs:
        # Use character count as key
        count = [0] * 26
        for c in s:
            count[ord(c) - ord('a')] += 1
        groups[tuple(count)].append(s)
    
    return list(groups.values())

result = groupAnagrams(["eat","tea","tan","ate","nat","bat"])
print(result)  # [["eat","tea","ate"],["tan","nat"],["bat"]]
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
using namespace std;

// LeetCode 49 - Group Anagrams
// Time: O(n × k), Space: O(n × k)
vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;& strs) {
    unordered_map&lt;string, vector&lt;string&gt;&gt; groups;
    
    for (const string& s : strs) {
        int count[26] = {0};
        for (char c : s) {
            count[c - 'a']++;
        }
        
        // Create key from count
        string key = "";
        for (int i = 0; i < 26; i++) {
            key += "#" + to_string(count[i]);
        }
        
        groups[key].push_back(s);
    }
    
    vector&lt;vector&lt;string&gt;&gt; result;
    for (auto& p : groups) {
        result.push_back(move(p.second));
    }
    
    return result;
}

// Test: ["eat","tea","tan","ate","nat","bat"]
// Result: [["eat","tea","ate"],["tan","nat"],["bat"]]
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">import java.util.*;

// LeetCode 49 - Group Anagrams
// Time: O(n × k), Space: O(n × k)
class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        Map&lt;String, List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();
        
        for (String s : strs) {
            int[] count = new int[26];
            for (char c : s.toCharArray()) {
                count[c - 'a']++;
            }
            
            // Create key from count
            StringBuilder key = new StringBuilder();
            for (int i = 0; i < 26; i++) {
                key.append("#").append(count[i]);
            }
            
            groups.computeIfAbsent(key.toString(), k -> new ArrayList&lt;&gt;()).add(s);
        }
        
        return new ArrayList&lt;&gt;(groups.values());
    }
}

// Test: ["eat","tea","tan","ate","nat","bat"]
// Result: [["eat","tea","ate"],["tan","nat"],["bat"]]
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 3. Longest Substring Without Repeating</h4>
                            <p>Find length of longest substring without repeating characters.</p>

                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 3 - Longest Substring Without Repeating Characters
# Sliding Window approach
# Time: O(n), Space: O(min(n, m)) where m is charset size

def lengthOfLongestSubstring(s):
    char_index = {}  # Character -> last index
    max_length = 0
    start = 0
    
    for end, char in enumerate(s):
        # If char seen and in current window
        if char in char_index and char_index[char] >= start:
            start = char_index[char] + 1
        
        char_index[char] = end
        max_length = max(max_length, end - start + 1)
    
    return max_length

print(lengthOfLongestSubstring("abcabcbb"))  # 3 ("abc")
print(lengthOfLongestSubstring("bbbbb"))     # 1 ("b")
print(lengthOfLongestSubstring("pwwkew"))    # 3 ("wke")
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;
using namespace std;

// LeetCode 3 - Longest Substring Without Repeating Characters
// Sliding Window - Time: O(n), Space: O(min(n, m))
int lengthOfLongestSubstring(string s) {
    unordered_map&lt;char, int&gt; charIndex;  // Character -> last index
    int maxLength = 0;
    int start = 0;
    
    for (int end = 0; end < s.length(); end++) {
        char c = s[end];
        
        // If char seen and in current window
        if (charIndex.count(c) && charIndex[c] >= start) {
            start = charIndex[c] + 1;
        }
        
        charIndex[c] = end;
        maxLength = max(maxLength, end - start + 1);
    }
    
    return maxLength;
}

int main() {
    cout << lengthOfLongestSubstring("abcabcbb") << endl;  // 3
    cout << lengthOfLongestSubstring("bbbbb") << endl;     // 1
    cout << lengthOfLongestSubstring("pwwkew") << endl;    // 3
    return 0;
}
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">import java.util.*;

// LeetCode 3 - Longest Substring Without Repeating Characters
// Sliding Window - Time: O(n), Space: O(min(n, m))
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map&lt;Character, Integer&gt; charIndex = new HashMap&lt;&gt;();
        int maxLength = 0;
        int start = 0;
        
        for (int end = 0; end < s.length(); end++) {
            char c = s.charAt(end);
            
            // If char seen and in current window
            if (charIndex.containsKey(c) && charIndex.get(c) >= start) {
                start = charIndex.get(c) + 1;
            }
            
            charIndex.put(c, end);
            maxLength = Math.max(maxLength, end - start + 1);
        }
        
        return maxLength;
    }
}

// Test: "abcabcbb" → 3 ("abc")
// Test: "bbbbb" → 1 ("b")
// Test: "pwwkew" → 3 ("wke")
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-hard">Hard</span> 76. Minimum Window Substring</h4>
                            <p>Find minimum window in s containing all characters of t.</p>

                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 76 - Minimum Window Substring
# Sliding Window with two pointers
# Time: O(n + m), Space: O(m)

from collections import Counter

def minWindow(s, t):
    if not t or not s:
        return ""
    
    # Count characters needed from t
    need = Counter(t)
    required = len(need)
    
    # Sliding window
    left = 0
    formed = 0
    window_counts = {}
    
    # Result: (window_length, left, right)
    result = float('inf'), None, None
    
    for right in range(len(s)):
        char = s[right]
        window_counts[char] = window_counts.get(char, 0) + 1
        
        # Check if current char satisfies requirement
        if char in need and window_counts[char] == need[char]:
            formed += 1
        
        # Contract window until it's no longer valid
        while left <= right and formed == required:
            char = s[left]
            
            # Update result
            if right - left + 1 < result[0]:
                result = (right - left + 1, left, right)
            
            # Remove left char
            window_counts[char] -= 1
            if char in need and window_counts[char] < need[char]:
                formed -= 1
            
            left += 1
    
    return "" if result[0] == float('inf') else s[result[1]:result[2] + 1]

print(minWindow("ADOBECODEBANC", "ABC"))  # "BANC"
print(minWindow("a", "a"))                # "a"
print(minWindow("a", "aa"))               # ""
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;climits&gt;
using namespace std;

// LeetCode 76 - Minimum Window Substring
// Sliding Window - Time: O(n + m), Space: O(m)
string minWindow(string s, string t) {
    if (s.empty() || t.empty()) return "";
    
    unordered_map&lt;char, int&gt; need, window;
    for (char c : t) need[c]++;
    
    int required = need.size();
    int formed = 0;
    int left = 0;
    
    int minLen = INT_MAX;
    int minLeft = 0;
    
    for (int right = 0; right < s.length(); right++) {
        char c = s[right];
        window[c]++;
        
        if (need.count(c) && window[c] == need[c]) {
            formed++;
        }
        
        // Contract window
        while (left <= right && formed == required) {
            c = s[left];
            
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                minLeft = left;
            }
            
            window[c]--;
            if (need.count(c) && window[c] < need[c]) {
                formed--;
            }
            
            left++;
        }
    }
    
    return minLen == INT_MAX ? "" : s.substr(minLeft, minLen);
}

int main() {
    cout << minWindow("ADOBECODEBANC", "ABC") << endl;  // "BANC"
    cout << minWindow("a", "a") << endl;                // "a"
    cout << minWindow("a", "aa") << endl;               // ""
    return 0;
}
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">import java.util.*;

// LeetCode 76 - Minimum Window Substring
// Sliding Window - Time: O(n + m), Space: O(m)
class Solution {
    public String minWindow(String s, String t) {
        if (s.isEmpty() || t.isEmpty()) return "";
        
        Map&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();
        for (char c : t.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        
        int required = need.size();
        int formed = 0;
        int left = 0;
        
        int minLen = Integer.MAX_VALUE;
        int minLeft = 0;
        
        Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();
        
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            window.put(c, window.getOrDefault(c, 0) + 1);
            
            if (need.containsKey(c) && 
                window.get(c).intValue() == need.get(c).intValue()) {
                formed++;
            }
            
            // Contract window
            while (left <= right && formed == required) {
                c = s.charAt(left);
                
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    minLeft = left;
                }
                
                window.put(c, window.get(c) - 1);
                if (need.containsKey(c) && window.get(c) < need.get(c)) {
                    formed--;
                }
                
                left++;
            }
        }
        
        return minLen == Integer.MAX_VALUE ? "" : 
               s.substring(minLeft, minLeft + minLen);
    }
}

// Test: "ADOBECODEBANC", "ABC" → "BANC"
</code></pre>
                        </div>

                        <!-- Related Posts -->
                        <div class="related-posts">
                            <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 3: Arrays & Array ADT</h5>
                                <p class="text-muted small mb-2">Master arrays, Array ADT operations, searching algorithms, and 2D arrays.</p>
                                <a href="dsa-arrays-adt-operations.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 5: Matrices</h5>
                                <p class="text-muted small mb-2">Special matrices: diagonal, triangular, symmetric, sparse with storage optimization.</p>
                                <a href="dsa-matrices-special-sparse.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 6: Linked Lists</h5>
                                <p class="text-muted small mb-2">Singly, doubly, circular linked lists with all operations and interview problems.</p>
                                <a href="dsa-linked-lists-guide.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest"><i class="fab fa-pinterest-p"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Scroll-to-Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    <!-- Category Indicator -->
    <div id="categoryIndicator" class="category-indicator" title="Current Section">
        <i class="fas fa-tag"></i><span id="categoryText">Technology</span>
    </div>
    
    <!-- Cookie Consent JS -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>

    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    <!-- Side Navigation Script -->
    <script>
        function openNav() {
            document.getElementById('tocSidenav').classList.add('open');
            document.getElementById('tocOverlay').classList.add('show');
            document.body.style.overflow = 'hidden';
        }
        function closeNav() {
            document.getElementById('tocSidenav').classList.remove('open');
            document.getElementById('tocOverlay').classList.remove('show');
            document.body.style.overflow = 'auto';
        }
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeNav();
        });
        document.addEventListener('DOMContentLoaded', function() {
            const sections = document.querySelectorAll('[id]');
            const tocLinks = document.querySelectorAll('.sidenav-toc a');
            function highlightActiveSection() {
                let currentSection = '';
                sections.forEach(section => {
                    const sectionTop = section.offsetTop;
                    if (window.scrollY >= sectionTop - 200) {
                        currentSection = section.getAttribute('id');
                    }
                });
                tocLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === '#' + currentSection) {
                        link.classList.add('active');
                    }
                });
            }
            window.addEventListener('scroll', highlightActiveSection);
            highlightActiveSection();
            tocLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetSection = document.querySelector(targetId);
                    if (targetSection) {
                        const offsetTop = targetSection.offsetTop - 80;
                        window.scrollTo({ top: offsetTop, behavior: 'smooth' });
                    }
                    setTimeout(closeNav, 300);
                });
            });
        });
    </script>

    </body>
</html>
