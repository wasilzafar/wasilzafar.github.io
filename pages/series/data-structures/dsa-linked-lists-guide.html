<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 6 of the Complete DSA Series: Master linked lists including singly, doubly, circular linked lists, operations, reversal techniques, and FAANG interview problems." />
    <meta name="author" content="Wasil Zafar" />
    <meta name="keywords" content="Linked List, Singly Linked List, Doubly Linked List, Circular Linked List, DSA, Data Structures, FAANG Interview, LeetCode" />
    <meta property="og:title" content="Complete DSA Series Part 6: Linked Lists" />
    <meta property="og:description" content="Master singly, doubly, and circular linked lists with operations, reversal techniques, and FAANG interview problems." />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2026-01-28" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />
    
    <title>Complete DSA Series Part 6: Linked Lists - Wasil Zafar</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />

    <!-- Prism.js Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <!-- Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE']
        });
        gtag('consent', 'default', {
            'ad_storage': 'granted',
            'ad_user_data': 'granted',
            'ad_personalization': 'granted',
            'analytics_storage': 'granted'
        });
        gtag('set', 'url_passthrough', true);
    </script>

    <!-- Google Tag Manager -->
    <script>
        (function(w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s),
                dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>

    </head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link">
                    <i class="fas fa-arrow-left me-2"></i>Back to Technology
                </a>
                <h1 class="display-4 fw-bold mb-3">Complete DSA Series Part 6: Linked Lists</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>January 28, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>35 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
                <p class="lead">Master singly, doubly, and circular linked lists with complete implementations, operations, reversal techniques, and classic FAANG interview problems.</p>
            </div>
        </div>
    </section>

    <!-- TOC Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close">&times;</button>
        </div>
        <ol>
            <li>
                <a href="#introduction" onclick="closeNav()">Introduction</a>
                <ul>
                    <li><a href="#introduction" onclick="closeNav()">Why Linked Lists?</a></li>
                    <li><a href="#arrays-vs-linked" onclick="closeNav()">Arrays vs Linked Lists</a></li>
                </ul>
            </li>
            <li>
                <a href="#singly" onclick="closeNav()">Singly Linked List</a>
                <ul>
                    <li><a href="#singly" onclick="closeNav()">Implementation</a></li>
                    <li><a href="#singly-operations" onclick="closeNav()">Operations</a></li>
                </ul>
            </li>
            <li>
                <a href="#doubly" onclick="closeNav()">Doubly Linked List</a>
                <ul>
                    <li><a href="#doubly" onclick="closeNav()">Implementation</a></li>
                    <li><a href="#doubly-operations" onclick="closeNav()">Operations</a></li>
                </ul>
            </li>
            <li>
                <a href="#circular" onclick="closeNav()">Circular Linked List</a>
            </li>
            <li>
                <a href="#techniques" onclick="closeNav()">Key Techniques</a>
                <ul>
                    <li><a href="#reversal" onclick="closeNav()">Reversal</a></li>
                    <li><a href="#two-pointers" onclick="closeNav()">Two Pointers</a></li>
                    <li><a href="#cycle-detection" onclick="closeNav()">Cycle Detection</a></li>
                </ul>
            </li>
            <li>
                <a href="#leetcode" onclick="closeNav()">LeetCode Problems</a>
            </li>
        </ol>
    </div>

    <!-- Overlay -->
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Main Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">
                    <div class="blog-content">

                        <!-- Introduction -->
                        <h2 id="introduction"><i class="fas fa-link me-2" style="color: var(--color-teal);"></i>Introduction to Linked Lists</h2>
                        
                        <p>A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node in the sequence. Unlike arrays, linked lists don't require contiguous memory allocation, making insertions and deletions more efficient.</p>

                        <div class="highlight-box">
                            <i class="fas fa-lightbulb"></i>
                            <strong>Key Insight:</strong> Linked lists excel at dynamic memory allocation and O(1) insertions/deletions at known positions. However, they sacrifice O(1) random access that arrays provide.
                        </div>

                        <div class="experiment-card">
                            <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                            <div class="mb-2">
                                <span class="badge bg-teal me-2">12-Part Series</span>
                                <span class="badge bg-crimson">FAANG Interview Prep</span>
                            </div>
                            <ol>
                                <li><a href="dsa-foundations-memory-complexity.html">Foundations, Memory & Complexity</a></li>
                                <li><a href="dsa-recursion-complete-guide.html">Recursion Complete Guide</a></li>
                                <li><a href="dsa-arrays-adt-operations.html">Arrays & Array ADT</a></li>
                                <li><a href="dsa-strings-manipulation.html">Strings</a></li>
                                <li><a href="dsa-matrices-special-sparse.html">Matrices</a></li>
                                <li><strong>Linked Lists (This Guide)</strong></li>
                                <li><a href="dsa-stack-applications.html">Stack</a></li>
                                <li><a href="dsa-queue-implementations.html">Queue</a></li>
                                <li><a href="dsa-trees-fundamentals.html">Trees</a></li>
                                <li><a href="dsa-bst-avl-redblack.html">BST & Balanced Trees</a></li>
                                <li><a href="dsa-heaps-sorting-hashing.html">Heaps, Sorting & Hashing</a></li>
                                <li><a href="dsa-graphs-dp-greedy-backtracking.html">Graphs, DP, Greedy & Backtracking</a></li>
                            </ol>
                        </div>

                        <!-- Arrays vs Linked Lists -->
                        <h3 id="arrays-vs-linked">Arrays vs Linked Lists</h3>

                        <div class="highlight-box">
                            <h4><i class="fas fa-balance-scale me-2"></i>Comparison Table</h4>
                            <table class="complexity-table">
                                <thead>
                                    <tr>
                                        <th>Operation</th>
                                        <th>Array</th>
                                        <th>Linked List</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Access by Index</td>
                                        <td>O(1)</td>
                                        <td>O(n)</td>
                                    </tr>
                                    <tr>
                                        <td>Insert at Beginning</td>
                                        <td>O(n)</td>
                                        <td>O(1)</td>
                                    </tr>
                                    <tr>
                                        <td>Insert at End</td>
                                        <td>O(1)*</td>
                                        <td>O(n) / O(1)**</td>
                                    </tr>
                                    <tr>
                                        <td>Insert in Middle</td>
                                        <td>O(n)</td>
                                        <td>O(n)***</td>
                                    </tr>
                                    <tr>
                                        <td>Delete at Beginning</td>
                                        <td>O(n)</td>
                                        <td>O(1)</td>
                                    </tr>
                                    <tr>
                                        <td>Search</td>
                                        <td>O(n) / O(log n)****</td>
                                        <td>O(n)</td>
                                    </tr>
                                    <tr>
                                        <td>Memory</td>
                                        <td>Contiguous</td>
                                        <td>Scattered + Overhead</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p class="small text-muted mt-2">* Amortized O(1) for dynamic arrays<br>
                            ** O(1) with tail pointer<br>
                            *** O(1) once position is found<br>
                            **** O(log n) if sorted (binary search)</p>
                        </div>

                        <!-- Singly Linked List -->
                        <h2 id="singly"><i class="fas fa-arrow-right me-2" style="color: var(--color-teal);"></i>Singly Linked List</h2>

                        <p>In a singly linked list, each node contains data and a pointer to the next node. The last node points to null (or None in Python).</p>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Singly Linked List - Node Class
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Singly Linked List Implementation
class SinglyLinkedList:
    def __init__(self):
        self.head = None
        self.size = 0
    
    def is_empty(self):
        return self.head is None
    
    def __len__(self):
        return self.size
    
    # Insert at beginning - O(1)
    def insert_at_head(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        self.size += 1
    
    # Insert at end - O(n)
    def insert_at_tail(self, data):
        new_node = Node(data)
        if self.is_empty():
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        self.size += 1
    
    # Insert at position - O(n)
    def insert_at_position(self, data, position):
        if position < 0 or position > self.size:
            raise IndexError("Position out of bounds")
        
        if position == 0:
            self.insert_at_head(data)
            return
        
        new_node = Node(data)
        current = self.head
        for _ in range(position - 1):
            current = current.next
        
        new_node.next = current.next
        current.next = new_node
        self.size += 1
    
    # Delete from beginning - O(1)
    def delete_from_head(self):
        if self.is_empty():
            raise IndexError("List is empty")
        
        deleted_data = self.head.data
        self.head = self.head.next
        self.size -= 1
        return deleted_data
    
    # Delete from end - O(n)
    def delete_from_tail(self):
        if self.is_empty():
            raise IndexError("List is empty")
        
        if self.head.next is None:
            return self.delete_from_head()
        
        current = self.head
        while current.next.next:
            current = current.next
        
        deleted_data = current.next.data
        current.next = None
        self.size -= 1
        return deleted_data
    
    # Delete by value - O(n)
    def delete_by_value(self, data):
        if self.is_empty():
            return False
        
        if self.head.data == data:
            self.head = self.head.next
            self.size -= 1
            return True
        
        current = self.head
        while current.next:
            if current.next.data == data:
                current.next = current.next.next
                self.size -= 1
                return True
            current = current.next
        
        return False
    
    # Search - O(n)
    def search(self, data):
        current = self.head
        index = 0
        while current:
            if current.data == data:
                return index
            current = current.next
            index += 1
        return -1
    
    # Get element at index - O(n)
    def get(self, index):
        if index < 0 or index >= self.size:
            raise IndexError("Index out of bounds")
        
        current = self.head
        for _ in range(index):
            current = current.next
        return current.data
    
    # Display list
    def display(self):
        elements = []
        current = self.head
        while current:
            elements.append(str(current.data))
            current = current.next
        print(" -> ".join(elements) + " -> None")

# Test Singly Linked List
sll = SinglyLinkedList()
sll.insert_at_tail(1)
sll.insert_at_tail(2)
sll.insert_at_tail(3)
sll.insert_at_head(0)
sll.insert_at_position(1.5, 2)

print("Singly Linked List:")
sll.display()  # 0 -> 1 -> 1.5 -> 2 -> 3 -> None

print(f"Size: {len(sll)}")
print(f"Search 2: index {sll.search(2)}")
print(f"Element at index 3: {sll.get(3)}")

sll.delete_from_head()
sll.delete_by_value(1.5)
sll.display()  # 1 -> 2 -> 3 -> None
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Singly Linked List Implementation in C++

#include &lt;iostream&gt;
using namespace std;

// Node class
class Node {
public:
    int data;
    Node* next;
    
    Node(int val) : data(val), next(nullptr) {}
};

// Singly Linked List class
class SinglyLinkedList {
private:
    Node* head;
    int size;

public:
    SinglyLinkedList() : head(nullptr), size(0) {}
    
    bool isEmpty() { return head == nullptr; }
    int getSize() { return size; }
    
    // Insert at head - O(1)
    void insertAtHead(int data) {
        Node* newNode = new Node(data);
        newNode-&gt;next = head;
        head = newNode;
        size++;
    }
    
    // Insert at tail - O(n)
    void insertAtTail(int data) {
        Node* newNode = new Node(data);
        if (isEmpty()) {
            head = newNode;
        } else {
            Node* current = head;
            while (current-&gt;next) {
                current = current-&gt;next;
            }
            current-&gt;next = newNode;
        }
        size++;
    }
    
    // Insert at position - O(n)
    void insertAtPosition(int data, int position) {
        if (position &lt; 0 || position &gt; size) {
            throw out_of_range("Position out of bounds");
        }
        
        if (position == 0) {
            insertAtHead(data);
            return;
        }
        
        Node* newNode = new Node(data);
        Node* current = head;
        for (int i = 0; i &lt; position - 1; i++) {
            current = current-&gt;next;
        }
        newNode-&gt;next = current-&gt;next;
        current-&gt;next = newNode;
        size++;
    }
    
    // Delete from head - O(1)
    int deleteFromHead() {
        if (isEmpty()) throw runtime_error("List is empty");
        
        int deletedData = head-&gt;data;
        Node* temp = head;
        head = head-&gt;next;
        delete temp;
        size--;
        return deletedData;
    }
    
    // Delete from tail - O(n)
    int deleteFromTail() {
        if (isEmpty()) throw runtime_error("List is empty");
        
        if (head-&gt;next == nullptr) {
            return deleteFromHead();
        }
        
        Node* current = head;
        while (current-&gt;next-&gt;next) {
            current = current-&gt;next;
        }
        
        int deletedData = current-&gt;next-&gt;data;
        delete current-&gt;next;
        current-&gt;next = nullptr;
        size--;
        return deletedData;
    }
    
    // Search - O(n)
    int search(int data) {
        Node* current = head;
        int index = 0;
        while (current) {
            if (current-&gt;data == data) return index;
            current = current-&gt;next;
            index++;
        }
        return -1;
    }
    
    // Display list
    void display() {
        Node* current = head;
        while (current) {
            cout &lt;&lt; current-&gt;data &lt;&lt; " -> ";
            current = current-&gt;next;
        }
        cout &lt;&lt; "None" &lt;&lt; endl;
    }
    
    // Destructor
    ~SinglyLinkedList() {
        while (head) {
            Node* temp = head;
            head = head-&gt;next;
            delete temp;
        }
    }
};

int main() {
    SinglyLinkedList sll;
    sll.insertAtTail(1);
    sll.insertAtTail(2);
    sll.insertAtTail(3);
    sll.insertAtHead(0);
    
    cout &lt;&lt; "Singly Linked List: ";
    sll.display();  // 0 -> 1 -> 2 -> 3 -> None
    
    cout &lt;&lt; "Size: " &lt;&lt; sll.getSize() &lt;&lt; endl;
    cout &lt;&lt; "Search 2: index " &lt;&lt; sll.search(2) &lt;&lt; endl;
    
    sll.deleteFromHead();
    sll.display();  // 1 -> 2 -> 3 -> None
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Singly Linked List Implementation in Java

class Node {
    int data;
    Node next;
    
    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class SinglyLinkedList {
    private Node head;
    private int size;
    
    public SinglyLinkedList() {
        head = null;
        size = 0;
    }
    
    public boolean isEmpty() { return head == null; }
    public int getSize() { return size; }
    
    // Insert at head - O(1)
    public void insertAtHead(int data) {
        Node newNode = new Node(data);
        newNode.next = head;
        head = newNode;
        size++;
    }
    
    // Insert at tail - O(n)
    public void insertAtTail(int data) {
        Node newNode = new Node(data);
        if (isEmpty()) {
            head = newNode;
        } else {
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
        size++;
    }
    
    // Insert at position - O(n)
    public void insertAtPosition(int data, int position) {
        if (position &lt; 0 || position &gt; size) {
            throw new IndexOutOfBoundsException("Position out of bounds");
        }
        
        if (position == 0) {
            insertAtHead(data);
            return;
        }
        
        Node newNode = new Node(data);
        Node current = head;
        for (int i = 0; i &lt; position - 1; i++) {
            current = current.next;
        }
        newNode.next = current.next;
        current.next = newNode;
        size++;
    }
    
    // Delete from head - O(1)
    public int deleteFromHead() {
        if (isEmpty()) throw new RuntimeException("List is empty");
        
        int deletedData = head.data;
        head = head.next;
        size--;
        return deletedData;
    }
    
    // Delete from tail - O(n)
    public int deleteFromTail() {
        if (isEmpty()) throw new RuntimeException("List is empty");
        
        if (head.next == null) {
            return deleteFromHead();
        }
        
        Node current = head;
        while (current.next.next != null) {
            current = current.next;
        }
        
        int deletedData = current.next.data;
        current.next = null;
        size--;
        return deletedData;
    }
    
    // Search - O(n)
    public int search(int data) {
        Node current = head;
        int index = 0;
        while (current != null) {
            if (current.data == data) return index;
            current = current.next;
            index++;
        }
        return -1;
    }
    
    // Display list
    public void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " -> ");
            current = current.next;
        }
        System.out.println("None");
    }
    
    public static void main(String[] args) {
        SinglyLinkedList sll = new SinglyLinkedList();
        sll.insertAtTail(1);
        sll.insertAtTail(2);
        sll.insertAtTail(3);
        sll.insertAtHead(0);
        
        System.out.print("Singly Linked List: ");
        sll.display();  // 0 -> 1 -> 2 -> 3 -> None
        
        System.out.println("Size: " + sll.getSize());
        System.out.println("Search 2: index " + sll.search(2));
        
        sll.deleteFromHead();
        sll.display();  // 1 -> 2 -> 3 -> None
    }
}
</code></pre>

                        <h3 id="singly-operations">Singly Linked List with Tail Pointer</h3>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Optimized Singly Linked List with Tail Pointer
# Insert at tail becomes O(1)

class SinglyLinkedListWithTail:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
    
    def is_empty(self):
        return self.head is None
    
    # Insert at tail - O(1) with tail pointer
    def insert_at_tail(self, data):
        new_node = Node(data)
        if self.is_empty():
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node
        self.size += 1
    
    # Insert at head - O(1)
    def insert_at_head(self, data):
        new_node = Node(data)
        if self.is_empty():
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.head = new_node
        self.size += 1
    
    # Delete from head - O(1)
    def delete_from_head(self):
        if self.is_empty():
            raise IndexError("List is empty")
        
        deleted_data = self.head.data
        self.head = self.head.next
        
        if self.head is None:
            self.tail = None
        
        self.size -= 1
        return deleted_data
    
    # Delete from tail - Still O(n) for singly linked
    def delete_from_tail(self):
        if self.is_empty():
            raise IndexError("List is empty")
        
        if self.head == self.tail:
            deleted_data = self.head.data
            self.head = self.tail = None
            self.size -= 1
            return deleted_data
        
        current = self.head
        while current.next != self.tail:
            current = current.next
        
        deleted_data = self.tail.data
        current.next = None
        self.tail = current
        self.size -= 1
        return deleted_data
    
    def display(self):
        elements = []
        current = self.head
        while current:
            elements.append(str(current.data))
            current = current.next
        print(" -> ".join(elements) + " -> None")

# Test
sll_tail = SinglyLinkedListWithTail()
for i in range(5):
    sll_tail.insert_at_tail(i)

print("With Tail Pointer:")
sll_tail.display()  # 0 -> 1 -> 2 -> 3 -> 4 -> None
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Optimized Singly Linked List with Tail Pointer
// Insert at tail becomes O(1)

#include &lt;iostream&gt;
using namespace std;

class SinglyLinkedListWithTail {
private:
    Node* head;
    Node* tail;
    int size;

public:
    SinglyLinkedListWithTail() : head(nullptr), tail(nullptr), size(0) {}
    
    bool isEmpty() { return head == nullptr; }
    int getSize() { return size; }
    
    // Insert at tail - O(1) with tail pointer
    void insertAtTail(int data) {
        Node* newNode = new Node(data);
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            tail-&gt;next = newNode;
            tail = newNode;
        }
        size++;
    }
    
    // Insert at head - O(1)
    void insertAtHead(int data) {
        Node* newNode = new Node(data);
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            newNode-&gt;next = head;
            head = newNode;
        }
        size++;
    }
    
    // Delete from head - O(1)
    int deleteFromHead() {
        if (isEmpty()) throw runtime_error("List is empty");
        
        int deletedData = head-&gt;data;
        Node* temp = head;
        head = head-&gt;next;
        delete temp;
        
        if (head == nullptr) tail = nullptr;
        
        size--;
        return deletedData;
    }
    
    // Delete from tail - Still O(n) for singly linked
    int deleteFromTail() {
        if (isEmpty()) throw runtime_error("List is empty");
        
        if (head == tail) {
            int deletedData = head-&gt;data;
            delete head;
            head = tail = nullptr;
            size--;
            return deletedData;
        }
        
        Node* current = head;
        while (current-&gt;next != tail) {
            current = current-&gt;next;
        }
        
        int deletedData = tail-&gt;data;
        delete tail;
        current-&gt;next = nullptr;
        tail = current;
        size--;
        return deletedData;
    }
    
    void display() {
        Node* current = head;
        while (current) {
            cout &lt;&lt; current-&gt;data &lt;&lt; " -> ";
            current = current-&gt;next;
        }
        cout &lt;&lt; "None" &lt;&lt; endl;
    }
    
    ~SinglyLinkedListWithTail() {
        while (head) {
            Node* temp = head;
            head = head-&gt;next;
            delete temp;
        }
    }
};

int main() {
    SinglyLinkedListWithTail sll;
    for (int i = 0; i &lt; 5; i++) {
        sll.insertAtTail(i);
    }
    
    cout &lt;&lt; "With Tail Pointer: ";
    sll.display();  // 0 -> 1 -> 2 -> 3 -> 4 -> None
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Optimized Singly Linked List with Tail Pointer
// Insert at tail becomes O(1)

public class SinglyLinkedListWithTail {
    private Node head;
    private Node tail;
    private int size;
    
    public SinglyLinkedListWithTail() {
        head = null;
        tail = null;
        size = 0;
    }
    
    public boolean isEmpty() { return head == null; }
    public int getSize() { return size; }
    
    // Insert at tail - O(1) with tail pointer
    public void insertAtTail(int data) {
        Node newNode = new Node(data);
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            tail = newNode;
        }
        size++;
    }
    
    // Insert at head - O(1)
    public void insertAtHead(int data) {
        Node newNode = new Node(data);
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            newNode.next = head;
            head = newNode;
        }
        size++;
    }
    
    // Delete from head - O(1)
    public int deleteFromHead() {
        if (isEmpty()) throw new RuntimeException("List is empty");
        
        int deletedData = head.data;
        head = head.next;
        
        if (head == null) tail = null;
        
        size--;
        return deletedData;
    }
    
    // Delete from tail - Still O(n) for singly linked
    public int deleteFromTail() {
        if (isEmpty()) throw new RuntimeException("List is empty");
        
        if (head == tail) {
            int deletedData = head.data;
            head = tail = null;
            size--;
            return deletedData;
        }
        
        Node current = head;
        while (current.next != tail) {
            current = current.next;
        }
        
        int deletedData = tail.data;
        current.next = null;
        tail = current;
        size--;
        return deletedData;
    }
    
    public void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " -> ");
            current = current.next;
        }
        System.out.println("None");
    }
    
    public static void main(String[] args) {
        SinglyLinkedListWithTail sll = new SinglyLinkedListWithTail();
        for (int i = 0; i &lt; 5; i++) {
            sll.insertAtTail(i);
        }
        
        System.out.print("With Tail Pointer: ");
        sll.display();  // 0 -> 1 -> 2 -> 3 -> 4 -> None
    }
}
</code></pre>

                        <!-- Doubly Linked List -->
                        <h2 id="doubly"><i class="fas fa-arrows-alt-h me-2" style="color: var(--color-teal);"></i>Doubly Linked List</h2>

                        <p>In a doubly linked list, each node has pointers to both the next and previous nodes, enabling bidirectional traversal and O(1) deletion when you have a reference to the node.</p>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Doubly Linked List - Node Class
class DNode:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Doubly Linked List Implementation
class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
    
    def is_empty(self):
        return self.head is None
    
    def __len__(self):
        return self.size
    
    # Insert at head - O(1)
    def insert_at_head(self, data):
        new_node = DNode(data)
        
        if self.is_empty():
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
        
        self.size += 1
    
    # Insert at tail - O(1)
    def insert_at_tail(self, data):
        new_node = DNode(data)
        
        if self.is_empty():
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
        
        self.size += 1
    
    # Delete node - O(1) if node reference is given
    def delete_node(self, node):
        if node is None:
            return
        
        if node.prev:
            node.prev.next = node.next
        else:
            self.head = node.next
        
        if node.next:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        
        self.size -= 1
    
    # Delete from head - O(1)
    def delete_from_head(self):
        if self.is_empty():
            raise IndexError("List is empty")
        
        deleted_data = self.head.data
        self.delete_node(self.head)
        return deleted_data
    
    # Delete from tail - O(1)
    def delete_from_tail(self):
        if self.is_empty():
            raise IndexError("List is empty")
        
        deleted_data = self.tail.data
        self.delete_node(self.tail)
        return deleted_data
    
    # Display forward
    def display_forward(self):
        elements = []
        current = self.head
        while current:
            elements.append(str(current.data))
            current = current.next
        print("None <-> " + " <-> ".join(elements) + " <-> None")

# Test Doubly Linked List
dll = DoublyLinkedList()
for i in range(5):
    dll.insert_at_tail(i)

print("Doubly Linked List:")
dll.display_forward()   # None <-> 0 <-> 1 <-> 2 <-> 3 <-> 4 <-> None

dll.delete_from_tail()
dll.delete_from_head()
dll.display_forward()   # None <-> 1 <-> 2 <-> 3 <-> None
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Doubly Linked List Implementation in C++

#include &lt;iostream&gt;
using namespace std;

// Doubly Linked Node
class DNode {
public:
    int data;
    DNode* prev;
    DNode* next;
    
    DNode(int val) : data(val), prev(nullptr), next(nullptr) {}
};

// Doubly Linked List
class DoublyLinkedList {
private:
    DNode* head;
    DNode* tail;
    int size;

public:
    DoublyLinkedList() : head(nullptr), tail(nullptr), size(0) {}
    
    bool isEmpty() { return head == nullptr; }
    int getSize() { return size; }
    
    // Insert at head - O(1)
    void insertAtHead(int data) {
        DNode* newNode = new DNode(data);
        
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            newNode-&gt;next = head;
            head-&gt;prev = newNode;
            head = newNode;
        }
        size++;
    }
    
    // Insert at tail - O(1)
    void insertAtTail(int data) {
        DNode* newNode = new DNode(data);
        
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            newNode-&gt;prev = tail;
            tail-&gt;next = newNode;
            tail = newNode;
        }
        size++;
    }
    
    // Delete node - O(1) if node reference is given
    void deleteNode(DNode* node) {
        if (node == nullptr) return;
        
        if (node-&gt;prev) {
            node-&gt;prev-&gt;next = node-&gt;next;
        } else {
            head = node-&gt;next;
        }
        
        if (node-&gt;next) {
            node-&gt;next-&gt;prev = node-&gt;prev;
        } else {
            tail = node-&gt;prev;
        }
        
        delete node;
        size--;
    }
    
    // Delete from head - O(1)
    int deleteFromHead() {
        if (isEmpty()) throw runtime_error("List is empty");
        
        int deletedData = head-&gt;data;
        deleteNode(head);
        return deletedData;
    }
    
    // Delete from tail - O(1)
    int deleteFromTail() {
        if (isEmpty()) throw runtime_error("List is empty");
        
        int deletedData = tail-&gt;data;
        deleteNode(tail);
        return deletedData;
    }
    
    // Display forward
    void displayForward() {
        cout &lt;&lt; "None <-> ";
        DNode* current = head;
        while (current) {
            cout &lt;&lt; current-&gt;data &lt;&lt; " <-> ";
            current = current-&gt;next;
        }
        cout &lt;&lt; "None" &lt;&lt; endl;
    }
    
    // Destructor
    ~DoublyLinkedList() {
        while (head) {
            DNode* temp = head;
            head = head-&gt;next;
            delete temp;
        }
    }
};

int main() {
    DoublyLinkedList dll;
    for (int i = 0; i &lt; 5; i++) {
        dll.insertAtTail(i);
    }
    
    cout &lt;&lt; "Doubly Linked List: ";
    dll.displayForward();  // None <-> 0 <-> 1 <-> 2 <-> 3 <-> 4 <-> None
    
    dll.deleteFromTail();
    dll.deleteFromHead();
    dll.displayForward();  // None <-> 1 <-> 2 <-> 3 <-> None
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Doubly Linked List Implementation in Java

class DNode {
    int data;
    DNode prev;
    DNode next;
    
    DNode(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}

public class DoublyLinkedList {
    private DNode head;
    private DNode tail;
    private int size;
    
    public DoublyLinkedList() {
        head = null;
        tail = null;
        size = 0;
    }
    
    public boolean isEmpty() { return head == null; }
    public int getSize() { return size; }
    
    // Insert at head - O(1)
    public void insertAtHead(int data) {
        DNode newNode = new DNode(data);
        
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
        }
        size++;
    }
    
    // Insert at tail - O(1)
    public void insertAtTail(int data) {
        DNode newNode = new DNode(data);
        
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            newNode.prev = tail;
            tail.next = newNode;
            tail = newNode;
        }
        size++;
    }
    
    // Delete node - O(1) if node reference is given
    private void deleteNode(DNode node) {
        if (node == null) return;
        
        if (node.prev != null) {
            node.prev.next = node.next;
        } else {
            head = node.next;
        }
        
        if (node.next != null) {
            node.next.prev = node.prev;
        } else {
            tail = node.prev;
        }
        
        size--;
    }
    
    // Delete from head - O(1)
    public int deleteFromHead() {
        if (isEmpty()) throw new RuntimeException("List is empty");
        
        int deletedData = head.data;
        deleteNode(head);
        return deletedData;
    }
    
    // Delete from tail - O(1)
    public int deleteFromTail() {
        if (isEmpty()) throw new RuntimeException("List is empty");
        
        int deletedData = tail.data;
        deleteNode(tail);
        return deletedData;
    }
    
    // Display forward
    public void displayForward() {
        System.out.print("None <-> ");
        DNode current = head;
        while (current != null) {
            System.out.print(current.data + " <-> ");
            current = current.next;
        }
        System.out.println("None");
    }
    
    public static void main(String[] args) {
        DoublyLinkedList dll = new DoublyLinkedList();
        for (int i = 0; i &lt; 5; i++) {
            dll.insertAtTail(i);
        }
        
        System.out.print("Doubly Linked List: ");
        dll.displayForward();  // None <-> 0 <-> 1 <-> 2 <-> 3 <-> 4 <-> None
        
        dll.deleteFromTail();
        dll.deleteFromHead();
        dll.displayForward();  // None <-> 1 <-> 2 <-> 3 <-> None
    }
}
</code></pre>

                        <!-- Circular Linked List -->
                        <h2 id="circular"><i class="fas fa-sync me-2" style="color: var(--color-teal);"></i>Circular Linked List</h2>

                        <p>In a circular linked list, the last node points back to the first node, creating a loop. This is useful for applications like round-robin scheduling, circular buffers, and playlists.</p>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Circular Singly Linked List Implementation
class CircularLinkedList:
    def __init__(self):
        self.tail = None  # Point to last node (easier operations)
        self.size = 0
    
    def is_empty(self):
        return self.tail is None
    
    # Insert at head - O(1)
    def insert_at_head(self, data):
        new_node = Node(data)
        
        if self.is_empty():
            new_node.next = new_node  # Point to itself
            self.tail = new_node
        else:
            new_node.next = self.tail.next  # Point to old head
            self.tail.next = new_node       # Tail points to new head
        
        self.size += 1
    
    # Insert at tail - O(1)
    def insert_at_tail(self, data):
        self.insert_at_head(data)
        self.tail = self.tail.next  # Move tail to new node
    
    # Delete from head - O(1)
    def delete_from_head(self):
        if self.is_empty():
            raise IndexError("List is empty")
        
        head = self.tail.next
        deleted_data = head.data
        
        if self.tail == head:  # Only one node
            self.tail = None
        else:
            self.tail.next = head.next
        
        self.size -= 1
        return deleted_data
    
    # Rotate the list (move head to tail)
    def rotate(self):
        if not self.is_empty():
            self.tail = self.tail.next
    
    # Display
    def display(self):
        if self.is_empty():
            print("Empty list")
            return
        
        elements = []
        current = self.tail.next  # Start from head
        while True:
            elements.append(str(current.data))
            current = current.next
            if current == self.tail.next:
                break
        
        print(" -> ".join(elements) + " -> (back to head)")

# Test Circular Linked List
cll = CircularLinkedList()
for i in range(1, 6):
    cll.insert_at_tail(i)

print("Circular Linked List:")
cll.display()  # 1 -> 2 -> 3 -> 4 -> 5 -> (back to head)

cll.rotate()
cll.display()  # 2 -> 3 -> 4 -> 5 -> 1 -> (back to head)
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Circular Singly Linked List Implementation in C++

#include &lt;iostream&gt;
using namespace std;

class CircularLinkedList {
private:
    Node* tail;
    int size;

public:
    CircularLinkedList() : tail(nullptr), size(0) {}
    
    bool isEmpty() { return tail == nullptr; }
    int getSize() { return size; }
    
    // Insert at head - O(1)
    void insertAtHead(int data) {
        Node* newNode = new Node(data);
        
        if (isEmpty()) {
            newNode-&gt;next = newNode;  // Point to itself
            tail = newNode;
        } else {
            newNode-&gt;next = tail-&gt;next;  // Point to old head
            tail-&gt;next = newNode;        // Tail points to new head
        }
        size++;
    }
    
    // Insert at tail - O(1)
    void insertAtTail(int data) {
        insertAtHead(data);
        tail = tail-&gt;next;  // Move tail to new node
    }
    
    // Delete from head - O(1)
    int deleteFromHead() {
        if (isEmpty()) throw runtime_error("List is empty");
        
        Node* head = tail-&gt;next;
        int deletedData = head-&gt;data;
        
        if (tail == head) {  // Only one node
            tail = nullptr;
        } else {
            tail-&gt;next = head-&gt;next;
        }
        
        delete head;
        size--;
        return deletedData;
    }
    
    // Rotate the list
    void rotate() {
        if (!isEmpty()) {
            tail = tail-&gt;next;
        }
    }
    
    // Display
    void display() {
        if (isEmpty()) {
            cout &lt;&lt; "Empty list" &lt;&lt; endl;
            return;
        }
        
        Node* current = tail-&gt;next;  // Start from head
        do {
            cout &lt;&lt; current-&gt;data &lt;&lt; " -> ";
            current = current-&gt;next;
        } while (current != tail-&gt;next);
        cout &lt;&lt; "(back to head)" &lt;&lt; endl;
    }
    
    ~CircularLinkedList() {
        if (isEmpty()) return;
        Node* current = tail-&gt;next;
        while (current != tail) {
            Node* temp = current;
            current = current-&gt;next;
            delete temp;
        }
        delete tail;
    }
};

int main() {
    CircularLinkedList cll;
    for (int i = 1; i &lt;= 5; i++) {
        cll.insertAtTail(i);
    }
    
    cout &lt;&lt; "Circular Linked List: ";
    cll.display();  // 1 -> 2 -> 3 -> 4 -> 5 -> (back to head)
    
    cll.rotate();
    cll.display();  // 2 -> 3 -> 4 -> 5 -> 1 -> (back to head)
    
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Circular Singly Linked List Implementation in Java

public class CircularLinkedList {
    private Node tail;
    private int size;
    
    public CircularLinkedList() {
        tail = null;
        size = 0;
    }
    
    public boolean isEmpty() { return tail == null; }
    public int getSize() { return size; }
    
    // Insert at head - O(1)
    public void insertAtHead(int data) {
        Node newNode = new Node(data);
        
        if (isEmpty()) {
            newNode.next = newNode;  // Point to itself
            tail = newNode;
        } else {
            newNode.next = tail.next;  // Point to old head
            tail.next = newNode;       // Tail points to new head
        }
        size++;
    }
    
    // Insert at tail - O(1)
    public void insertAtTail(int data) {
        insertAtHead(data);
        tail = tail.next;  // Move tail to new node
    }
    
    // Delete from head - O(1)
    public int deleteFromHead() {
        if (isEmpty()) throw new RuntimeException("List is empty");
        
        Node head = tail.next;
        int deletedData = head.data;
        
        if (tail == head) {  // Only one node
            tail = null;
        } else {
            tail.next = head.next;
        }
        
        size--;
        return deletedData;
    }
    
    // Rotate the list
    public void rotate() {
        if (!isEmpty()) {
            tail = tail.next;
        }
    }
    
    // Display
    public void display() {
        if (isEmpty()) {
            System.out.println("Empty list");
            return;
        }
        
        Node current = tail.next;  // Start from head
        do {
            System.out.print(current.data + " -> ");
            current = current.next;
        } while (current != tail.next);
        System.out.println("(back to head)");
    }
    
    public static void main(String[] args) {
        CircularLinkedList cll = new CircularLinkedList();
        for (int i = 1; i &lt;= 5; i++) {
            cll.insertAtTail(i);
        }
        
        System.out.print("Circular Linked List: ");
        cll.display();  // 1 -> 2 -> 3 -> 4 -> 5 -> (back to head)
        
        cll.rotate();
        cll.display();  // 2 -> 3 -> 4 -> 5 -> 1 -> (back to head)
    }
}
</code></pre>

                        <h3>Circular Doubly Linked List</h3>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Circular Doubly Linked List Implementation
class CircularDoublyLinkedList:
    def __init__(self):
        # Use sentinel node for cleaner code
        self.sentinel = DNode(None)
        self.sentinel.next = self.sentinel
        self.sentinel.prev = self.sentinel
        self.size = 0
    
    def is_empty(self):
        return self.sentinel.next == self.sentinel
    
    # Insert after given node - O(1)
    def _insert_after(self, node, data):
        new_node = DNode(data)
        new_node.prev = node
        new_node.next = node.next
        node.next.prev = new_node
        node.next = new_node
        self.size += 1
    
    # Insert at head - O(1)
    def insert_at_head(self, data):
        self._insert_after(self.sentinel, data)
    
    # Insert at tail - O(1)
    def insert_at_tail(self, data):
        self._insert_after(self.sentinel.prev, data)
    
    # Delete node - O(1)
    def _delete_node(self, node):
        if node == self.sentinel:
            return None
        node.prev.next = node.next
        node.next.prev = node.prev
        self.size -= 1
        return node.data
    
    # Delete from head - O(1)
    def delete_from_head(self):
        if self.is_empty():
            raise IndexError("List is empty")
        return self._delete_node(self.sentinel.next)
    
    # Delete from tail - O(1)
    def delete_from_tail(self):
        if self.is_empty():
            raise IndexError("List is empty")
        return self._delete_node(self.sentinel.prev)
    
    # Display
    def display(self):
        elements = []
        current = self.sentinel.next
        while current != self.sentinel:
            elements.append(str(current.data))
            current = current.next
        print(" &lt;-&gt; ".join(elements) + " &lt;-&gt; (circular)")

# Test
cdll = CircularDoublyLinkedList()
for i in range(1, 6):
    cdll.insert_at_tail(i)

cdll.display()  # 1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 5 &lt;-&gt; (circular)
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Circular Doubly Linked List with Sentinel Node

#include &lt;iostream&gt;
using namespace std;

class CircularDoublyLinkedList {
private:
    DNode* sentinel;
    int size;
    
    void insertAfter(DNode* node, int data) {
        DNode* newNode = new DNode(data);
        newNode-&gt;prev = node;
        newNode-&gt;next = node-&gt;next;
        node-&gt;next-&gt;prev = newNode;
        node-&gt;next = newNode;
        size++;
    }
    
    int deleteNode(DNode* node) {
        if (node == sentinel) return -1;
        int data = node-&gt;data;
        node-&gt;prev-&gt;next = node-&gt;next;
        node-&gt;next-&gt;prev = node-&gt;prev;
        delete node;
        size--;
        return data;
    }

public:
    CircularDoublyLinkedList() {
        sentinel = new DNode(0);
        sentinel-&gt;next = sentinel;
        sentinel-&gt;prev = sentinel;
        size = 0;
    }
    
    bool isEmpty() { return sentinel-&gt;next == sentinel; }
    
    // Insert at head - O(1)
    void insertAtHead(int data) {
        insertAfter(sentinel, data);
    }
    
    // Insert at tail - O(1)
    void insertAtTail(int data) {
        insertAfter(sentinel-&gt;prev, data);
    }
    
    // Delete from head - O(1)
    int deleteFromHead() {
        if (isEmpty()) throw runtime_error("List is empty");
        return deleteNode(sentinel-&gt;next);
    }
    
    // Delete from tail - O(1)
    int deleteFromTail() {
        if (isEmpty()) throw runtime_error("List is empty");
        return deleteNode(sentinel-&gt;prev);
    }
    
    void display() {
        DNode* current = sentinel-&gt;next;
        while (current != sentinel) {
            cout &lt;&lt; current-&gt;data &lt;&lt; " &lt;-&gt; ";
            current = current-&gt;next;
        }
        cout &lt;&lt; "(circular)" &lt;&lt; endl;
    }
    
    ~CircularDoublyLinkedList() {
        while (!isEmpty()) deleteFromHead();
        delete sentinel;
    }
};

int main() {
    CircularDoublyLinkedList cdll;
    for (int i = 1; i &lt;= 5; i++) cdll.insertAtTail(i);
    cdll.display();  // 1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 5 &lt;-&gt; (circular)
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Circular Doubly Linked List with Sentinel Node

public class CircularDoublyLinkedList {
    private DNode sentinel;
    private int size;
    
    public CircularDoublyLinkedList() {
        sentinel = new DNode(0);
        sentinel.next = sentinel;
        sentinel.prev = sentinel;
        size = 0;
    }
    
    public boolean isEmpty() { return sentinel.next == sentinel; }
    
    private void insertAfter(DNode node, int data) {
        DNode newNode = new DNode(data);
        newNode.prev = node;
        newNode.next = node.next;
        node.next.prev = newNode;
        node.next = newNode;
        size++;
    }
    
    private int deleteNode(DNode node) {
        if (node == sentinel) return -1;
        int data = node.data;
        node.prev.next = node.next;
        node.next.prev = node.prev;
        size--;
        return data;
    }
    
    // Insert at head - O(1)
    public void insertAtHead(int data) {
        insertAfter(sentinel, data);
    }
    
    // Insert at tail - O(1)
    public void insertAtTail(int data) {
        insertAfter(sentinel.prev, data);
    }
    
    // Delete from head - O(1)
    public int deleteFromHead() {
        if (isEmpty()) throw new RuntimeException("List is empty");
        return deleteNode(sentinel.next);
    }
    
    // Delete from tail - O(1)
    public int deleteFromTail() {
        if (isEmpty()) throw new RuntimeException("List is empty");
        return deleteNode(sentinel.prev);
    }
    
    public void display() {
        DNode current = sentinel.next;
        while (current != sentinel) {
            System.out.print(current.data + " &lt;-&gt; ");
            current = current.next;
        }
        System.out.println("(circular)");
    }
    
    public static void main(String[] args) {
        CircularDoublyLinkedList cdll = new CircularDoublyLinkedList();
        for (int i = 1; i &lt;= 5; i++) cdll.insertAtTail(i);
        cdll.display();  // 1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 5 &lt;-&gt; (circular)
    }
}
</code></pre>

                        <!-- Key Techniques -->
                        <h2 id="techniques"><i class="fas fa-tools me-2" style="color: var(--color-teal);"></i>Key Techniques</h2>

                        <h3 id="reversal">List Reversal</h3>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Reverse Linked List - Three Approaches
# All approaches: Time O(n), Space varies

# 1. Iterative Reversal - Space O(1)
def reverse_iterative(head):
    """Reverse using three pointers"""
    prev = None
    current = head
    
    while current:
        next_node = current.next  # Save next
        current.next = prev       # Reverse link
        prev = current            # Move prev forward
        current = next_node       # Move current forward
    
    return prev  # New head

# 2. Recursive Reversal - Space O(n) call stack
def reverse_recursive(head):
    """Reverse recursively"""
    if not head or not head.next:
        return head
    
    new_head = reverse_recursive(head.next)
    head.next.next = head
    head.next = None
    return new_head

# 3. Reverse using Stack - Space O(n)
def reverse_with_stack(head):
    """Reverse using a stack"""
    if not head:
        return None
    
    stack = []
    current = head
    while current:
        stack.append(current)
        current = current.next
    
    new_head = stack.pop()
    current = new_head
    while stack:
        current.next = stack.pop()
        current = current.next
    current.next = None
    return new_head

# Test
original = create_list([1, 2, 3, 4, 5])
display_list(original)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; None
reversed_list = reverse_iterative(original)
display_list(reversed_list)  # 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; None
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Reverse Linked List - Three Approaches

#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;

// 1. Iterative Reversal - O(n) time, O(1) space
ListNode* reverseIterative(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* current = head;
    
    while (current) {
        ListNode* nextNode = current-&gt;next;  // Save next
        current-&gt;next = prev;                // Reverse link
        prev = current;                      // Move prev forward
        current = nextNode;                  // Move current forward
    }
    return prev;  // New head
}

// 2. Recursive Reversal - O(n) time, O(n) space (call stack)
ListNode* reverseRecursive(ListNode* head) {
    if (!head || !head-&gt;next) return head;
    
    ListNode* newHead = reverseRecursive(head-&gt;next);
    head-&gt;next-&gt;next = head;
    head-&gt;next = nullptr;
    return newHead;
}

// 3. Reverse using Stack - O(n) time, O(n) space
ListNode* reverseWithStack(ListNode* head) {
    if (!head) return nullptr;
    
    stack&lt;ListNode*&gt; stk;
    ListNode* current = head;
    while (current) {
        stk.push(current);
        current = current-&gt;next;
    }
    
    ListNode* newHead = stk.top();
    stk.pop();
    current = newHead;
    
    while (!stk.empty()) {
        current-&gt;next = stk.top();
        stk.pop();
        current = current-&gt;next;
    }
    current-&gt;next = nullptr;
    return newHead;
}

int main() {
    // Create: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
    ListNode* head = new ListNode(1);
    head-&gt;next = new ListNode(2);
    head-&gt;next-&gt;next = new ListNode(3);
    head-&gt;next-&gt;next-&gt;next = new ListNode(4);
    head-&gt;next-&gt;next-&gt;next-&gt;next = new ListNode(5);
    
    head = reverseIterative(head);
    // Output: 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; null
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Reverse Linked List - Three Approaches

import java.util.Stack;

public class ListReversal {
    
    // 1. Iterative Reversal - O(n) time, O(1) space
    public static ListNode reverseIterative(ListNode head) {
        ListNode prev = null;
        ListNode current = head;
        
        while (current != null) {
            ListNode nextNode = current.next;  // Save next
            current.next = prev;               // Reverse link
            prev = current;                    // Move prev forward
            current = nextNode;                // Move current forward
        }
        return prev;  // New head
    }
    
    // 2. Recursive Reversal - O(n) time, O(n) space (call stack)
    public static ListNode reverseRecursive(ListNode head) {
        if (head == null || head.next == null) return head;
        
        ListNode newHead = reverseRecursive(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
    
    // 3. Reverse using Stack - O(n) time, O(n) space
    public static ListNode reverseWithStack(ListNode head) {
        if (head == null) return null;
        
        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();
        ListNode current = head;
        while (current != null) {
            stack.push(current);
            current = current.next;
        }
        
        ListNode newHead = stack.pop();
        current = newHead;
        
        while (!stack.isEmpty()) {
            current.next = stack.pop();
            current = current.next;
        }
        current.next = null;
        return newHead;
    }
    
    public static void main(String[] args) {
        // Create: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        
        head = reverseIterative(head);
        // Output: 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; null
    }
}
</code></pre>

                        <h3 id="two-pointers">Two Pointer Techniques</h3>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Two Pointer Techniques for Linked Lists

# 1. Find Middle Element - Floyd's Tortoise &amp; Hare
def find_middle(head):
    """Find middle node using slow &amp; fast pointers"""
    if not head:
        return None
    
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow  # Middle node

# 2. Find Nth Node from End
def find_nth_from_end(head, n):
    """Find nth node from end using two pointers"""
    first = second = head
    
    # Move first pointer n steps ahead
    for _ in range(n):
        if not first:
            return None  # n &gt; length
        first = first.next
    
    # Move both until first reaches end
    while first:
        first = first.next
        second = second.next
    return second

# 3. Check if Palindrome
def is_palindrome(head):
    """Check if linked list is palindrome"""
    if not head or not head.next:
        return True
    
    # Find middle
    slow = fast = head
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
    
    # Reverse second half
    second_half = reverse_iterative(slow.next)
    
    # Compare both halves
    first_half = head
    result = True
    while second_half:
        if first_half.data != second_half.data:
            result = False
            break
        first_half = first_half.next
        second_half = second_half.next
    return result

# Test
print(f"Middle of [1,2,3,4,5]: {find_middle(create_list([1,2,3,4,5])).data}")  # 3
print(f"2nd from end: {find_nth_from_end(create_list([1,2,3,4,5]), 2).data}")  # 4
print(f"Is [1,2,3,2,1] palindrome: {is_palindrome(create_list([1,2,3,2,1]))}")  # True
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Two Pointer Techniques for Linked Lists

#include &lt;iostream&gt;
using namespace std;

// 1. Find Middle Element - Floyd's Tortoise &amp; Hare
ListNode* findMiddle(ListNode* head) {
    if (!head) return nullptr;
    
    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
    return slow;  // Middle node
}

// 2. Find Nth Node from End
ListNode* findNthFromEnd(ListNode* head, int n) {
    ListNode* first = head;
    ListNode* second = head;
    
    // Move first pointer n steps ahead
    for (int i = 0; i &lt; n; i++) {
        if (!first) return nullptr;  // n &gt; length
        first = first-&gt;next;
    }
    
    // Move both until first reaches end
    while (first) {
        first = first-&gt;next;
        second = second-&gt;next;
    }
    return second;
}

// Helper to reverse list (for palindrome check)
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    while (head) {
        ListNode* next = head-&gt;next;
        head-&gt;next = prev;
        prev = head;
        head = next;
    }
    return prev;
}

// 3. Check if Palindrome
bool isPalindrome(ListNode* head) {
    if (!head || !head-&gt;next) return true;
    
    // Find middle
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
    
    // Reverse second half
    ListNode* secondHalf = reverseList(slow-&gt;next);
    
    // Compare both halves
    ListNode* firstHalf = head;
    while (secondHalf) {
        if (firstHalf-&gt;val != secondHalf-&gt;val)
            return false;
        firstHalf = firstHalf-&gt;next;
        secondHalf = secondHalf-&gt;next;
    }
    return true;
}

int main() {
    // Test with 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
    ListNode* head = new ListNode(1);
    head-&gt;next = new ListNode(2);
    head-&gt;next-&gt;next = new ListNode(3);
    head-&gt;next-&gt;next-&gt;next = new ListNode(4);
    head-&gt;next-&gt;next-&gt;next-&gt;next = new ListNode(5);
    
    cout &lt;&lt; "Middle: " &lt;&lt; findMiddle(head)-&gt;val &lt;&lt; endl;  // 3
    cout &lt;&lt; "2nd from end: " &lt;&lt; findNthFromEnd(head, 2)-&gt;val &lt;&lt; endl;  // 4
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Two Pointer Techniques for Linked Lists

public class TwoPointerTechniques {
    
    // 1. Find Middle Element - Floyd's Tortoise &amp; Hare
    public static ListNode findMiddle(ListNode head) {
        if (head == null) return null;
        
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;  // Middle node
    }
    
    // 2. Find Nth Node from End
    public static ListNode findNthFromEnd(ListNode head, int n) {
        ListNode first = head;
        ListNode second = head;
        
        // Move first pointer n steps ahead
        for (int i = 0; i &lt; n; i++) {
            if (first == null) return null;  // n &gt; length
            first = first.next;
        }
        
        // Move both until first reaches end
        while (first != null) {
            first = first.next;
            second = second.next;
        }
        return second;
    }
    
    // Helper to reverse list
    private static ListNode reverseList(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;
    }
    
    // 3. Check if Palindrome
    public static boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) return true;
        
        // Find middle
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null &amp;&amp; fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        // Reverse second half
        ListNode secondHalf = reverseList(slow.next);
        
        // Compare both halves
        ListNode firstHalf = head;
        while (secondHalf != null) {
            if (firstHalf.val != secondHalf.val)
                return false;
            firstHalf = firstHalf.next;
            secondHalf = secondHalf.next;
        }
        return true;
    }
    
    public static void main(String[] args) {
        // Test with 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        
        System.out.println("Middle: " + findMiddle(head).val);  // 3
        System.out.println("2nd from end: " + findNthFromEnd(head, 2).val);  // 4
    }
}
</code></pre>

                        <h3 id="cycle-detection">Cycle Detection</h3>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Cycle Detection - Floyd's Algorithm

def has_cycle(head):
    """Detect if linked list has a cycle - O(n) time, O(1) space"""
    if not head or not head.next:
        return False
    
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False

def find_cycle_start(head):
    """Find the starting node of the cycle"""
    if not head or not head.next:
        return None
    
    slow = fast = head
    
    # Phase 1: Detect cycle
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    else:
        return None  # No cycle
    
    # Phase 2: Find cycle start
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    return slow  # Cycle start

def get_cycle_length(head):
    """Get the length of the cycle"""
    if not head or not head.next:
        return 0
    
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            # Count cycle length
            length = 1
            current = slow.next
            while current != slow:
                length += 1
                current = current.next
            return length
    return 0  # No cycle

# Test: Create list with cycle: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 3
nodes = [Node(i) for i in range(1, 6)]
for i in range(4):
    nodes[i].next = nodes[i + 1]
nodes[4].next = nodes[2]  # 5 -&gt; 3 (cycle)

print(f"Has cycle: {has_cycle(nodes[0])}")           # True
print(f"Cycle starts at: {find_cycle_start(nodes[0]).data}")  # 3
print(f"Cycle length: {get_cycle_length(nodes[0])}")  # 3
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Cycle Detection - Floyd's Algorithm

#include &lt;iostream&gt;
using namespace std;

// Detect if linked list has a cycle - O(n) time, O(1) space
bool hasCycle(ListNode* head) {
    if (!head || !head-&gt;next) return false;
    
    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        if (slow == fast) return true;
    }
    return false;
}

// Find the starting node of the cycle
ListNode* findCycleStart(ListNode* head) {
    if (!head || !head-&gt;next) return nullptr;
    
    ListNode* slow = head;
    ListNode* fast = head;
    
    // Phase 1: Detect cycle
    while (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        if (slow == fast) break;
    }
    
    if (!fast || !fast-&gt;next) return nullptr;  // No cycle
    
    // Phase 2: Find cycle start
    slow = head;
    while (slow != fast) {
        slow = slow-&gt;next;
        fast = fast-&gt;next;
    }
    return slow;  // Cycle start
}

// Get the length of the cycle
int getCycleLength(ListNode* head) {
    if (!head || !head-&gt;next) return 0;
    
    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        
        if (slow == fast) {
            // Count cycle length
            int length = 1;
            ListNode* current = slow-&gt;next;
            while (current != slow) {
                length++;
                current = current-&gt;next;
            }
            return length;
        }
    }
    return 0;  // No cycle
}

int main() {
    // Create list with cycle: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 3
    ListNode* nodes[5];
    for (int i = 0; i &lt; 5; i++) {
        nodes[i] = new ListNode(i + 1);
    }
    for (int i = 0; i &lt; 4; i++) {
        nodes[i]-&gt;next = nodes[i + 1];
    }
    nodes[4]-&gt;next = nodes[2];  // 5 -&gt; 3 (cycle)
    
    cout &lt;&lt; "Has cycle: " &lt;&lt; (hasCycle(nodes[0]) ? "true" : "false") &lt;&lt; endl;
    cout &lt;&lt; "Cycle starts at: " &lt;&lt; findCycleStart(nodes[0])-&gt;val &lt;&lt; endl;
    cout &lt;&lt; "Cycle length: " &lt;&lt; getCycleLength(nodes[0]) &lt;&lt; endl;
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Cycle Detection - Floyd's Algorithm

public class CycleDetection {
    
    // Detect if linked list has a cycle - O(n) time, O(1) space
    public static boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;
        
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) return true;
        }
        return false;
    }
    
    // Find the starting node of the cycle
    public static ListNode findCycleStart(ListNode head) {
        if (head == null || head.next == null) return null;
        
        ListNode slow = head;
        ListNode fast = head;
        
        // Phase 1: Detect cycle
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) break;
        }
        
        if (fast == null || fast.next == null) return null;  // No cycle
        
        // Phase 2: Find cycle start
        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;  // Cycle start
    }
    
    // Get the length of the cycle
    public static int getCycleLength(ListNode head) {
        if (head == null || head.next == null) return 0;
        
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            
            if (slow == fast) {
                // Count cycle length
                int length = 1;
                ListNode current = slow.next;
                while (current != slow) {
                    length++;
                    current = current.next;
                }
                return length;
            }
        }
        return 0;  // No cycle
    }
    
    public static void main(String[] args) {
        // Create list with cycle: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 3
        ListNode[] nodes = new ListNode[5];
        for (int i = 0; i &lt; 5; i++) {
            nodes[i] = new ListNode(i + 1);
        }
        for (int i = 0; i &lt; 4; i++) {
            nodes[i].next = nodes[i + 1];
        }
        nodes[4].next = nodes[2];  // 5 -&gt; 3 (cycle)
        
        System.out.println("Has cycle: " + hasCycle(nodes[0]));
        System.out.println("Cycle starts at: " + findCycleStart(nodes[0]).val);
        System.out.println("Cycle length: " + getCycleLength(nodes[0]));
    }
}
</code></pre>

                        <!-- LeetCode -->
                        <h2 id="leetcode"><i class="fas fa-code me-2" style="color: var(--color-teal);"></i>LeetCode Practice Problems</h2>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 206. Reverse Linked List</h4>
                            <p>Reverse a singly linked list.</p>
                            
                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 206 - Reverse Linked List
# Time: O(n), Space: O(1)

def reverseList(head):
    prev = None
    current = head
    
    while current:
        next_temp = current.next
        current.next = prev
        prev = current
        current = next_temp
    
    return prev

# Recursive approach
def reverseListRecursive(head):
    if not head or not head.next:
        return head
    
    new_head = reverseListRecursive(head.next)
    head.next.next = head
    head.next = None
    
    return new_head
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 206 - Reverse Linked List
// Time: O(n), Space: O(1)

class Solution {
public:
    // Iterative approach
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* current = head;
        
        while (current) {
            ListNode* nextTemp = current-&gt;next;
            current-&gt;next = prev;
            prev = current;
            current = nextTemp;
        }
        
        return prev;
    }
    
    // Recursive approach
    ListNode* reverseListRecursive(ListNode* head) {
        if (!head || !head-&gt;next) {
            return head;
        }
        
        ListNode* newHead = reverseListRecursive(head-&gt;next);
        head-&gt;next-&gt;next = head;
        head-&gt;next = nullptr;
        
        return newHead;
    }
};
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 206 - Reverse Linked List
// Time: O(n), Space: O(1)

class Solution {
    // Iterative approach
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;
        
        while (current != null) {
            ListNode nextTemp = current.next;
            current.next = prev;
            prev = current;
            current = nextTemp;
        }
        
        return prev;
    }
    
    // Recursive approach
    public ListNode reverseListRecursive(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        
        ListNode newHead = reverseListRecursive(head.next);
        head.next.next = head;
        head.next = null;
        
        return newHead;
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 21. Merge Two Sorted Lists</h4>
                            <p>Merge two sorted linked lists into one sorted list.</p>
                            
                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 21 - Merge Two Sorted Lists
# Time: O(n + m), Space: O(1)

def mergeTwoLists(list1, list2):
    # Create dummy head
    dummy = Node(0)
    current = dummy
    
    while list1 and list2:
        if list1.data &lt;= list2.data:
            current.next = list1
            list1 = list1.next
        else:
            current.next = list2
            list2 = list2.next
        current = current.next
    
    # Attach remaining nodes
    current.next = list1 if list1 else list2
    
    return dummy.next
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 21 - Merge Two Sorted Lists
// Time: O(n + m), Space: O(1)

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy(0);
        ListNode* current = &amp;dummy;
        
        while (list1 &amp;&amp; list2) {
            if (list1-&gt;val &lt;= list2-&gt;val) {
                current-&gt;next = list1;
                list1 = list1-&gt;next;
            } else {
                current-&gt;next = list2;
                list2 = list2-&gt;next;
            }
            current = current-&gt;next;
        }
        
        // Attach remaining nodes
        current-&gt;next = list1 ? list1 : list2;
        
        return dummy.next;
    }
};
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 21 - Merge Two Sorted Lists
// Time: O(n + m), Space: O(1)

class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (list1 != null &amp;&amp; list2 != null) {
            if (list1.val &lt;= list2.val) {
                current.next = list1;
                list1 = list1.next;
            } else {
                current.next = list2;
                list2 = list2.next;
            }
            current = current.next;
        }
        
        // Attach remaining nodes
        current.next = (list1 != null) ? list1 : list2;
        
        return dummy.next;
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 141. Linked List Cycle</h4>
                            <p>Determine if a linked list has a cycle.</p>
                            
                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 141 - Linked List Cycle
# Time: O(n), Space: O(1)

def hasCycle(head):
    if not head or not head.next:
        return False
    
    slow = head
    fast = head.next
    
    while slow != fast:
        if not fast or not fast.next:
            return False
        slow = slow.next
        fast = fast.next.next
    
    return True
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 141 - Linked List Cycle
// Time: O(n), Space: O(1)

class Solution {
public:
    bool hasCycle(ListNode* head) {
        if (!head || !head-&gt;next) return false;
        
        ListNode* slow = head;
        ListNode* fast = head-&gt;next;
        
        while (slow != fast) {
            if (!fast || !fast-&gt;next) return false;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        
        return true;
    }
};
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 141 - Linked List Cycle
// Time: O(n), Space: O(1)

class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;
        
        ListNode slow = head;
        ListNode fast = head.next;
        
        while (slow != fast) {
            if (fast == null || fast.next == null) return false;
            slow = slow.next;
            fast = fast.next.next;
        }
        
        return true;
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 19. Remove Nth Node From End</h4>
                            <p>Remove the nth node from the end in one pass.</p>
                            
                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 19 - Remove Nth Node From End
# Time: O(n), Space: O(1)

def removeNthFromEnd(head, n):
    dummy = Node(0)
    dummy.next = head
    
    first = dummy
    second = dummy
    
    # Move first n+1 steps ahead
    for _ in range(n + 1):
        first = first.next
    
    # Move both until first reaches end
    while first:
        first = first.next
        second = second.next
    
    # Remove nth node
    second.next = second.next.next
    
    return dummy.next
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 19 - Remove Nth Node From End
// Time: O(n), Space: O(1)

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode dummy(0);
        dummy.next = head;
        
        ListNode* first = &amp;dummy;
        ListNode* second = &amp;dummy;
        
        // Move first n+1 steps ahead
        for (int i = 0; i &lt;= n; i++) {
            first = first-&gt;next;
        }
        
        // Move both until first reaches end
        while (first) {
            first = first-&gt;next;
            second = second-&gt;next;
        }
        
        // Remove nth node
        ListNode* toDelete = second-&gt;next;
        second-&gt;next = second-&gt;next-&gt;next;
        delete toDelete;
        
        return dummy.next;
    }
};
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 19 - Remove Nth Node From End
// Time: O(n), Space: O(1)

class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        ListNode first = dummy;
        ListNode second = dummy;
        
        // Move first n+1 steps ahead
        for (int i = 0; i &lt;= n; i++) {
            first = first.next;
        }
        
        // Move both until first reaches end
        while (first != null) {
            first = first.next;
            second = second.next;
        }
        
        // Remove nth node
        second.next = second.next.next;
        
        return dummy.next;
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 142. Linked List Cycle II</h4>
                            <p>Find the node where the cycle begins.</p>
                            
                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 142 - Linked List Cycle II
# Time: O(n), Space: O(1)

def detectCycle(head):
    if not head or not head.next:
        return None
    
    slow = fast = head
    
    # Phase 1: Detect cycle
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            # Phase 2: Find cycle start
            slow = head
            while slow != fast:
                slow = slow.next
                fast = fast.next
            return slow
    
    return None
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 142 - Linked List Cycle II
// Time: O(n), Space: O(1)

class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        if (!head || !head-&gt;next) return nullptr;
        
        ListNode* slow = head;
        ListNode* fast = head;
        
        // Phase 1: Detect cycle
        while (fast &amp;&amp; fast-&gt;next) {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
            
            if (slow == fast) {
                // Phase 2: Find cycle start
                slow = head;
                while (slow != fast) {
                    slow = slow-&gt;next;
                    fast = fast-&gt;next;
                }
                return slow;
            }
        }
        
        return nullptr;
    }
};
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 142 - Linked List Cycle II
// Time: O(n), Space: O(1)

class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) return null;
        
        ListNode slow = head;
        ListNode fast = head;
        
        // Phase 1: Detect cycle
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            
            if (slow == fast) {
                // Phase 2: Find cycle start
                slow = head;
                while (slow != fast) {
                    slow = slow.next;
                    fast = fast.next;
                }
                return slow;
            }
        }
        
        return null;
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 148. Sort List</h4>
                            <p>Sort a linked list in O(n log n) time using constant space.</p>
                            
                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 148 - Sort List (Merge Sort)
# Time: O(n log n), Space: O(log n) for recursion

def sortList(head):
    if not head or not head.next:
        return head
    
    # Find middle
    slow = head
    fast = head.next
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    # Split list
    mid = slow.next
    slow.next = None
    
    # Recursively sort both halves
    left = sortList(head)
    right = sortList(mid)
    
    # Merge sorted halves
    return mergeTwoLists(left, right)
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 148 - Sort List (Merge Sort)
// Time: O(n log n), Space: O(log n) for recursion

class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (!head || !head-&gt;next) return head;
        
        // Find middle
        ListNode* slow = head;
        ListNode* fast = head-&gt;next;
        while (fast &amp;&amp; fast-&gt;next) {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        
        // Split list
        ListNode* mid = slow-&gt;next;
        slow-&gt;next = nullptr;
        
        // Recursively sort both halves
        ListNode* left = sortList(head);
        ListNode* right = sortList(mid);
        
        // Merge sorted halves
        return merge(left, right);
    }
    
private:
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);
        ListNode* tail = &amp;dummy;
        
        while (l1 &amp;&amp; l2) {
            if (l1-&gt;val &lt; l2-&gt;val) {
                tail-&gt;next = l1;
                l1 = l1-&gt;next;
            } else {
                tail-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            tail = tail-&gt;next;
        }
        
        tail-&gt;next = l1 ? l1 : l2;
        return dummy.next;
    }
};
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 148 - Sort List (Merge Sort)
// Time: O(n log n), Space: O(log n) for recursion

class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) return head;
        
        // Find middle
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        // Split list
        ListNode mid = slow.next;
        slow.next = null;
        
        // Recursively sort both halves
        ListNode left = sortList(head);
        ListNode right = sortList(mid);
        
        // Merge sorted halves
        return merge(left, right);
    }
    
    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        
        while (l1 != null &amp;&amp; l2 != null) {
            if (l1.val &lt; l2.val) {
                tail.next = l1;
                l1 = l1.next;
            } else {
                tail.next = l2;
                l2 = l2.next;
            }
            tail = tail.next;
        }
        
        tail.next = (l1 != null) ? l1 : l2;
        return dummy.next;
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-hard">Hard</span> 25. Reverse Nodes in k-Group</h4>
                            <p>Reverse nodes in groups of k. If remaining &lt; k, leave as-is.</p>
                            
                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 25 - Reverse Nodes in k-Group
# Time: O(n), Space: O(1)

def reverseKGroup(head, k):
    # Count total nodes
    count = 0
    current = head
    while current:
        count += 1
        current = current.next
    
    dummy = Node(0)
    dummy.next = head
    group_prev = dummy
    
    while count &gt;= k:
        # Reverse k nodes
        prev = None
        current = group_prev.next
        
        for _ in range(k):
            next_temp = current.next
            current.next = prev
            prev = current
            current = next_temp
        
        # Connect with previous group
        tail = group_prev.next  # Tail of reversed group
        tail.next = current     # Connect to remaining
        group_prev.next = prev  # Connect prev group to new head
        group_prev = tail       # Move to next group
        
        count -= k
    
    return dummy.next
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 25 - Reverse Nodes in k-Group
// Time: O(n), Space: O(1)

class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // Count total nodes
        int count = 0;
        ListNode* current = head;
        while (current) {
            count++;
            current = current-&gt;next;
        }
        
        ListNode dummy(0);
        dummy.next = head;
        ListNode* groupPrev = &amp;dummy;
        
        while (count &gt;= k) {
            // Reverse k nodes
            ListNode* prev = nullptr;
            current = groupPrev-&gt;next;
            
            for (int i = 0; i &lt; k; i++) {
                ListNode* nextTemp = current-&gt;next;
                current-&gt;next = prev;
                prev = current;
                current = nextTemp;
            }
            
            // Connect with previous group
            ListNode* tail = groupPrev-&gt;next;
            tail-&gt;next = current;
            groupPrev-&gt;next = prev;
            groupPrev = tail;
            
            count -= k;
        }
        
        return dummy.next;
    }
};
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 25 - Reverse Nodes in k-Group
// Time: O(n), Space: O(1)

class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // Count total nodes
        int count = 0;
        ListNode current = head;
        while (current != null) {
            count++;
            current = current.next;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode groupPrev = dummy;
        
        while (count &gt;= k) {
            // Reverse k nodes
            ListNode prev = null;
            current = groupPrev.next;
            
            for (int i = 0; i &lt; k; i++) {
                ListNode nextTemp = current.next;
                current.next = prev;
                prev = current;
                current = nextTemp;
            }
            
            // Connect with previous group
            ListNode tail = groupPrev.next;
            tail.next = current;
            groupPrev.next = prev;
            groupPrev = tail;
            
            count -= k;
        }
        
        return dummy.next;
    }
}
</code></pre>
                        </div>

                        <!-- Related Posts -->
                        <div class="related-posts">
                            <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 5: Matrices</h5>
                                <p class="text-muted small mb-2">Diagonal, triangular, symmetric matrices, sparse representations (COO, CSR, CSC).</p>
                                <a href="dsa-matrices-special-sparse.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 7: Stack</h5>
                                <p class="text-muted small mb-2">Stack implementations, applications, expression evaluation, monotonic stack.</p>
                                <a href="dsa-stack-applications.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 8: Queue</h5>
                                <p class="text-muted small mb-2">Queue implementations, circular queue, deque, priority queue applications.</p>
                                <a href="dsa-queue-implementations.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest"><i class="fab fa-pinterest-p"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Scroll-to-Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    <!-- Category Indicator -->
    <div id="categoryIndicator" class="category-indicator" title="Current Section">
        <i class="fas fa-tag"></i><span id="categoryText">Technology</span>
    </div>
    
    <!-- Cookie Consent JS -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>

    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    </body>
</html>
