<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master Heaps, Sorting Algorithms, and Hash Tables for FAANG interviews. Complete guide with Python implementations, heapify, heap sort, merge sort, quick sort, and hash collision handling.">
    <meta name="keywords" content="heap, priority queue, sorting algorithms, hash table, merge sort, quick sort, heap sort, Python, data structures, FAANG interview, LeetCode">
    <meta name="author" content="Wasil Zafar">
    
    <!-- Open Graph / Social Media -->
    <meta property="og:title" content="DSA Part 11: Heaps, Sorting & Hashing | Wasil Zafar">
    <meta property="og:description" content="Complete guide to heaps, sorting algorithms, and hash tables for technical interviews.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://wasilzafar.com/pag../series/data-structures/dsa-heaps-sorting-hashing.html">
    <meta property="article:published_time" content="2026-01-28">
    <meta property="article:author" content="Wasil Zafar">
    <meta property="article:section" content="Technology">
    
    <title>DSA Part 11: Heaps, Sorting & Hashing | Wasil Zafar</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../../../images/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Prism.js Syntax Highlighting - Multiple Themes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css">
    
    <!-- Main CSS -->
    <link rel="stylesheet" href="../../../css/main.css">

    <!-- Google tag (gtag.js) - Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'functionality_storage': 'granted',
            'personalization_storage': 'denied',
            'security_storage': 'granted',
            'wait_for_update': 500
        });
        
        gtag('set', 'ads_data_redaction', true);
        gtag('set', 'url_passthrough', true);
    </script>
    
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-PBS8M2JR');</script>
    
    </head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/">
                <span class="gradient-text">Wasil Zafar</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#about">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#skills">Skills</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#certifications">Certifications</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#interests">Interests</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- TOC Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation TOC -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close">&times;</button>
        </div>
        <ol>
            <li><a href="#heaps" onclick="closeNav()">Heap Fundamentals</a></li>
            <li><a href="#heap-operations" onclick="closeNav()">Heap Operations</a></li>
            <li><a href="#python-heapq" onclick="closeNav()">Python heapq</a></li>
            <li><a href="#heap-applications" onclick="closeNav()">Heap Applications</a></li>
            <li><a href="#sorting-overview" onclick="closeNav()">Sorting Overview</a></li>
            <li><a href="#merge-sort" onclick="closeNav()">Merge Sort</a></li>
            <li><a href="#quick-sort" onclick="closeNav()">Quick Sort</a></li>
            <li><a href="#heap-sort" onclick="closeNav()">Heap Sort</a></li>
            <li><a href="#hash-tables" onclick="closeNav()">Hash Tables</a></li>
            <li><a href="#collision-handling" onclick="closeNav()">Collision Handling</a></li>
            <li><a href="#leetcode" onclick="closeNav()">LeetCode Problems</a></li>
            <li><a href="#series-nav" onclick="closeNav()">Complete Series</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link">
                    <i class="fas fa-arrow-left me-2"></i>Back to Technology
                </a>
                <h1 class="display-4 fw-bold mb-3">DSA Part 11: Heaps, Sorting & Hashing</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>January 28, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>28 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
                <p class="lead">Master heaps, sorting algorithms, and hash tables with complete Python implementations. Essential data structures for FAANG interview success.</p>
            </div>
        </div>
    </section>

    <!-- Blog Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">
                    <div class="blog-content">
                        
                        <!-- Heaps -->
                        <h2 id="heaps"><i class="fas fa-layer-group me-2"></i>Heap Fundamentals</h2>
                        
                        <p>A <strong>Heap</strong> is a complete binary tree that satisfies the heap property. It's the underlying data structure for priority queues and is crucial for many interview problems.</p>
                        
                        <div class="highlight-box">
                            <h4><i class="fas fa-lightbulb me-2"></i>Heap Properties</h4>
                            <ul>
                                <li><strong>Max Heap:</strong> Parent ≥ Children (root is maximum)</li>
                                <li><strong>Min Heap:</strong> Parent ≤ Children (root is minimum)</li>
                                <li><strong>Complete Binary Tree:</strong> All levels filled except possibly last, filled left to right</li>
                                <li><strong>Array Representation:</strong> For index i: parent = (i-1)//2, left = 2i+1, right = 2i+2</li>
                            </ul>
                        </div>

                        <div class="experiment-card">
                            <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                            <div class="mb-2">
                                <span class="badge bg-teal me-2">12-Part Series</span>
                                <span class="badge bg-crimson">FAANG Interview Prep</span>
                            </div>
                            <ol>
                                <li><a href="dsa-foundations-memory-complexity.html">Foundations, Memory & Complexity</a></li>
                                <li><a href="dsa-recursion-complete-guide.html">Recursion Complete Guide</a></li>
                                <li><a href="dsa-arrays-adt-operations.html">Arrays & Array ADT</a></li>
                                <li><a href="dsa-strings-manipulation.html">Strings</a></li>
                                <li><a href="dsa-matrices-special-sparse.html">Matrices</a></li>
                                <li><a href="dsa-linked-lists-guide.html">Linked Lists</a></li>
                                <li><a href="dsa-stack-applications.html">Stack</a></li>
                                <li><a href="dsa-queue-implementations.html">Queue</a></li>
                                <li><a href="dsa-trees-fundamentals.html">Trees</a></li>
                                <li><a href="dsa-bst-avl-redblack.html">BST & Balanced Trees</a></li>
                                <li><strong>Heaps, Sorting & Hashing (This Guide)</strong></li>
                                <li><a href="dsa-graphs-dp-greedy-backtracking.html">Graphs, DP, Greedy & Backtracking</a></li>
                            </ol>
                        </div>

                        <h3>Heap Implementation from Scratch</h3>
                        
<pre><code class="language-python">class MinHeap:
    """
    Min Heap implementation using array
    Root is always the minimum element
    """
    def __init__(self):
        self.heap = []
    
    def parent(self, i):
        return (i - 1) // 2
    
    def left_child(self, i):
        return 2 * i + 1
    
    def right_child(self, i):
        return 2 * i + 2
    
    def swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    
    def insert(self, val):
        """Insert value and maintain heap property - O(log n)"""
        self.heap.append(val)
        self._heapify_up(len(self.heap) - 1)
    
    def _heapify_up(self, i):
        """Bubble up to restore heap property"""
        while i > 0 and self.heap[self.parent(i)] > self.heap[i]:
            self.swap(i, self.parent(i))
            i = self.parent(i)
    
    def extract_min(self):
        """Remove and return minimum element - O(log n)"""
        if not self.heap:
            return None
        
        if len(self.heap) == 1:
            return self.heap.pop()
        
        min_val = self.heap[0]
        self.heap[0] = self.heap.pop()  # Move last to root
        self._heapify_down(0)
        
        return min_val
    
    def _heapify_down(self, i):
        """Bubble down to restore heap property"""
        smallest = i
        left = self.left_child(i)
        right = self.right_child(i)
        
        if left < len(self.heap) and self.heap[left] < self.heap[smallest]:
            smallest = left
        
        if right < len(self.heap) and self.heap[right] < self.heap[smallest]:
            smallest = right
        
        if smallest != i:
            self.swap(i, smallest)
            self._heapify_down(smallest)
    
    def peek(self):
        """Return minimum without removing - O(1)"""
        return self.heap[0] if self.heap else None
    
    def size(self):
        return len(self.heap)

# Example usage
heap = MinHeap()
for val in [5, 3, 8, 1, 2, 9, 4]:
    heap.insert(val)
    print(f"Inserted {val}, heap: {heap.heap}")

print("\nExtracting in sorted order:")
while heap.size() > 0:
    print(heap.extract_min(), end=" ")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Min Heap Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;

class MinHeap {
private:
    std::vector&lt;int&gt; heap;
    
    int parent(int i) { return (i - 1) / 2; }
    int left(int i) { return 2 * i + 1; }
    int right(int i) { return 2 * i + 2; }
    
    void heapifyUp(int i) {
        while (i &gt; 0 &amp;&amp; heap[parent(i)] &gt; heap[i]) {
            std::swap(heap[i], heap[parent(i)]);
            i = parent(i);
        }
    }
    
    void heapifyDown(int i) {
        int smallest = i;
        int l = left(i), r = right(i);
        
        if (l &lt; heap.size() &amp;&amp; heap[l] &lt; heap[smallest]) smallest = l;
        if (r &lt; heap.size() &amp;&amp; heap[r] &lt; heap[smallest]) smallest = r;
        
        if (smallest != i) {
            std::swap(heap[i], heap[smallest]);
            heapifyDown(smallest);
        }
    }
    
public:
    void insert(int val) {
        heap.push_back(val);
        heapifyUp(heap.size() - 1);
    }
    
    int extractMin() {
        if (heap.empty()) return -1;
        int minVal = heap[0];
        heap[0] = heap.back();
        heap.pop_back();
        if (!heap.empty()) heapifyDown(0);
        return minVal;
    }
    
    int peek() { return heap.empty() ? -1 : heap[0]; }
    int size() { return heap.size(); }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Min Heap Implementation
import java.util.*;

class MinHeap {
    private List&lt;Integer&gt; heap = new ArrayList&lt;&gt;();
    
    private int parent(int i) { return (i - 1) / 2; }
    private int left(int i) { return 2 * i + 1; }
    private int right(int i) { return 2 * i + 2; }
    
    private void swap(int i, int j) {
        int temp = heap.get(i);
        heap.set(i, heap.get(j));
        heap.set(j, temp);
    }
    
    private void heapifyUp(int i) {
        while (i &gt; 0 &amp;&amp; heap.get(parent(i)) &gt; heap.get(i)) {
            swap(i, parent(i));
            i = parent(i);
        }
    }
    
    private void heapifyDown(int i) {
        int smallest = i;
        int l = left(i), r = right(i);
        
        if (l &lt; heap.size() &amp;&amp; heap.get(l) &lt; heap.get(smallest)) smallest = l;
        if (r &lt; heap.size() &amp;&amp; heap.get(r) &lt; heap.get(smallest)) smallest = r;
        
        if (smallest != i) {
            swap(i, smallest);
            heapifyDown(smallest);
        }
    }
    
    public void insert(int val) {
        heap.add(val);
        heapifyUp(heap.size() - 1);
    }
    
    public int extractMin() {
        if (heap.isEmpty()) return -1;
        int minVal = heap.get(0);
        heap.set(0, heap.get(heap.size() - 1));
        heap.remove(heap.size() - 1);
        if (!heap.isEmpty()) heapifyDown(0);
        return minVal;
    }
    
    public int peek() { return heap.isEmpty() ? -1 : heap.get(0); }
    public int size() { return heap.size(); }
}
</code></pre>

                        <!-- Heap Operations -->
                        <h2 id="heap-operations"><i class="fas fa-cogs me-2"></i>Heap Operations</h2>
                        
                        <h3>Build Heap (Heapify)</h3>
                        
<pre><code class="language-python">def build_min_heap(arr):
    """
    Build min heap from array in-place
    Time: O(n) - not O(n log n)!
    """
    n = len(arr)
    
    # Start from last non-leaf node and heapify down
    # Last non-leaf node is at index (n // 2) - 1
    for i in range(n // 2 - 1, -1, -1):
        heapify_down(arr, n, i)
    
    return arr

def heapify_down(arr, n, i):
    """Heapify down for min heap"""
    smallest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] < arr[smallest]:
        smallest = left
    
    if right < n and arr[right] < arr[smallest]:
        smallest = right
    
    if smallest != i:
        arr[i], arr[smallest] = arr[smallest], arr[i]
        heapify_down(arr, n, smallest)

def build_max_heap(arr):
    """Build max heap from array in-place"""
    n = len(arr)
    
    for i in range(n // 2 - 1, -1, -1):
        max_heapify_down(arr, n, i)
    
    return arr

def max_heapify_down(arr, n, i):
    """Heapify down for max heap"""
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        max_heapify_down(arr, n, largest)

# Example
arr = [4, 10, 3, 5, 1, 8, 7]
print("Original:", arr)

min_heap = build_min_heap(arr.copy())
print("Min heap:", min_heap)

max_heap = build_max_heap(arr.copy())
print("Max heap:", max_heap)
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Build Min/Max Heap in O(n)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

void heapifyDownMin(std::vector&lt;int&gt;&amp; arr, int n, int i) {
    int smallest = i;
    int left = 2 * i + 1, right = 2 * i + 2;
    
    if (left &lt; n &amp;&amp; arr[left] &lt; arr[smallest]) smallest = left;
    if (right &lt; n &amp;&amp; arr[right] &lt; arr[smallest]) smallest = right;
    
    if (smallest != i) {
        std::swap(arr[i], arr[smallest]);
        heapifyDownMin(arr, n, smallest);
    }
}

void heapifyDownMax(std::vector&lt;int&gt;&amp; arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1, right = 2 * i + 2;
    
    if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;
    if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;
    
    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapifyDownMax(arr, n, largest);
    }
}

void buildMinHeap(std::vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    for (int i = n / 2 - 1; i &gt;= 0; i--)
        heapifyDownMin(arr, n, i);
}

void buildMaxHeap(std::vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    for (int i = n / 2 - 1; i &gt;= 0; i--)
        heapifyDownMax(arr, n, i);
}

// Also available: std::make_heap (max heap by default)
// std::make_heap(arr.begin(), arr.end());  // Max heap
// std::make_heap(arr.begin(), arr.end(), std::greater&lt;int&gt;());  // Min heap
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Build Min/Max Heap in O(n)
import java.util.*;

class HeapBuilder {
    private static void heapifyDownMin(int[] arr, int n, int i) {
        int smallest = i;
        int left = 2 * i + 1, right = 2 * i + 2;
        
        if (left &lt; n &amp;&amp; arr[left] &lt; arr[smallest]) smallest = left;
        if (right &lt; n &amp;&amp; arr[right] &lt; arr[smallest]) smallest = right;
        
        if (smallest != i) {
            int temp = arr[i]; arr[i] = arr[smallest]; arr[smallest] = temp;
            heapifyDownMin(arr, n, smallest);
        }
    }
    
    private static void heapifyDownMax(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1, right = 2 * i + 2;
        
        if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;
        if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;
        
        if (largest != i) {
            int temp = arr[i]; arr[i] = arr[largest]; arr[largest] = temp;
            heapifyDownMax(arr, n, largest);
        }
    }
    
    public static void buildMinHeap(int[] arr) {
        int n = arr.length;
        for (int i = n / 2 - 1; i &gt;= 0; i--)
            heapifyDownMin(arr, n, i);
    }
    
    public static void buildMaxHeap(int[] arr) {
        int n = arr.length;
        for (int i = n / 2 - 1; i &gt;= 0; i--)
            heapifyDownMax(arr, n, i);
    }
}

// Also available: PriorityQueue
// PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
// PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());
</code></pre>

                        <div class="experiment-card">
                            <h4><i class="fas fa-clock me-2"></i>Time Complexity Analysis</h4>
                            <table class="table table-bordered">
                                <thead>
                                    <tr>
                                        <th>Operation</th>
                                        <th>Time</th>
                                        <th>Notes</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr><td>Insert</td><td>O(log n)</td><td>Heapify up</td></tr>
                                    <tr><td>Extract Min/Max</td><td>O(log n)</td><td>Heapify down</td></tr>
                                    <tr><td>Peek</td><td>O(1)</td><td>Return root</td></tr>
                                    <tr><td>Build Heap</td><td>O(n)</td><td>Not O(n log n)!</td></tr>
                                    <tr><td>Heap Sort</td><td>O(n log n)</td><td>Build + n extractions</td></tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Python heapq -->
                        <h2 id="python-heapq"><i class="fab fa-python me-2"></i>Python heapq Module</h2>
                        
<pre><code class="language-python">import heapq

# Python heapq implements MIN HEAP only
# For max heap, negate values

# Basic operations
heap = []
heapq.heappush(heap, 3)
heapq.heappush(heap, 1)
heapq.heappush(heap, 4)
heapq.heappush(heap, 1)
heapq.heappush(heap, 5)

print("Heap:", heap)  # [1, 1, 4, 3, 5]
print("Min:", heap[0])  # 1 (peek without removing)

# Extract minimum
print("Pop:", heapq.heappop(heap))  # 1
print("After pop:", heap)  # [1, 3, 4, 5]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// C++ priority_queue (Max heap by default)
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

int main() {
    // Min heap using greater comparator
    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap;
    
    minHeap.push(3);
    minHeap.push(1);
    minHeap.push(4);
    minHeap.push(1);
    minHeap.push(5);
    
    std::cout &lt;&lt; "Min: " &lt;&lt; minHeap.top() &lt;&lt; std::endl;  // 1
    
    minHeap.pop();
    std::cout &lt;&lt; "After pop, Min: " &lt;&lt; minHeap.top() &lt;&lt; std::endl;  // 1
    
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Java PriorityQueue (Min heap by default)
import java.util.*;

public class HeapDemo {
    public static void main(String[] args) {
        // Min heap (default)
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
        
        minHeap.add(3);
        minHeap.add(1);
        minHeap.add(4);
        minHeap.add(1);
        minHeap.add(5);
        
        System.out.println("Heap: " + minHeap);  // [1, 1, 4, 3, 5]
        System.out.println("Min: " + minHeap.peek());  // 1
        
        System.out.println("Pop: " + minHeap.poll());  // 1
        System.out.println("After pop: " + minHeap);
    }
}
</code></pre>

<pre><code class="language-python">import heapq

# heapify - Convert list to heap in-place O(n)
arr = [5, 7, 9, 1, 3]
heapq.heapify(arr)
print("Heapified:", arr)  # [1, 3, 9, 7, 5]

# nlargest and nsmallest - O(n log k)
nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3]
print("3 largest:", heapq.nlargest(3, nums))   # [9, 6, 5]
print("3 smallest:", heapq.nsmallest(3, nums))  # [1, 1, 2]

# With key function
people = [('Alice', 30), ('Bob', 25), ('Charlie', 35)]
print("Oldest:", heapq.nlargest(1, people, key=lambda x: x[1]))
</code></pre>

<pre><code class="language-python">import heapq

# Max Heap using negative values
max_heap = []
values = [3, 1, 4, 1, 5, 9]

for val in values:
    heapq.heappush(max_heap, -val)  # Negate to simulate max heap

print("Max heap (negated):", max_heap)

# Extract max
max_val = -heapq.heappop(max_heap)
print("Maximum:", max_val)  # 9
</code></pre>

<pre><code class="language-python">import heapq

# Priority Queue with tuples (priority, item)
# Lower priority value = higher priority
pq = []
heapq.heappush(pq, (2, "task B"))
heapq.heappush(pq, (1, "task A"))
heapq.heappush(pq, (3, "task C"))

print("Processing order:")
while pq:
    priority, task = heapq.heappop(pq)
    print(f"  {task} (priority {priority})")
</code></pre>

                        <!-- Heap Applications -->
                        <h2 id="heap-applications"><i class="fas fa-rocket me-2"></i>Heap Applications</h2>
                        
                        <h3>Kth Largest Element</h3>
                        
<pre><code class="language-python">import heapq

def find_kth_largest(nums, k):
    """
    LeetCode 215: Kth Largest Element in an Array
    Use min heap of size k
    Time: O(n log k), Space: O(k)
    """
    # Maintain min heap of k largest elements
    min_heap = []
    
    for num in nums:
        heapq.heappush(min_heap, num)
        
        # Keep only k elements
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    
    # Root is kth largest
    return min_heap[0]

def find_kth_largest_quick(nums, k):
    """
    Alternative using nlargest - cleaner
    Time: O(n log k)
    """
    return heapq.nlargest(k, nums)[-1]

# Example
nums = [3, 2, 1, 5, 6, 4]
k = 2
print(f"Array: {nums}")
print(f"{k}th largest: {find_kth_largest(nums, k)}")  # 5

nums = [3, 2, 3, 1, 2, 4, 5, 5, 6]
k = 4
print(f"{k}th largest: {find_kth_largest(nums, k)}")  # 4
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 215 - Kth Largest Element
// Time: O(n log k), Space: O(k)
#include &lt;vector&gt;
#include &lt;queue&gt;

class Solution {
public:
    int findKthLargest(std::vector&lt;int&gt;&amp; nums, int k) {
        // Min heap of size k
        std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap;
        
        for (int num : nums) {
            minHeap.push(num);
            if (minHeap.size() &gt; k) {
                minHeap.pop();
            }
        }
        
        return minHeap.top();
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 215 - Kth Largest Element
// Time: O(n log k), Space: O(k)
import java.util.*;

class Solution {
    public int findKthLargest(int[] nums, int k) {
        // Min heap of size k
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
        
        for (int num : nums) {
            minHeap.add(num);
            if (minHeap.size() &gt; k) {
                minHeap.poll();
            }
        }
        
        return minHeap.peek();
    }
}
</code></pre>

                        <h3>Top K Frequent Elements</h3>
                        
<pre><code class="language-python">import heapq
from collections import Counter

def top_k_frequent(nums, k):
    """
    LeetCode 347: Top K Frequent Elements
    Time: O(n log k), Space: O(n)
    """
    # Count frequencies
    freq = Counter(nums)
    
    # Use min heap of size k
    # Store (frequency, element)
    min_heap = []
    
    for num, count in freq.items():
        heapq.heappush(min_heap, (count, num))
        
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    
    # Extract elements
    return [item[1] for item in min_heap]

# Example
nums = [1, 1, 1, 2, 2, 3]
k = 2
print(f"Top {k} frequent:", top_k_frequent(nums, k))  # [2, 1]

nums = [1]
k = 1
print(f"Top {k} frequent:", top_k_frequent(nums, k))  # [1]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 347 - Top K Frequent Elements
// Time: O(n log k), Space: O(n)
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;

class Solution {
public:
    std::vector&lt;int&gt; topKFrequent(std::vector&lt;int&gt;&amp; nums, int k) {
        // Count frequencies
        std::unordered_map&lt;int, int&gt; freq;
        for (int num : nums) freq[num]++;
        
        // Min heap of (frequency, element)
        auto cmp = [](std::pair&lt;int,int&gt;&amp; a, std::pair&lt;int,int&gt;&amp; b) {
            return a.first &gt; b.first;
        };
        std::priority_queue&lt;std::pair&lt;int,int&gt;, std::vector&lt;std::pair&lt;int,int&gt;&gt;, decltype(cmp)&gt; minHeap(cmp);
        
        for (auto&amp; [num, count] : freq) {
            minHeap.push({count, num});
            if (minHeap.size() &gt; k) minHeap.pop();
        }
        
        std::vector&lt;int&gt; result;
        while (!minHeap.empty()) {
            result.push_back(minHeap.top().second);
            minHeap.pop();
        }
        return result;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 347 - Top K Frequent Elements
// Time: O(n log k), Space: O(n)
import java.util.*;

class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // Count frequencies
        Map&lt;Integer, Integer&gt; freq = new HashMap&lt;&gt;();
        for (int num : nums) freq.put(num, freq.getOrDefault(num, 0) + 1);
        
        // Min heap by frequency
        PriorityQueue&lt;int[]&gt; minHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; a[0] - b[0]);
        
        for (Map.Entry&lt;Integer, Integer&gt; entry : freq.entrySet()) {
            minHeap.add(new int[]{entry.getValue(), entry.getKey()});
            if (minHeap.size() &gt; k) minHeap.poll();
        }
        
        int[] result = new int[k];
        for (int i = 0; i &lt; k; i++) {
            result[i] = minHeap.poll()[1];
        }
        return result;
    }
}
</code></pre>

                        <h3>Merge K Sorted Lists</h3>
                        
<pre><code class="language-python">import heapq

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_k_lists(lists):
    """
    LeetCode 23: Merge k Sorted Lists
    Time: O(n log k) where n = total nodes, k = number of lists
    Space: O(k) for heap
    """
    # Min heap: (value, index, node)
    # Index is for tie-breaking (nodes aren't comparable)
    heap = []
    
    # Initialize heap with first node of each list
    for i, node in enumerate(lists):
        if node:
            heapq.heappush(heap, (node.val, i, node))
    
    # Dummy head for result
    dummy = ListNode(0)
    current = dummy
    
    while heap:
        val, idx, node = heapq.heappop(heap)
        
        # Add to result
        current.next = node
        current = current.next
        
        # Push next node from same list
        if node.next:
            heapq.heappush(heap, (node.next.val, idx, node.next))
    
    return dummy.next

# Helper to create list from array
def create_list(arr):
    dummy = ListNode(0)
    curr = dummy
    for val in arr:
        curr.next = ListNode(val)
        curr = curr.next
    return dummy.next

def list_to_array(head):
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result

# Example
lists = [
    create_list([1, 4, 5]),
    create_list([1, 3, 4]),
    create_list([2, 6])
]

merged = merge_k_lists(lists)
print("Merged:", list_to_array(merged))  # [1, 1, 2, 3, 4, 4, 5, 6]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 23 - Merge K Sorted Lists
// Time: O(n log k), Space: O(k)
#include &lt;vector&gt;
#include &lt;queue&gt;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    ListNode* mergeKLists(std::vector&lt;ListNode*&gt;&amp; lists) {
        auto cmp = [](ListNode* a, ListNode* b) { return a-&gt;val &gt; b-&gt;val; };
        std::priority_queue&lt;ListNode*, std::vector&lt;ListNode*&gt;, decltype(cmp)&gt; minHeap(cmp);
        
        for (ListNode* node : lists) {
            if (node) minHeap.push(node);
        }
        
        ListNode dummy(0);
        ListNode* current = &amp;dummy;
        
        while (!minHeap.empty()) {
            ListNode* node = minHeap.top(); minHeap.pop();
            current-&gt;next = node;
            current = current-&gt;next;
            if (node-&gt;next) minHeap.push(node-&gt;next);
        }
        
        return dummy.next;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 23 - Merge K Sorted Lists
// Time: O(n log k), Space: O(k)
import java.util.*;

class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue&lt;ListNode&gt; minHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; a.val - b.val);
        
        for (ListNode node : lists) {
            if (node != null) minHeap.add(node);
        }
        
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (!minHeap.isEmpty()) {
            ListNode node = minHeap.poll();
            current.next = node;
            current = current.next;
            if (node.next != null) minHeap.add(node.next);
        }
        
        return dummy.next;
    }
}
</code></pre>

                        <!-- Sorting Overview -->
                        <h2 id="sorting-overview"><i class="fas fa-sort-amount-down me-2"></i>Sorting Algorithms Overview</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-table me-2"></i>Sorting Algorithms Comparison</h4>
                            <table class="table table-bordered table-sm">
                                <thead>
                                    <tr>
                                        <th>Algorithm</th>
                                        <th>Best</th>
                                        <th>Average</th>
                                        <th>Worst</th>
                                        <th>Space</th>
                                        <th>Stable</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr><td>Merge Sort</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n)</td><td>Yes</td></tr>
                                    <tr><td>Quick Sort</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n²)</td><td>O(log n)</td><td>No</td></tr>
                                    <tr><td>Heap Sort</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td><td>No</td></tr>
                                    <tr><td>Counting Sort</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>Yes</td></tr>
                                    <tr><td>Radix Sort</td><td>O(nk)</td><td>O(nk)</td><td>O(nk)</td><td>O(n+k)</td><td>Yes</td></tr>
                                    <tr><td>Bubble Sort</td><td>O(n)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>Yes</td></tr>
                                    <tr><td>Insertion Sort</td><td>O(n)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>Yes</td></tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Merge Sort -->
                        <h2 id="merge-sort"><i class="fas fa-code-branch me-2"></i>Merge Sort</h2>
                        
                        <p><strong>Merge Sort</strong> uses divide-and-conquer: split array in half, recursively sort each half, then merge. Guaranteed O(n log n) but requires O(n) extra space.</p>
                        
<pre><code class="language-python">def merge_sort(arr):
    """
    Merge Sort - Divide and Conquer
    Time: O(n log n), Space: O(n)
    Stable: Yes
    """
    if len(arr) <= 1:
        return arr
    
    # Divide
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    # Conquer (merge)
    return merge(left, right)

def merge(left, right):
    """Merge two sorted arrays"""
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:  # <= for stability
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # Add remaining elements
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

# Example
arr = [38, 27, 43, 3, 9, 82, 10]
print("Original:", arr)
print("Sorted:", merge_sort(arr))
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Merge Sort - Divide and Conquer
// Time: O(n log n), Space: O(n), Stable: Yes
#include &lt;vector&gt;

class MergeSort {
private:
    static std::vector&lt;int&gt; merge(std::vector&lt;int&gt;&amp; left, std::vector&lt;int&gt;&amp; right) {
        std::vector&lt;int&gt; result;
        int i = 0, j = 0;
        
        while (i &lt; left.size() &amp;&amp; j &lt; right.size()) {
            if (left[i] &lt;= right[j]) result.push_back(left[i++]);
            else result.push_back(right[j++]);
        }
        
        while (i &lt; left.size()) result.push_back(left[i++]);
        while (j &lt; right.size()) result.push_back(right[j++]);
        
        return result;
    }
    
public:
    static std::vector&lt;int&gt; sort(std::vector&lt;int&gt; arr) {
        if (arr.size() &lt;= 1) return arr;
        
        int mid = arr.size() / 2;
        std::vector&lt;int&gt; left(arr.begin(), arr.begin() + mid);
        std::vector&lt;int&gt; right(arr.begin() + mid, arr.end());
        
        left = sort(left);
        right = sort(right);
        
        return merge(left, right);
    }
};

// Also available: std::sort (introsort) and std::stable_sort (merge sort)
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Merge Sort - Divide and Conquer
// Time: O(n log n), Space: O(n), Stable: Yes
import java.util.*;

class MergeSort {
    public static int[] sort(int[] arr) {
        if (arr.length &lt;= 1) return arr;
        
        int mid = arr.length / 2;
        int[] left = sort(Arrays.copyOfRange(arr, 0, mid));
        int[] right = sort(Arrays.copyOfRange(arr, mid, arr.length));
        
        return merge(left, right);
    }
    
    private static int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0, j = 0, k = 0;
        
        while (i &lt; left.length &amp;&amp; j &lt; right.length) {
            if (left[i] &lt;= right[j]) result[k++] = left[i++];
            else result[k++] = right[j++];
        }
        
        while (i &lt; left.length) result[k++] = left[i++];
        while (j &lt; right.length) result[k++] = right[j++];
        
        return result;
    }
}

// Also available: Arrays.sort() uses dual-pivot quicksort for primitives,
// merge sort for objects (stable)
</code></pre>

<pre><code class="language-python">def merge_sort_inplace(arr, left, right):
    """
    Merge Sort - In-place variant (still O(n) space for merge)
    Useful for linked lists where O(1) space is achievable
    """
    if left < right:
        mid = (left + right) // 2
        
        merge_sort_inplace(arr, left, mid)
        merge_sort_inplace(arr, mid + 1, right)
        merge_inplace(arr, left, mid, right)

def merge_inplace(arr, left, mid, right):
    """Merge two sorted subarrays using auxiliary space"""
    # Create temp arrays
    left_arr = arr[left:mid + 1]
    right_arr = arr[mid + 1:right + 1]
    
    i = j = 0
    k = left
    
    while i < len(left_arr) and j < len(right_arr):
        if left_arr[i] <= right_arr[j]:
            arr[k] = left_arr[i]
            i += 1
        else:
            arr[k] = right_arr[j]
            j += 1
        k += 1
    
    while i < len(left_arr):
        arr[k] = left_arr[i]
        i += 1
        k += 1
    
    while j < len(right_arr):
        arr[k] = right_arr[j]
        j += 1
        k += 1

# Example
arr = [12, 11, 13, 5, 6, 7]
print("Original:", arr)
merge_sort_inplace(arr, 0, len(arr) - 1)
print("Sorted:", arr)
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Merge Sort - In-place variant
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class MergeSortInplace {
private:
    static void merge(std::vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
        std::vector&lt;int&gt; leftArr(arr.begin() + left, arr.begin() + mid + 1);
        std::vector&lt;int&gt; rightArr(arr.begin() + mid + 1, arr.begin() + right + 1);
        
        int i = 0, j = 0, k = left;
        
        while (i &lt; leftArr.size() &amp;&amp; j &lt; rightArr.size()) {
            if (leftArr[i] &lt;= rightArr[j]) arr[k++] = leftArr[i++];
            else arr[k++] = rightArr[j++];
        }
        
        while (i &lt; leftArr.size()) arr[k++] = leftArr[i++];
        while (j &lt; rightArr.size()) arr[k++] = rightArr[j++];
    }
    
public:
    static void sort(std::vector&lt;int&gt;&amp; arr, int left, int right) {
        if (left &lt; right) {
            int mid = left + (right - left) / 2;
            sort(arr, left, mid);
            sort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Merge Sort - In-place variant
import java.util.*;

class MergeSortInplace {
    public static void sort(int[] arr, int left, int right) {
        if (left &lt; right) {
            int mid = left + (right - left) / 2;
            sort(arr, left, mid);
            sort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }
    
    private static void merge(int[] arr, int left, int mid, int right) {
        int[] leftArr = Arrays.copyOfRange(arr, left, mid + 1);
        int[] rightArr = Arrays.copyOfRange(arr, mid + 1, right + 1);
        
        int i = 0, j = 0, k = left;
        
        while (i &lt; leftArr.length &amp;&amp; j &lt; rightArr.length) {
            if (leftArr[i] &lt;= rightArr[j]) arr[k++] = leftArr[i++];
            else arr[k++] = rightArr[j++];
        }
        
        while (i &lt; leftArr.length) arr[k++] = leftArr[i++];
        while (j &lt; rightArr.length) arr[k++] = rightArr[j++];
    }
}
</code></pre>

                        <!-- Quick Sort -->
                        <h2 id="quick-sort"><i class="fas fa-bolt me-2"></i>Quick Sort</h2>
                        
                        <p><strong>Quick Sort</strong> picks a pivot and partitions array into elements smaller and larger than pivot. Average O(n log n) with O(log n) space, but O(n²) worst case.</p>
                        
<pre><code class="language-python">def quick_sort(arr):
    """
    Quick Sort - Simple implementation
    Time: O(n log n) average, O(n²) worst
    Space: O(log n) average for recursion
    """
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]  # Middle element as pivot
    
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# Example
arr = [3, 6, 8, 10, 1, 2, 1]
print("Original:", arr)
print("Sorted:", quick_sort(arr))
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Quick Sort - Simple implementation
// Time: O(n log n) average, O(n²) worst, Space: O(log n)
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class QuickSort {
public:
    static std::vector&lt;int&gt; sort(std::vector&lt;int&gt; arr) {
        if (arr.size() &lt;= 1) return arr;
        
        int pivot = arr[arr.size() / 2];
        std::vector&lt;int&gt; left, middle, right;
        
        for (int x : arr) {
            if (x &lt; pivot) left.push_back(x);
            else if (x == pivot) middle.push_back(x);
            else right.push_back(x);
        }
        
        left = sort(left);
        right = sort(right);
        
        left.insert(left.end(), middle.begin(), middle.end());
        left.insert(left.end(), right.begin(), right.end());
        return left;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Quick Sort - Simple implementation
// Time: O(n log n) average, O(n²) worst, Space: O(log n)
import java.util.*;

class QuickSort {
    public static List&lt;Integer&gt; sort(List&lt;Integer&gt; arr) {
        if (arr.size() &lt;= 1) return new ArrayList&lt;&gt;(arr);
        
        int pivot = arr.get(arr.size() / 2);
        List&lt;Integer&gt; left = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; middle = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; right = new ArrayList&lt;&gt;();
        
        for (int x : arr) {
            if (x &lt; pivot) left.add(x);
            else if (x == pivot) middle.add(x);
            else right.add(x);
        }
        
        List&lt;Integer&gt; result = sort(left);
        result.addAll(middle);
        result.addAll(sort(right));
        return result;
    }
}
</code></pre>

<pre><code class="language-python">def quick_sort_inplace(arr, low, high):
    """
    Quick Sort - In-place with Lomuto partition
    More memory efficient
    """
    if low < high:
        # Partition and get pivot index
        pivot_idx = partition(arr, low, high)
        
        # Recursively sort partitions
        quick_sort_inplace(arr, low, pivot_idx - 1)
        quick_sort_inplace(arr, pivot_idx + 1, high)

def partition(arr, low, high):
    """
    Lomuto partition scheme
    Pivot is last element
    """
    pivot = arr[high]
    i = low - 1  # Index of smaller element
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    # Place pivot in correct position
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    
    return i + 1

# Example
arr = [10, 7, 8, 9, 1, 5]
print("Original:", arr)
quick_sort_inplace(arr, 0, len(arr) - 1)
print("Sorted:", arr)
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Quick Sort - In-place with Lomuto partition
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class QuickSortInplace {
private:
    static int partition(std::vector&lt;int&gt;&amp; arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j &lt; high; j++) {
            if (arr[j] &lt;= pivot) {
                i++;
                std::swap(arr[i], arr[j]);
            }
        }
        std::swap(arr[i + 1], arr[high]);
        return i + 1;
    }
    
public:
    static void sort(std::vector&lt;int&gt;&amp; arr, int low, int high) {
        if (low &lt; high) {
            int pivotIdx = partition(arr, low, high);
            sort(arr, low, pivotIdx - 1);
            sort(arr, pivotIdx + 1, high);
        }
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Quick Sort - In-place with Lomuto partition

class QuickSortInplace {
    public static void sort(int[] arr, int low, int high) {
        if (low &lt; high) {
            int pivotIdx = partition(arr, low, high);
            sort(arr, low, pivotIdx - 1);
            sort(arr, pivotIdx + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j &lt; high; j++) {
            if (arr[j] &lt;= pivot) {
                i++;
                int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;
            }
        }
        int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp;
        return i + 1;
    }
}
</code></pre>

<pre><code class="language-python">import random

def quick_sort_randomized(arr, low, high):
    """
    Randomized Quick Sort
    Avoids O(n²) worst case by random pivot selection
    """
    if low < high:
        pivot_idx = randomized_partition(arr, low, high)
        quick_sort_randomized(arr, low, pivot_idx - 1)
        quick_sort_randomized(arr, pivot_idx + 1, high)

def randomized_partition(arr, low, high):
    """Randomly select pivot and partition"""
    # Random pivot
    rand_idx = random.randint(low, high)
    arr[rand_idx], arr[high] = arr[high], arr[rand_idx]
    
    # Standard partition
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# Example with already sorted array (worst case for standard quick sort)
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print("Original (sorted):", arr)
quick_sort_randomized(arr, 0, len(arr) - 1)
print("After randomized quick sort:", arr)
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Randomized Quick Sort - Avoids O(n²) worst case
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;random&gt;

class RandomizedQuickSort {
private:
    static int randomizedPartition(std::vector&lt;int&gt;&amp; arr, int low, int high) {
        // Random pivot selection
        int randIdx = low + rand() % (high - low + 1);
        std::swap(arr[randIdx], arr[high]);
        
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j &lt; high; j++) {
            if (arr[j] &lt;= pivot) {
                i++;
                std::swap(arr[i], arr[j]);
            }
        }
        std::swap(arr[i + 1], arr[high]);
        return i + 1;
    }
    
public:
    static void sort(std::vector&lt;int&gt;&amp; arr, int low, int high) {
        if (low &lt; high) {
            int pivotIdx = randomizedPartition(arr, low, high);
            sort(arr, low, pivotIdx - 1);
            sort(arr, pivotIdx + 1, high);
        }
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Randomized Quick Sort - Avoids O(n²) worst case
import java.util.*;

class RandomizedQuickSort {
    private static Random rand = new Random();
    
    public static void sort(int[] arr, int low, int high) {
        if (low &lt; high) {
            int pivotIdx = randomizedPartition(arr, low, high);
            sort(arr, low, pivotIdx - 1);
            sort(arr, pivotIdx + 1, high);
        }
    }
    
    private static int randomizedPartition(int[] arr, int low, int high) {
        // Random pivot selection
        int randIdx = low + rand.nextInt(high - low + 1);
        int temp = arr[randIdx]; arr[randIdx] = arr[high]; arr[high] = temp;
        
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j &lt; high; j++) {
            if (arr[j] &lt;= pivot) {
                i++;
                temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;
            }
        }
        temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp;
        return i + 1;
    }
}
</code></pre>

                        <!-- Heap Sort -->
                        <h2 id="heap-sort"><i class="fas fa-sort me-2"></i>Heap Sort</h2>
                        
                        <p><strong>Heap Sort</strong> builds a max heap, then repeatedly extracts the maximum. Guaranteed O(n log n) with O(1) extra space, but not stable.</p>
                        
<pre><code class="language-python">def heap_sort(arr):
    """
    Heap Sort - In-place sorting using max heap
    Time: O(n log n), Space: O(1)
    Not stable
    """
    n = len(arr)
    
    # Build max heap - O(n)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Extract elements one by one - O(n log n)
    for i in range(n - 1, 0, -1):
        # Move current root (max) to end
        arr[0], arr[i] = arr[i], arr[0]
        
        # Heapify reduced heap
        heapify(arr, i, 0)
    
    return arr

def heapify(arr, n, i):
    """
    Heapify subtree rooted at index i
    n is size of heap
    """
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

# Example
arr = [12, 11, 13, 5, 6, 7]
print("Original:", arr)
heap_sort(arr)
print("Sorted:", arr)

# Test with larger array
import random
arr = [random.randint(1, 100) for _ in range(15)]
print("\nRandom array:", arr)
heap_sort(arr)
print("Sorted:", arr)
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Heap Sort - In-place using max heap
// Time: O(n log n), Space: O(1), Not stable
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class HeapSort {
private:
    static void heapify(std::vector&lt;int&gt;&amp; arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1, right = 2 * i + 2;
        
        if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;
        if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;
        
        if (largest != i) {
            std::swap(arr[i], arr[largest]);
            heapify(arr, n, largest);
        }
    }
    
public:
    static void sort(std::vector&lt;int&gt;&amp; arr) {
        int n = arr.size();
        
        // Build max heap
        for (int i = n / 2 - 1; i &gt;= 0; i--)
            heapify(arr, n, i);
        
        // Extract elements one by one
        for (int i = n - 1; i &gt; 0; i--) {
            std::swap(arr[0], arr[i]);
            heapify(arr, i, 0);
        }
    }
};

// Also available: std::sort_heap after std::make_heap
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Heap Sort - In-place using max heap
// Time: O(n log n), Space: O(1), Not stable

class HeapSort {
    public static void sort(int[] arr) {
        int n = arr.length;
        
        // Build max heap
        for (int i = n / 2 - 1; i &gt;= 0; i--)
            heapify(arr, n, i);
        
        // Extract elements one by one
        for (int i = n - 1; i &gt; 0; i--) {
            int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp;
            heapify(arr, i, 0);
        }
    }
    
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1, right = 2 * i + 2;
        
        if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;
        if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;
        
        if (largest != i) {
            int temp = arr[i]; arr[i] = arr[largest]; arr[largest] = temp;
            heapify(arr, n, largest);
        }
    }
}
</code></pre>

                        <!-- Hash Tables -->
                        <h2 id="hash-tables"><i class="fas fa-hashtag me-2"></i>Hash Tables</h2>
                        
                        <p>A <strong>Hash Table</strong> provides O(1) average-case lookup, insert, and delete by using a hash function to map keys to array indices.</p>
                        
                        <div class="highlight-box">
                            <h4><i class="fas fa-key me-2"></i>Hash Table Concepts</h4>
                            <ul>
                                <li><strong>Hash Function:</strong> Maps keys to array indices</li>
                                <li><strong>Collision:</strong> When two keys hash to same index</li>
                                <li><strong>Load Factor:</strong> n/m (items/buckets) - typically keep < 0.75</li>
                                <li><strong>Rehashing:</strong> Resize and rehash when load factor exceeds threshold</li>
                            </ul>
                        </div>

<pre><code class="language-python">class HashTable:
    """
    Hash Table with chaining for collision resolution
    """
    def __init__(self, size=10):
        self.size = size
        self.buckets = [[] for _ in range(size)]
        self.count = 0
    
    def _hash(self, key):
        """Simple hash function"""
        return hash(key) % self.size
    
    def put(self, key, value):
        """Insert or update key-value pair - O(1) average"""
        index = self._hash(key)
        
        # Check if key exists, update if so
        for i, (k, v) in enumerate(self.buckets[index]):
            if k == key:
                self.buckets[index][i] = (key, value)
                return
        
        # Add new key-value pair
        self.buckets[index].append((key, value))
        self.count += 1
        
        # Rehash if load factor > 0.75
        if self.count / self.size > 0.75:
            self._rehash()
    
    def get(self, key):
        """Get value by key - O(1) average"""
        index = self._hash(key)
        
        for k, v in self.buckets[index]:
            if k == key:
                return v
        
        return None  # Key not found
    
    def remove(self, key):
        """Remove key-value pair - O(1) average"""
        index = self._hash(key)
        
        for i, (k, v) in enumerate(self.buckets[index]):
            if k == key:
                del self.buckets[index][i]
                self.count -= 1
                return True
        
        return False  # Key not found
    
    def _rehash(self):
        """Double size and rehash all elements"""
        old_buckets = self.buckets
        self.size *= 2
        self.buckets = [[] for _ in range(self.size)]
        self.count = 0
        
        for bucket in old_buckets:
            for key, value in bucket:
                self.put(key, value)
    
    def __str__(self):
        items = []
        for bucket in self.buckets:
            for k, v in bucket:
                items.append(f"{k}: {v}")
        return "{" + ", ".join(items) + "}"

# Example usage
ht = HashTable()
ht.put("apple", 5)
ht.put("banana", 3)
ht.put("cherry", 8)
ht.put("date", 2)

print("Hash table:", ht)
print("Get 'banana':", ht.get("banana"))

ht.put("banana", 10)  # Update
print("After update:", ht.get("banana"))

ht.remove("cherry")
print("After remove:", ht)
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Hash Table with Chaining (Separate Chaining)
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;optional&gt;
#include &lt;functional&gt;

template&lt;typename K, typename V&gt;
class HashTableChaining {
private:
    struct Entry {
        K key;
        V value;
        Entry(K k, V v) : key(k), value(v) {}
    };
    
    std::vector&lt;std::list&lt;Entry&gt;&gt; buckets;
    int size_;
    
    int hash(const K&amp; key) const {
        return std::hash&lt;K&gt;{}(key) % buckets.size();
    }
    
public:
    HashTableChaining(int capacity = 16) : buckets(capacity), size_(0) {}
    
    void put(const K&amp; key, const V&amp; value) {
        int idx = hash(key);
        for (auto&amp; entry : buckets[idx]) {
            if (entry.key == key) {
                entry.value = value;
                return;
            }
        }
        buckets[idx].emplace_back(key, value);
        size_++;
    }
    
    std::optional&lt;V&gt; get(const K&amp; key) const {
        int idx = hash(key);
        for (const auto&amp; entry : buckets[idx]) {
            if (entry.key == key) return entry.value;
        }
        return std::nullopt;
    }
    
    bool remove(const K&amp; key) {
        int idx = hash(key);
        auto&amp; bucket = buckets[idx];
        for (auto it = bucket.begin(); it != bucket.end(); ++it) {
            if (it-&gt;key == key) {
                bucket.erase(it);
                size_--;
                return true;
            }
        }
        return false;
    }
    
    int size() const { return size_; }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Hash Table with Chaining (Separate Chaining)
import java.util.*;

class HashTableChaining&lt;K, V&gt; {
    private static class Entry&lt;K, V&gt; {
        K key; V value;
        Entry(K k, V v) { key = k; value = v; }
    }
    
    private LinkedList&lt;Entry&lt;K, V&gt;&gt;[] buckets;
    private int size;
    
    @SuppressWarnings("unchecked")
    public HashTableChaining(int capacity) {
        buckets = new LinkedList[capacity];
        for (int i = 0; i &lt; capacity; i++)
            buckets[i] = new LinkedList&lt;&gt;();
        size = 0;
    }
    
    private int hash(K key) {
        return Math.abs(key.hashCode()) % buckets.length;
    }
    
    public void put(K key, V value) {
        int idx = hash(key);
        for (Entry&lt;K, V&gt; entry : buckets[idx]) {
            if (entry.key.equals(key)) {
                entry.value = value;
                return;
            }
        }
        buckets[idx].add(new Entry&lt;&gt;(key, value));
        size++;
    }
    
    public V get(K key) {
        int idx = hash(key);
        for (Entry&lt;K, V&gt; entry : buckets[idx]) {
            if (entry.key.equals(key)) return entry.value;
        }
        return null;
    }
    
    public boolean remove(K key) {
        int idx = hash(key);
        Iterator&lt;Entry&lt;K, V&gt;&gt; it = buckets[idx].iterator();
        while (it.hasNext()) {
            if (it.next().key.equals(key)) {
                it.remove();
                size--;
                return true;
            }
        }
        return false;
    }
    
    public int size() { return size; }
}
</code></pre>

                        <!-- Collision Handling -->
                        <h2 id="collision-handling"><i class="fas fa-random me-2"></i>Collision Handling</h2>
                        
                        <h3>Open Addressing (Linear Probing)</h3>
                        
<pre><code class="language-python">class HashTableOpenAddressing:
    """
    Hash Table with open addressing (linear probing)
    """
    def __init__(self, size=10):
        self.size = size
        self.keys = [None] * size
        self.values = [None] * size
        self.count = 0
        self.DELETED = object()  # Tombstone marker
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def _probe(self, key):
        """Linear probing to find slot"""
        index = self._hash(key)
        first_deleted = None
        
        while self.keys[index] is not None:
            if self.keys[index] == key:
                return index, False  # Found existing key
            
            if self.keys[index] is self.DELETED and first_deleted is None:
                first_deleted = index
            
            index = (index + 1) % self.size
        
        # Use first deleted slot if found, else use empty slot
        if first_deleted is not None:
            return first_deleted, True
        return index, True
    
    def put(self, key, value):
        """Insert or update - O(1) average"""
        if self.count >= self.size * 0.7:
            self._rehash()
        
        index, is_new = self._probe(key)
        
        if is_new:
            self.count += 1
        
        self.keys[index] = key
        self.values[index] = value
    
    def get(self, key):
        """Get value - O(1) average"""
        index = self._hash(key)
        
        while self.keys[index] is not None:
            if self.keys[index] == key:
                return self.values[index]
            index = (index + 1) % self.size
        
        return None
    
    def remove(self, key):
        """Remove using tombstone - O(1) average"""
        index = self._hash(key)
        
        while self.keys[index] is not None:
            if self.keys[index] == key:
                self.keys[index] = self.DELETED
                self.values[index] = None
                self.count -= 1
                return True
            index = (index + 1) % self.size
        
        return False
    
    def _rehash(self):
        """Resize and rehash"""
        old_keys = self.keys
        old_values = self.values
        
        self.size *= 2
        self.keys = [None] * self.size
        self.values = [None] * self.size
        self.count = 0
        
        for i, key in enumerate(old_keys):
            if key is not None and key is not self.DELETED:
                self.put(key, old_values[i])

# Example
ht = HashTableOpenAddressing(5)
ht.put("a", 1)
ht.put("b", 2)
ht.put("c", 3)

print("Get 'b':", ht.get("b"))
ht.remove("b")
print("After remove 'b':", ht.get("b"))
ht.put("d", 4)  # May use deleted slot
print("Get 'd':", ht.get("d"))
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Hash Table with Open Addressing (Linear Probing)
#include &lt;vector&gt;
#include &lt;optional&gt;
#include &lt;functional&gt;

template&lt;typename K, typename V&gt;
class HashTableOpenAddressing {
private:
    enum State { EMPTY, OCCUPIED, DELETED };
    struct Entry {
        K key; V value; State state = EMPTY;
    };
    
    std::vector&lt;Entry&gt; table;
    int size_ = 0, capacity;
    double loadFactor = 0.7;
    
    int hash(const K&amp; key) const {
        return std::hash&lt;K&gt;{}(key) % capacity;
    }
    
    void rehash() {
        auto old = table;
        capacity *= 2;
        table.assign(capacity, Entry{});
        size_ = 0;
        for (const auto&amp; e : old)
            if (e.state == OCCUPIED) put(e.key, e.value);
    }
    
public:
    HashTableOpenAddressing(int cap = 16) : capacity(cap), table(cap) {}
    
    void put(const K&amp; key, const V&amp; value) {
        if ((double)size_ / capacity &gt;= loadFactor) rehash();
        
        int idx = hash(key), firstDeleted = -1;
        while (table[idx].state != EMPTY) {
            if (table[idx].state == DELETED &amp;&amp; firstDeleted == -1)
                firstDeleted = idx;
            else if (table[idx].state == OCCUPIED &amp;&amp; table[idx].key == key) {
                table[idx].value = value;
                return;
            }
            idx = (idx + 1) % capacity;
        }
        
        int insertIdx = (firstDeleted != -1) ? firstDeleted : idx;
        table[insertIdx] = {key, value, OCCUPIED};
        size_++;
    }
    
    std::optional&lt;V&gt; get(const K&amp; key) const {
        int idx = hash(key);
        while (table[idx].state != EMPTY) {
            if (table[idx].state == OCCUPIED &amp;&amp; table[idx].key == key)
                return table[idx].value;
            idx = (idx + 1) % capacity;
        }
        return std::nullopt;
    }
    
    bool remove(const K&amp; key) {
        int idx = hash(key);
        while (table[idx].state != EMPTY) {
            if (table[idx].state == OCCUPIED &amp;&amp; table[idx].key == key) {
                table[idx].state = DELETED;
                size_--;
                return true;
            }
            idx = (idx + 1) % capacity;
        }
        return false;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Hash Table with Open Addressing (Linear Probing)

class HashTableOpenAddressing&lt;K, V&gt; {
    private enum State { EMPTY, OCCUPIED, DELETED }
    private static class Entry&lt;K, V&gt; {
        K key; V value; State state = State.EMPTY;
    }
    
    private Entry&lt;K, V&gt;[] table;
    private int size = 0, capacity;
    private double loadFactor = 0.7;
    
    @SuppressWarnings("unchecked")
    public HashTableOpenAddressing(int cap) {
        capacity = cap;
        table = new Entry[capacity];
        for (int i = 0; i &lt; capacity; i++) table[i] = new Entry&lt;&gt;();
    }
    
    private int hash(K key) {
        return Math.abs(key.hashCode()) % capacity;
    }
    
    private void rehash() {
        Entry&lt;K, V&gt;[] old = table;
        capacity *= 2;
        table = new Entry[capacity];
        for (int i = 0; i &lt; capacity; i++) table[i] = new Entry&lt;&gt;();
        size = 0;
        for (Entry&lt;K, V&gt; e : old)
            if (e.state == State.OCCUPIED) put(e.key, e.value);
    }
    
    public void put(K key, V value) {
        if ((double)size / capacity &gt;= loadFactor) rehash();
        
        int idx = hash(key), firstDeleted = -1;
        while (table[idx].state != State.EMPTY) {
            if (table[idx].state == State.DELETED &amp;&amp; firstDeleted == -1)
                firstDeleted = idx;
            else if (table[idx].state == State.OCCUPIED &amp;&amp; table[idx].key.equals(key)) {
                table[idx].value = value;
                return;
            }
            idx = (idx + 1) % capacity;
        }
        
        int insertIdx = (firstDeleted != -1) ? firstDeleted : idx;
        table[insertIdx].key = key;
        table[insertIdx].value = value;
        table[insertIdx].state = State.OCCUPIED;
        size++;
    }
    
    public V get(K key) {
        int idx = hash(key);
        while (table[idx].state != State.EMPTY) {
            if (table[idx].state == State.OCCUPIED &amp;&amp; table[idx].key.equals(key))
                return table[idx].value;
            idx = (idx + 1) % capacity;
        }
        return null;
    }
}
</code></pre>

                        <h3>Common Hash Table Problems</h3>
                        
<pre><code class="language-python">from collections import defaultdict

def two_sum(nums, target):
    """
    LeetCode 1: Two Sum
    Time: O(n), Space: O(n)
    """
    seen = {}  # value -> index
    
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    
    return []

def group_anagrams(strs):
    """
    LeetCode 49: Group Anagrams
    Time: O(n * k log k), Space: O(n * k)
    """
    groups = defaultdict(list)
    
    for s in strs:
        # Use sorted string as key
        key = ''.join(sorted(s))
        groups[key].append(s)
    
    return list(groups.values())

def longest_consecutive(nums):
    """
    LeetCode 128: Longest Consecutive Sequence
    Time: O(n), Space: O(n)
    """
    num_set = set(nums)
    max_length = 0
    
    for num in num_set:
        # Only start counting if num is start of sequence
        if num - 1 not in num_set:
            current = num
            length = 1
            
            while current + 1 in num_set:
                current += 1
                length += 1
            
            max_length = max(max_length, length)
    
    return max_length

# Examples
print("Two Sum:", two_sum([2, 7, 11, 15], 9))

strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
print("Group Anagrams:", group_anagrams(strs))

nums = [100, 4, 200, 1, 3, 2]
print("Longest Consecutive:", longest_consecutive(nums))
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Common Hash Table Problems
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

class HashTableProblems {
public:
    // LeetCode 1: Two Sum - O(n) time, O(n) space
    std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt;&amp; nums, int target) {
        std::unordered_map&lt;int, int&gt; seen;
        for (int i = 0; i &lt; nums.size(); i++) {
            int complement = target - nums[i];
            if (seen.count(complement))
                return {seen[complement], i};
            seen[nums[i]] = i;
        }
        return {};
    }
    
    // LeetCode 49: Group Anagrams - O(n*k log k)
    std::vector&lt;std::vector&lt;std::string&gt;&gt; groupAnagrams(std::vector&lt;std::string&gt;&amp; strs) {
        std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; groups;
        for (const std::string&amp; s : strs) {
            std::string key = s;
            std::sort(key.begin(), key.end());
            groups[key].push_back(s);
        }
        
        std::vector&lt;std::vector&lt;std::string&gt;&gt; result;
        for (auto&amp; [key, group] : groups)
            result.push_back(std::move(group));
        return result;
    }
    
    // LeetCode 128: Longest Consecutive Sequence - O(n)
    int longestConsecutive(std::vector&lt;int&gt;&amp; nums) {
        std::unordered_set&lt;int&gt; numSet(nums.begin(), nums.end());
        int maxLen = 0;
        
        for (int num : numSet) {
            if (numSet.find(num - 1) == numSet.end()) {
                int curr = num, len = 1;
                while (numSet.count(curr + 1)) {
                    curr++;
                    len++;
                }
                maxLen = std::max(maxLen, len);
            }
        }
        return maxLen;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Common Hash Table Problems
import java.util.*;

class HashTableProblems {
    // LeetCode 1: Two Sum - O(n) time, O(n) space
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; seen = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            int complement = target - nums[i];
            if (seen.containsKey(complement))
                return new int[]{seen.get(complement), i};
            seen.put(nums[i], i);
        }
        return new int[]{};
    }
    
    // LeetCode 49: Group Anagrams - O(n*k log k)
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        Map&lt;String, List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();
        for (String s : strs) {
            char[] chars = s.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);
            groups.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(s);
        }
        return new ArrayList&lt;&gt;(groups.values());
    }
    
    // LeetCode 128: Longest Consecutive Sequence - O(n)
    public int longestConsecutive(int[] nums) {
        Set&lt;Integer&gt; numSet = new HashSet&lt;&gt;();
        for (int num : nums) numSet.add(num);
        
        int maxLen = 0;
        for (int num : numSet) {
            if (!numSet.contains(num - 1)) {
                int curr = num, len = 1;
                while (numSet.contains(curr + 1)) {
                    curr++;
                    len++;
                }
                maxLen = Math.max(maxLen, len);
            }
        }
        return maxLen;
    }
}
</code></pre>

                        <!-- LeetCode Problems -->
                        <h2 id="leetcode"><i class="fas fa-code me-2"></i>LeetCode Practice Problems</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-tasks me-2"></i>Essential Problems</h4>
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>#</th>
                                        <th>Problem</th>
                                        <th>Difficulty</th>
                                        <th>Key Concept</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>215</td>
                                        <td>Kth Largest Element in an Array</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Min heap of size k</td>
                                    </tr>
                                    <tr>
                                        <td>347</td>
                                        <td>Top K Frequent Elements</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Hash map + heap</td>
                                    </tr>
                                    <tr>
                                        <td>23</td>
                                        <td>Merge k Sorted Lists</td>
                                        <td><span class="badge badge-hard">Hard</span></td>
                                        <td>Min heap for k-way merge</td>
                                    </tr>
                                    <tr>
                                        <td>295</td>
                                        <td>Find Median from Data Stream</td>
                                        <td><span class="badge badge-hard">Hard</span></td>
                                        <td>Two heaps (max + min)</td>
                                    </tr>
                                    <tr>
                                        <td>973</td>
                                        <td>K Closest Points to Origin</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Max heap of size k</td>
                                    </tr>
                                    <tr>
                                        <td>1</td>
                                        <td>Two Sum</td>
                                        <td><span class="badge badge-easy">Easy</span></td>
                                        <td>Hash map lookup</td>
                                    </tr>
                                    <tr>
                                        <td>49</td>
                                        <td>Group Anagrams</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Hash map grouping</td>
                                    </tr>
                                    <tr>
                                        <td>128</td>
                                        <td>Longest Consecutive Sequence</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Hash set for O(n)</td>
                                    </tr>
                                    <tr>
                                        <td>912</td>
                                        <td>Sort an Array</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Merge/Quick/Heap sort</td>
                                    </tr>
                                    <tr>
                                        <td>148</td>
                                        <td>Sort List</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Merge sort on linked list</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Series Navigation -->
                        <h2 id="series-nav"><i class="fas fa-book me-2"></i>Complete DSA Series</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-graduation-cap me-2"></i>FAANG Interview Preparation</h4>
                            <div class="row">
                                <div class="col-md-6">
                                    <ol>
                                        <li><a href="dsa-foundations-memory-complexity.html">Foundations & Complexity</a></li>
                                        <li><a href="dsa-recursion-complete-guide.html">Recursion Deep Dive</a></li>
                                        <li><a href="dsa-arrays-adt-operations.html">Arrays & ADT</a></li>
                                        <li><a href="dsa-strings-manipulation.html">Strings & Manipulation</a></li>
                                        <li><a href="dsa-matrices-special-sparse.html">Matrices & Sparse</a></li>
                                        <li><a href="dsa-linked-lists-guide.html">Linked Lists</a></li>
                                    </ol>
                                </div>
                                <div class="col-md-6">
                                    <ol start="7">
                                        <li><a href="dsa-stack-applications.html">Stack & Applications</a></li>
                                        <li><a href="dsa-queue-implementations.html">Queue & Variants</a></li>
                                        <li><a href="dsa-trees-fundamentals.html">Trees & Traversals</a></li>
                                        <li><a href="dsa-bst-avl-redblack.html">BST & Balanced Trees</a></li>
                                        <li><strong>Heaps, Sorting & Hashing (You are here)</strong></li>
                                        <li><a href="dsa-graphs-dp-greedy-backtracking.html">Graphs, DP & Greedy</a></li>
                                    </ol>
                                </div>
                            </div>
                        </div>

                        <!-- Related Posts -->
                        <div class="related-posts">
                            <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 10: BST & Balanced Trees</h5>
                                <p class="text-muted small mb-2">Binary Search Trees, AVL Trees, and Red-Black Trees with rotations.</p>
                                <a href="dsa-bst-avl-redblack.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 12: Graphs, DP, Greedy & Backtracking</h5>
                                <p class="text-muted small mb-2">Graph algorithms, dynamic programming, greedy algorithms, and backtracking patterns.</p>
                                <a href="dsa-graphs-dp-greedy-backtracking.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 9: Trees & Traversals</h5>
                                <p class="text-muted small mb-2">Binary tree fundamentals, DFS, BFS, and classic tree problems.</p>
                                <a href="dsa-trees-fundamentals.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest"><i class="fab fa-pinterest-p"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Scroll to Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Cookie Consent -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>
    
    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    </body>
</html>
