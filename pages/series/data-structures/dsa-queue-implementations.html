<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 8 of the Complete DSA Series: Master queue data structure with array and linked list implementations, circular queue, deque, priority queue, and FAANG interview problems." />
    <meta name="author" content="Wasil Zafar" />
    <meta name="keywords" content="Queue, DSA, Data Structures, Circular Queue, Deque, Priority Queue, BFS, FAANG Interview, LeetCode" />
    <meta property="og:title" content="Complete DSA Series Part 8: Queue" />
    <meta property="og:description" content="Master queue implementations, circular queue, deque, priority queue, BFS applications, and FAANG interview problems." />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2026-01-28" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />
    
    <title>Complete DSA Series Part 8: Queue - Wasil Zafar</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />

    <!-- Prism.js Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <!-- Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE']
        });
        gtag('consent', 'default', {
            'ad_storage': 'granted',
            'ad_user_data': 'granted',
            'ad_personalization': 'granted',
            'analytics_storage': 'granted'
        });
        gtag('set', 'url_passthrough', true);
    </script>

    <!-- Google Tag Manager -->
    <script>
        (function(w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s),
                dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>

    <style>
        /* Blog Hero */
        .blog-hero {
            background: linear-gradient(135deg, var(--color-navy) 0%, var(--color-blue) 100%);
            color: white;
            padding: 80px 0;
        }
        .blog-meta {
            font-size: 0.95rem;
            color: var(--color-teal);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        .print-btn {
            background: var(--color-teal);
            color: white;
            border: none;
            padding: 0.4rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        .print-btn:hover {
            background: var(--color-crimson);
            transform: translateY(-1px);
        }
        .reading-time {
            display: inline-block;
            background: var(--color-crimson);
            color: white;
            padding: 0.3rem 0.8rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .back-link {
            display: inline-block;
            color: white;
            text-decoration: none;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
            opacity: 0.9;
        }
        .back-link:hover {
            color: var(--color-teal);
            opacity: 1;
            transform: translateX(-5px);
        }

        /* Print Styles */
        @media print {
            .print-btn, nav, .navbar, footer, .back-link, .related-posts,
            .scroll-to-top, .toc-toggle-btn, .sidenav-toc, .sidenav-overlay { 
                display: none !important; 
            }
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            .blog-content h2 { color: var(--color-navy) !important; border-bottom: 3px solid var(--color-teal) !important; }
            .blog-content h3 { color: var(--color-blue) !important; }
            .blog-content h4 { color: var(--color-crimson) !important; }
            .highlight-box { background: rgba(59, 151, 151, 0.1) !important; border-left: 4px solid var(--color-teal) !important; }
            pre[class*="language-"] { page-break-inside: avoid; border: 1px solid #ddd !important; }
            body { font-size: 12pt; line-height: 1.6; }
        }

        /* Blog Content */
        .blog-content {
            max-width: 900px;
            margin: 0 auto;
            font-size: 1.05rem;
            line-height: 1.8;
            color: #333;
        }
        .blog-content h2 {
            font-size: 1.8rem;
            font-weight: 700;
            margin-top: 2.5rem;
            margin-bottom: 1.5rem;
            color: var(--color-navy);
            border-bottom: 3px solid var(--color-teal);
            padding-bottom: 0.5rem;
        }
        .blog-content h3 {
            font-size: 1.3rem;
            font-weight: 600;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: var(--color-blue);
        }
        .blog-content h4 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--color-crimson);
        }
        .blog-content p {
            margin-bottom: 1.2rem;
            text-align: justify;
        }
        .blog-content strong {
            color: var(--color-crimson);
        }

        /* Components */
        .highlight-box {
            background: rgba(59, 151, 151, 0.1);
            border-left: 4px solid var(--color-teal);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 4px;
        }
        .experiment-card {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: all 0.3s ease;
        }
        .experiment-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }
        .experiment-card h4 {
            color: var(--color-crimson);
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        /* Code Blocks */
        pre[class*="language-"] {
            position: relative;
            margin: 1.5rem 0;
            padding-top: 3rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        div.code-toolbar > .toolbar {
            opacity: 1;
            display: flex;
            gap: 0.5rem;
        }
        div.code-toolbar > .toolbar > .toolbar-item > button {
            background: var(--color-teal);
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        div.code-toolbar > .toolbar > .toolbar-item > button:hover {
            background: var(--color-blue);
        }
        div.code-toolbar > .toolbar > .toolbar-item > select {
            background: var(--color-navy);
            color: white;
            border: 1px solid var(--color-teal);
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
        }
        div.code-toolbar > .toolbar > .toolbar-item > select:hover {
            background: var(--color-blue);
        }

        /* TOC Toggle Button */
        .toc-toggle-btn {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            width: 50px;
            height: 50px;
            background: var(--color-teal);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 151, 151, 0.4);
            transition: all 0.3s ease;
            z-index: 1049;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .toc-toggle-btn:hover {
            background: var(--color-crimson);
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(191, 9, 47, 0.5);
        }
        .toc-toggle-btn:active {
            transform: scale(0.95);
        }

        /* Side Navigation */
        .sidenav-toc {
            height: calc(100% - 64px);
            width: 0;
            position: fixed;
            z-index: 1050;
            top: 64px;
            left: 0;
            background: linear-gradient(135deg, var(--color-navy) 0%, var(--color-blue) 100%);
            overflow-x: hidden;
            overflow-y: auto;
            transition: width 0.4s ease;
            padding-top: 30px;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3);
        }
        .sidenav-toc.open { width: 350px; }
        .sidenav-toc .toc-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 30px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--color-teal);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        .sidenav-toc.open .toc-header { opacity: 1; visibility: visible; }
        .sidenav-toc .closebtn {
            font-size: 32px;
            color: white;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .sidenav-toc .closebtn:hover { color: var(--color-crimson); transform: rotate(90deg); }
        .sidenav-toc h3 { color: white; margin: 0; font-weight: 700; font-size: 1.3rem; }
        .sidenav-toc ol { list-style: decimal; padding-left: 30px; margin: 0; color: rgba(255, 255, 255, 0.9); }
        .sidenav-toc ol li { margin-bottom: 8px; }
        .sidenav-toc ul { list-style-type: lower-alpha; padding-left: 30px; margin: 8px 0; }
        .sidenav-toc ul li { margin-bottom: 6px; }
        .sidenav-toc a {
            padding: 12px 30px;
            text-decoration: none;
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.85);
            display: block;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
            position: relative;
        }
        .sidenav-toc a:hover { color: white; background: rgba(59, 151, 151, 0.2); border-left-color: var(--color-teal); padding-left: 35px; }
        .sidenav-toc a.active { color: white; background: rgba(191, 9, 47, 0.3); border-left-color: var(--color-crimson); font-weight: 600; }
        .sidenav-toc a.active::before { content: 'â–¶'; position: absolute; left: 15px; font-size: 0.7rem; color: var(--color-crimson); }
        .sidenav-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1049;
        }
        .sidenav-overlay.show { display: block; }

        /* Scroll-to-Top */
        .scroll-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            background: var(--color-teal);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(59, 151, 151, 0.3);
            z-index: 999;
        }
        .scroll-to-top.show { opacity: 1; visibility: visible; }
        .scroll-to-top:hover { background: var(--color-crimson); transform: translateY(-3px); }

        /* Related Posts */
        .related-posts {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 2rem;
            margin-top: 3rem;
        }
        .related-posts h3 { color: var(--color-navy); margin-bottom: 1.5rem; }
        .related-post-item {
            padding: 1rem;
            border-left: 3px solid var(--color-teal);
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }
        .related-post-item:hover { background: white; border-left-color: var(--color-crimson); }
        .related-post-item a { color: var(--color-blue); text-decoration: none; font-weight: 600; }
        .related-post-item a:hover { color: var(--color-crimson); }

        /* Tables */
        .complexity-table { width: 100%; border-collapse: collapse; margin: 1.5rem 0; }
        .complexity-table th, .complexity-table td { border: 1px solid #ddd; padding: 0.75rem; text-align: center; }
        .complexity-table th { background: var(--color-navy); color: white; }
        .complexity-table tr:nth-child(even) { background: #f9f9f9; }

        /* Badges */
        .badge.bg-teal { background-color: var(--color-teal) !important; }
        .badge.bg-crimson { background-color: var(--color-crimson) !important; }
        .leetcode-badge { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.3rem 0.8rem; border-radius: 4px; font-size: 0.85rem; font-weight: 600; margin: 0.25rem; }
        .leetcode-easy { background: #00b8a3; color: white; }
        .leetcode-medium { background: #ffc01e; color: #333; }
        .leetcode-hard { background: #ff375f; color: white; }

        @media (max-width: 768px) {
            .sidenav-toc.open { width: 280px; }
            .toc-toggle-btn, .scroll-to-top { width: 45px; height: 45px; font-size: 1rem; }
            .toc-toggle-btn { left: 1rem; bottom: 1rem; }
            .scroll-to-top { right: 1rem; bottom: 1rem; }
        }

        html { scroll-behavior: smooth; }
        /* Category Indicator */
        .category-indicator {
            position: fixed;
            bottom: 2rem;
            right: 6.5rem;
            background: var(--color-navy);
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 600;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(19, 36, 64, 0.3);
            z-index: 998;
            max-width: 150px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .category-indicator.show {
            opacity: 1;
            visibility: visible;
        }

        .category-indicator i {
            margin-right: 0.5rem;
            color: var(--color-teal);
        }

        @media (max-width: 768px) {
            .category-indicator {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link">
                    <i class="fas fa-arrow-left me-2"></i>Back to Technology
                </a>
                <h1 class="display-4 fw-bold mb-3">Complete DSA Series Part 8: Queue</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>January 28, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>35 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
                <p class="lead">Master queue implementations including circular queue, double-ended queue (deque), priority queue, BFS applications, and essential FAANG interview problems.</p>
            </div>
        </div>
    </section>

    <!-- TOC Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close">&times;</button>
        </div>
        <ol>
            <li>
                <a href="#introduction" onclick="closeNav()">Introduction</a>
                <ul>
                    <li><a href="#introduction" onclick="closeNav()">Queue Basics</a></li>
                    <li><a href="#operations" onclick="closeNav()">Operations</a></li>
                </ul>
            </li>
            <li>
                <a href="#implementations" onclick="closeNav()">Implementations</a>
                <ul>
                    <li><a href="#array-queue" onclick="closeNav()">Array-Based</a></li>
                    <li><a href="#linkedlist-queue" onclick="closeNav()">Linked List</a></li>
                </ul>
            </li>
            <li>
                <a href="#circular-queue" onclick="closeNav()">Circular Queue</a>
            </li>
            <li>
                <a href="#deque" onclick="closeNav()">Deque (Double-Ended)</a>
            </li>
            <li>
                <a href="#priority-queue" onclick="closeNav()">Priority Queue</a>
            </li>
            <li>
                <a href="#applications" onclick="closeNav()">Applications</a>
                <ul>
                    <li><a href="#bfs" onclick="closeNav()">BFS</a></li>
                    <li><a href="#sliding-window" onclick="closeNav()">Sliding Window</a></li>
                </ul>
            </li>
            <li>
                <a href="#leetcode" onclick="closeNav()">LeetCode Problems</a>
            </li>
        </ol>
    </div>

    <!-- Overlay -->
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Main Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">
                    <div class="blog-content">

                        <!-- Introduction -->
                        <h2 id="introduction"><i class="fas fa-stream me-2" style="color: var(--color-teal);"></i>Introduction to Queue</h2>
                        
                        <p>A queue is a linear data structure that follows the <strong>First-In-First-Out (FIFO)</strong> principle. Think of it like a line at a ticket counter - the first person to join the line is the first to be served. Queues are fundamental in computer science, used in process scheduling, BFS traversal, print spooling, and handling asynchronous data transfer.</p>

                        <div class="highlight-box">
                            <i class="fas fa-lightbulb"></i>
                            <strong>Key Insight:</strong> The FIFO property makes queues ideal for maintaining order of operations. They ensure fairness and preserve sequence, making them essential for task scheduling, buffering, and level-order traversals.
                        </div>

                        <div class="experiment-card">
                            <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                            <div class="mb-2">
                                <span class="badge bg-teal me-2">12-Part Series</span>
                                <span class="badge bg-crimson">FAANG Interview Prep</span>
                            </div>
                            <ol>
                                <li><a href="dsa-foundations-memory-complexity.html">Foundations, Memory & Complexity</a></li>
                                <li><a href="dsa-recursion-complete-guide.html">Recursion Complete Guide</a></li>
                                <li><a href="dsa-arrays-adt-operations.html">Arrays & Array ADT</a></li>
                                <li><a href="dsa-strings-manipulation.html">Strings</a></li>
                                <li><a href="dsa-matrices-special-sparse.html">Matrices</a></li>
                                <li><a href="dsa-linked-lists-guide.html">Linked Lists</a></li>
                                <li><a href="dsa-stack-applications.html">Stack</a></li>
                                <li><strong>Queue (This Guide)</strong></li>
                                <li><a href="dsa-trees-fundamentals.html">Trees</a></li>
                                <li><a href="dsa-bst-avl-redblack.html">BST & Balanced Trees</a></li>
                                <li><a href="dsa-heaps-sorting-hashing.html">Heaps, Sorting & Hashing</a></li>
                                <li><a href="dsa-graphs-dp-greedy-backtracking.html">Graphs, DP, Greedy & Backtracking</a></li>
                            </ol>
                        </div>

                        <!-- Operations -->
                        <h3 id="operations">Queue Operations</h3>

                        <div class="highlight-box">
                            <h4><i class="fas fa-cogs me-2"></i>Core Queue Operations</h4>
                            <table class="complexity-table">
                                <thead>
                                    <tr>
                                        <th>Operation</th>
                                        <th>Description</th>
                                        <th>Time</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>enqueue(item)</strong></td>
                                        <td>Add item to rear</td>
                                        <td>O(1)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>dequeue()</strong></td>
                                        <td>Remove and return front item</td>
                                        <td>O(1)*</td>
                                    </tr>
                                    <tr>
                                        <td><strong>front()/peek()</strong></td>
                                        <td>Return front item without removing</td>
                                        <td>O(1)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>isEmpty()</strong></td>
                                        <td>Check if queue is empty</td>
                                        <td>O(1)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>size()</strong></td>
                                        <td>Return number of items</td>
                                        <td>O(1)</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p class="small text-muted mt-2">* O(n) for simple array implementation due to shifting; O(1) for circular/linked list</p>
                        </div>

                        <!-- Implementations -->
                        <h2 id="implementations"><i class="fas fa-code me-2" style="color: var(--color-teal);"></i>Queue Implementations</h2>

                        <h3 id="array-queue">Array-Based Queue (Simple)</h3>

<pre><code class="language-python"># Simple Queue Implementation using Python List
# dequeue is O(n) due to list shifting - not efficient!

class SimpleQueue:
    def __init__(self):
        """Initialize empty queue"""
        self.items = []
    
    def enqueue(self, item):
        """Add item to rear - O(1) amortized"""
        self.items.append(item)
    
    def dequeue(self):
        """Remove and return front item - O(n) due to shifting"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items.pop(0)  # This is O(n)!
    
    def front(self):
        """Return front item without removing - O(1)"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items[0]
    
    def is_empty(self):
        """Check if queue is empty - O(1)"""
        return len(self.items) == 0
    
    def size(self):
        """Return number of items - O(1)"""
        return len(self.items)
    
    def __str__(self):
        return f"Queue(front -> {self.items})"

# Test Simple Queue
queue = SimpleQueue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
print(f"Queue: {queue}")           # Queue(front -> [1, 2, 3])
print(f"Front: {queue.front()}")   # 1
print(f"Dequeue: {queue.dequeue()}")  # 1
print(f"Queue: {queue}")           # Queue(front -> [2, 3])
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Simple Queue using std::vector
// dequeue is O(n) due to shifting - not efficient for large queues
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

template &lt;typename T&gt;
class SimpleQueue {
private:
    std::vector&lt;T&gt; items;

public:
    void enqueue(const T&amp; item) {
        items.push_back(item);  // O(1) amortized
    }
    
    T dequeue() {
        if (isEmpty()) {
            throw std::out_of_range("Queue is empty");
        }
        T front = items.front();
        items.erase(items.begin());  // O(n) - shifts all elements
        return front;
    }
    
    T front() const {
        if (isEmpty()) {
            throw std::out_of_range("Queue is empty");
        }
        return items.front();
    }
    
    bool isEmpty() const { return items.empty(); }
    
    size_t size() const { return items.size(); }
    
    void display() const {
        std::cout &lt;&lt; "Queue(front -&gt; ";
        for (const auto&amp; item : items) {
            std::cout &lt;&lt; item &lt;&lt; " ";
        }
        std::cout &lt;&lt; ")" &lt;&lt; std::endl;
    }
};

// Usage
int main() {
    SimpleQueue&lt;int&gt; queue;
    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    queue.display();  // Queue(front -> 1 2 3 )
    
    std::cout &lt;&lt; "Front: " &lt;&lt; queue.front() &lt;&lt; std::endl;  // 1
    std::cout &lt;&lt; "Dequeue: " &lt;&lt; queue.dequeue() &lt;&lt; std::endl;  // 1
    queue.display();  // Queue(front -> 2 3 )
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Simple Queue using ArrayList
// dequeue is O(n) due to shifting - not efficient for large queues
import java.util.ArrayList;
import java.util.NoSuchElementException;

public class SimpleQueue&lt;T&gt; {
    private ArrayList&lt;T&gt; items;
    
    public SimpleQueue() {
        items = new ArrayList&lt;&gt;();
    }
    
    public void enqueue(T item) {
        items.add(item);  // O(1) amortized
    }
    
    public T dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return items.remove(0);  // O(n) - shifts all elements
    }
    
    public T front() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return items.get(0);
    }
    
    public boolean isEmpty() {
        return items.isEmpty();
    }
    
    public int size() {
        return items.size();
    }
    
    @Override
    public String toString() {
        return "Queue(front -> " + items + ")";
    }
    
    public static void main(String[] args) {
        SimpleQueue&lt;Integer&gt; queue = new SimpleQueue&lt;&gt;();
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        System.out.println(queue);  // Queue(front -> [1, 2, 3])
        
        System.out.println("Front: " + queue.front());  // 1
        System.out.println("Dequeue: " + queue.dequeue());  // 1
        System.out.println(queue);  // Queue(front -> [2, 3])
    }
}
</code></pre>

                        <h3 id="linkedlist-queue">Linked List-Based Queue</h3>

<pre><code class="language-python"># Queue Implementation using Linked List
# All operations O(1)

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedListQueue:
    def __init__(self):
        """Initialize empty queue with front and rear pointers"""
        self.front_node = None
        self.rear_node = None
        self._size = 0
    
    def enqueue(self, item):
        """Add item to rear - O(1)"""
        new_node = Node(item)
        
        if self.is_empty():
            self.front_node = new_node
            self.rear_node = new_node
        else:
            self.rear_node.next = new_node
            self.rear_node = new_node
        
        self._size += 1
    
    def dequeue(self):
        """Remove and return front item - O(1)"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        
        item = self.front_node.data
        self.front_node = self.front_node.next
        self._size -= 1
        
        # If queue becomes empty, reset rear
        if self.front_node is None:
            self.rear_node = None
        
        return item
    
    def front(self):
        """Return front item without removing - O(1)"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.front_node.data
    
    def rear(self):
        """Return rear item without removing - O(1)"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.rear_node.data
    
    def is_empty(self):
        return self.front_node is None
    
    def size(self):
        return self._size
    
    def display(self):
        elements = []
        current = self.front_node
        while current:
            elements.append(str(current.data))
            current = current.next
        print("Queue (front -> rear):", " -> ".join(elements))

# Test Linked List Queue
ll_queue = LinkedListQueue()
ll_queue.enqueue(1)
ll_queue.enqueue(2)
ll_queue.enqueue(3)
ll_queue.display()  # Queue (front -> rear): 1 -> 2 -> 3

print(f"Front: {ll_queue.front()}")  # 1
print(f"Rear: {ll_queue.rear()}")    # 3
print(f"Dequeue: {ll_queue.dequeue()}")  # 1
ll_queue.display()  # Queue (front -> rear): 2 -> 3
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Queue Implementation using Linked List
// All operations O(1)
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

template &lt;typename T&gt;
class LinkedListQueue {
private:
    struct Node {
        T data;
        Node* next;
        Node(const T&amp; d) : data(d), next(nullptr) {}
    };
    
    Node* frontNode;
    Node* rearNode;
    size_t _size;

public:
    LinkedListQueue() : frontNode(nullptr), rearNode(nullptr), _size(0) {}
    
    ~LinkedListQueue() {
        while (frontNode) {
            Node* temp = frontNode;
            frontNode = frontNode-&gt;next;
            delete temp;
        }
    }
    
    void enqueue(const T&amp; item) {
        Node* newNode = new Node(item);
        
        if (isEmpty()) {
            frontNode = rearNode = newNode;
        } else {
            rearNode-&gt;next = newNode;
            rearNode = newNode;
        }
        _size++;
    }
    
    T dequeue() {
        if (isEmpty()) {
            throw std::out_of_range("Queue is empty");
        }
        
        Node* temp = frontNode;
        T item = temp-&gt;data;
        frontNode = frontNode-&gt;next;
        delete temp;
        _size--;
        
        if (frontNode == nullptr) {
            rearNode = nullptr;
        }
        return item;
    }
    
    T front() const {
        if (isEmpty()) throw std::out_of_range("Queue is empty");
        return frontNode-&gt;data;
    }
    
    T rear() const {
        if (isEmpty()) throw std::out_of_range("Queue is empty");
        return rearNode-&gt;data;
    }
    
    bool isEmpty() const { return frontNode == nullptr; }
    
    size_t size() const { return _size; }
    
    void display() const {
        std::cout &lt;&lt; "Queue (front -&gt; rear): ";
        Node* current = frontNode;
        while (current) {
            std::cout &lt;&lt; current-&gt;data;
            if (current-&gt;next) std::cout &lt;&lt; " -&gt; ";
            current = current-&gt;next;
        }
        std::cout &lt;&lt; std::endl;
    }
};

// Usage
int main() {
    LinkedListQueue&lt;int&gt; queue;
    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    queue.display();  // Queue (front -> rear): 1 -> 2 -> 3
    
    std::cout &lt;&lt; "Front: " &lt;&lt; queue.front() &lt;&lt; std::endl;  // 1
    std::cout &lt;&lt; "Rear: " &lt;&lt; queue.rear() &lt;&lt; std::endl;    // 3
    std::cout &lt;&lt; "Dequeue: " &lt;&lt; queue.dequeue() &lt;&lt; std::endl;  // 1
    queue.display();  // Queue (front -> rear): 2 -> 3
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Queue Implementation using Linked List
// All operations O(1)

public class LinkedListQueue&lt;T&gt; {
    private class Node {
        T data;
        Node next;
        Node(T data) { this.data = data; }
    }
    
    private Node frontNode;
    private Node rearNode;
    private int size;
    
    public LinkedListQueue() {
        frontNode = null;
        rearNode = null;
        size = 0;
    }
    
    public void enqueue(T item) {
        Node newNode = new Node(item);
        
        if (isEmpty()) {
            frontNode = rearNode = newNode;
        } else {
            rearNode.next = newNode;
            rearNode = newNode;
        }
        size++;
    }
    
    public T dequeue() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException("Queue is empty");
        }
        
        T item = frontNode.data;
        frontNode = frontNode.next;
        size--;
        
        if (frontNode == null) {
            rearNode = null;
        }
        return item;
    }
    
    public T front() {
        if (isEmpty()) throw new java.util.NoSuchElementException("Queue is empty");
        return frontNode.data;
    }
    
    public T rear() {
        if (isEmpty()) throw new java.util.NoSuchElementException("Queue is empty");
        return rearNode.data;
    }
    
    public boolean isEmpty() { return frontNode == null; }
    
    public int size() { return size; }
    
    public void display() {
        StringBuilder sb = new StringBuilder("Queue (front -> rear): ");
        Node current = frontNode;
        while (current != null) {
            sb.append(current.data);
            if (current.next != null) sb.append(" -> ");
            current = current.next;
        }
        System.out.println(sb);
    }
    
    public static void main(String[] args) {
        LinkedListQueue&lt;Integer&gt; queue = new LinkedListQueue&lt;&gt;();
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        queue.display();  // Queue (front -> rear): 1 -> 2 -> 3
        
        System.out.println("Front: " + queue.front());  // 1
        System.out.println("Rear: " + queue.rear());    // 3
        System.out.println("Dequeue: " + queue.dequeue());  // 1
        queue.display();  // Queue (front -> rear): 2 -> 3
    }
}
</code></pre>

                        <!-- Circular Queue -->
                        <h2 id="circular-queue"><i class="fas fa-sync me-2" style="color: var(--color-teal);"></i>Circular Queue</h2>

                        <p>A circular queue (ring buffer) uses a fixed-size array where the rear wraps around to the front, making efficient use of space. Both enqueue and dequeue are O(1).</p>

<pre><code class="language-python"># Circular Queue Implementation
# Fixed-size, efficient O(1) operations

class CircularQueue:
    def __init__(self, capacity):
        """Initialize circular queue with fixed capacity"""
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front_idx = 0
        self.rear_idx = -1
        self._size = 0
    
    def enqueue(self, item):
        """Add item to rear - O(1)"""
        if self.is_full():
            raise OverflowError("Queue is full")
        
        # Move rear circularly
        self.rear_idx = (self.rear_idx + 1) % self.capacity
        self.queue[self.rear_idx] = item
        self._size += 1
    
    def dequeue(self):
        """Remove and return front item - O(1)"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        
        item = self.queue[self.front_idx]
        self.queue[self.front_idx] = None  # Optional: help GC
        
        # Move front circularly
        self.front_idx = (self.front_idx + 1) % self.capacity
        self._size -= 1
        
        return item
    
    def front(self):
        """Return front item - O(1)"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.queue[self.front_idx]
    
    def rear(self):
        """Return rear item - O(1)"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.queue[self.rear_idx]
    
    def is_empty(self):
        return self._size == 0
    
    def is_full(self):
        return self._size == self.capacity
    
    def size(self):
        return self._size
    
    def display(self):
        if self.is_empty():
            print("Queue is empty")
            return
        
        elements = []
        i = self.front_idx
        for _ in range(self._size):
            elements.append(str(self.queue[i]))
            i = (i + 1) % self.capacity
        print("Circular Queue:", " -> ".join(elements))
        print(f"Array state: {self.queue}")

# Test Circular Queue
cq = CircularQueue(5)
for i in range(1, 6):
    cq.enqueue(i * 10)
    
cq.display()  # 10 -> 20 -> 30 -> 40 -> 50

# Dequeue some elements
print(f"Dequeue: {cq.dequeue()}")  # 10
print(f"Dequeue: {cq.dequeue()}")  # 20

# Enqueue wraps around
cq.enqueue(60)
cq.enqueue(70)
cq.display()  # Shows wraparound
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Circular Queue Implementation
// Fixed-size, efficient O(1) operations
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

template &lt;typename T&gt;
class CircularQueue {
private:
    std::vector&lt;T&gt; queue;
    int capacity;
    int frontIdx;
    int rearIdx;
    int _size;

public:
    CircularQueue(int cap) : capacity(cap), frontIdx(0), rearIdx(-1), _size(0) {
        queue.resize(capacity);
    }
    
    void enqueue(const T&amp; item) {
        if (isFull()) {
            throw std::overflow_error("Queue is full");
        }
        rearIdx = (rearIdx + 1) % capacity;
        queue[rearIdx] = item;
        _size++;
    }
    
    T dequeue() {
        if (isEmpty()) {
            throw std::out_of_range("Queue is empty");
        }
        T item = queue[frontIdx];
        frontIdx = (frontIdx + 1) % capacity;
        _size--;
        return item;
    }
    
    T front() const {
        if (isEmpty()) throw std::out_of_range("Queue is empty");
        return queue[frontIdx];
    }
    
    T rear() const {
        if (isEmpty()) throw std::out_of_range("Queue is empty");
        return queue[rearIdx];
    }
    
    bool isEmpty() const { return _size == 0; }
    
    bool isFull() const { return _size == capacity; }
    
    int size() const { return _size; }
    
    void display() const {
        if (isEmpty()) {
            std::cout &lt;&lt; "Queue is empty" &lt;&lt; std::endl;
            return;
        }
        std::cout &lt;&lt; "Circular Queue: ";
        int i = frontIdx;
        for (int count = 0; count &lt; _size; count++) {
            std::cout &lt;&lt; queue[i];
            if (count &lt; _size - 1) std::cout &lt;&lt; " -&gt; ";
            i = (i + 1) % capacity;
        }
        std::cout &lt;&lt; std::endl;
    }
};

int main() {
    CircularQueue&lt;int&gt; cq(5);
    for (int i = 1; i &lt;= 5; i++) cq.enqueue(i * 10);
    cq.display();  // 10 -> 20 -> 30 -> 40 -> 50
    
    std::cout &lt;&lt; "Dequeue: " &lt;&lt; cq.dequeue() &lt;&lt; std::endl;  // 10
    std::cout &lt;&lt; "Dequeue: " &lt;&lt; cq.dequeue() &lt;&lt; std::endl;  // 20
    
    cq.enqueue(60);
    cq.enqueue(70);
    cq.display();  // Shows wraparound
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Circular Queue Implementation
// Fixed-size, efficient O(1) operations

public class CircularQueue&lt;T&gt; {
    private Object[] queue;
    private int capacity;
    private int frontIdx;
    private int rearIdx;
    private int size;
    
    public CircularQueue(int capacity) {
        this.capacity = capacity;
        queue = new Object[capacity];
        frontIdx = 0;
        rearIdx = -1;
        size = 0;
    }
    
    public void enqueue(T item) {
        if (isFull()) {
            throw new IllegalStateException("Queue is full");
        }
        rearIdx = (rearIdx + 1) % capacity;
        queue[rearIdx] = item;
        size++;
    }
    
    @SuppressWarnings("unchecked")
    public T dequeue() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException("Queue is empty");
        }
        T item = (T) queue[frontIdx];
        frontIdx = (frontIdx + 1) % capacity;
        size--;
        return item;
    }
    
    @SuppressWarnings("unchecked")
    public T front() {
        if (isEmpty()) throw new java.util.NoSuchElementException("Queue is empty");
        return (T) queue[frontIdx];
    }
    
    @SuppressWarnings("unchecked")
    public T rear() {
        if (isEmpty()) throw new java.util.NoSuchElementException("Queue is empty");
        return (T) queue[rearIdx];
    }
    
    public boolean isEmpty() { return size == 0; }
    
    public boolean isFull() { return size == capacity; }
    
    public int size() { return size; }
    
    public void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }
        StringBuilder sb = new StringBuilder("Circular Queue: ");
        int i = frontIdx;
        for (int count = 0; count &lt; size; count++) {
            sb.append(queue[i]);
            if (count &lt; size - 1) sb.append(" -> ");
            i = (i + 1) % capacity;
        }
        System.out.println(sb);
    }
    
    public static void main(String[] args) {
        CircularQueue&lt;Integer&gt; cq = new CircularQueue&lt;&gt;(5);
        for (int i = 1; i &lt;= 5; i++) cq.enqueue(i * 10);
        cq.display();  // 10 -> 20 -> 30 -> 40 -> 50
        
        System.out.println("Dequeue: " + cq.dequeue());  // 10
        System.out.println("Dequeue: " + cq.dequeue());  // 20
        
        cq.enqueue(60);
        cq.enqueue(70);
        cq.display();  // Shows wraparound
    }
}
</code></pre>

                        <!-- Deque -->
                        <h2 id="deque"><i class="fas fa-arrows-alt-h me-2" style="color: var(--color-teal);"></i>Deque (Double-Ended Queue)</h2>

                        <p>A deque allows insertion and deletion at both ends, combining the capabilities of both stack and queue.</p>

<pre><code class="language-python"># Deque Implementation using Doubly Linked List
# All operations O(1)

class DequeNode:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

class Deque:
    def __init__(self):
        """Initialize empty deque"""
        self.front_node = None
        self.rear_node = None
        self._size = 0
    
    def add_front(self, item):
        """Add item to front - O(1)"""
        new_node = DequeNode(item)
        
        if self.is_empty():
            self.front_node = new_node
            self.rear_node = new_node
        else:
            new_node.next = self.front_node
            self.front_node.prev = new_node
            self.front_node = new_node
        
        self._size += 1
    
    def add_rear(self, item):
        """Add item to rear - O(1)"""
        new_node = DequeNode(item)
        
        if self.is_empty():
            self.front_node = new_node
            self.rear_node = new_node
        else:
            new_node.prev = self.rear_node
            self.rear_node.next = new_node
            self.rear_node = new_node
        
        self._size += 1
    
    def remove_front(self):
        """Remove and return front item - O(1)"""
        if self.is_empty():
            raise IndexError("Deque is empty")
        
        item = self.front_node.data
        self.front_node = self.front_node.next
        
        if self.front_node:
            self.front_node.prev = None
        else:
            self.rear_node = None
        
        self._size -= 1
        return item
    
    def remove_rear(self):
        """Remove and return rear item - O(1)"""
        if self.is_empty():
            raise IndexError("Deque is empty")
        
        item = self.rear_node.data
        self.rear_node = self.rear_node.prev
        
        if self.rear_node:
            self.rear_node.next = None
        else:
            self.front_node = None
        
        self._size -= 1
        return item
    
    def peek_front(self):
        if self.is_empty():
            raise IndexError("Deque is empty")
        return self.front_node.data
    
    def peek_rear(self):
        if self.is_empty():
            raise IndexError("Deque is empty")
        return self.rear_node.data
    
    def is_empty(self):
        return self.front_node is None
    
    def size(self):
        return self._size
    
    def display(self):
        elements = []
        current = self.front_node
        while current:
            elements.append(str(current.data))
            current = current.next
        print("Deque:", " <-> ".join(elements))

# Test Deque
deque = Deque()
deque.add_rear(1)
deque.add_rear(2)
deque.add_front(0)
deque.add_rear(3)
deque.display()  # Deque: 0 <-> 1 <-> 2 <-> 3

print(f"Remove front: {deque.remove_front()}")  # 0
print(f"Remove rear: {deque.remove_rear()}")    # 3
deque.display()  # Deque: 1 <-> 2
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Deque Implementation using Doubly Linked List
// All operations O(1)
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

template &lt;typename T&gt;
class Deque {
private:
    struct Node {
        T data;
        Node* prev;
        Node* next;
        Node(const T&amp; d) : data(d), prev(nullptr), next(nullptr) {}
    };
    
    Node* frontNode;
    Node* rearNode;
    size_t _size;

public:
    Deque() : frontNode(nullptr), rearNode(nullptr), _size(0) {}
    
    ~Deque() {
        while (frontNode) {
            Node* temp = frontNode;
            frontNode = frontNode-&gt;next;
            delete temp;
        }
    }
    
    void addFront(const T&amp; item) {
        Node* newNode = new Node(item);
        if (isEmpty()) {
            frontNode = rearNode = newNode;
        } else {
            newNode-&gt;next = frontNode;
            frontNode-&gt;prev = newNode;
            frontNode = newNode;
        }
        _size++;
    }
    
    void addRear(const T&amp; item) {
        Node* newNode = new Node(item);
        if (isEmpty()) {
            frontNode = rearNode = newNode;
        } else {
            newNode-&gt;prev = rearNode;
            rearNode-&gt;next = newNode;
            rearNode = newNode;
        }
        _size++;
    }
    
    T removeFront() {
        if (isEmpty()) throw std::out_of_range("Deque is empty");
        Node* temp = frontNode;
        T item = temp-&gt;data;
        frontNode = frontNode-&gt;next;
        if (frontNode) frontNode-&gt;prev = nullptr;
        else rearNode = nullptr;
        delete temp;
        _size--;
        return item;
    }
    
    T removeRear() {
        if (isEmpty()) throw std::out_of_range("Deque is empty");
        Node* temp = rearNode;
        T item = temp-&gt;data;
        rearNode = rearNode-&gt;prev;
        if (rearNode) rearNode-&gt;next = nullptr;
        else frontNode = nullptr;
        delete temp;
        _size--;
        return item;
    }
    
    T peekFront() const {
        if (isEmpty()) throw std::out_of_range("Deque is empty");
        return frontNode-&gt;data;
    }
    
    T peekRear() const {
        if (isEmpty()) throw std::out_of_range("Deque is empty");
        return rearNode-&gt;data;
    }
    
    bool isEmpty() const { return frontNode == nullptr; }
    size_t size() const { return _size; }
    
    void display() const {
        std::cout &lt;&lt; "Deque: ";
        Node* current = frontNode;
        while (current) {
            std::cout &lt;&lt; current-&gt;data;
            if (current-&gt;next) std::cout &lt;&lt; " &lt;-&gt; ";
            current = current-&gt;next;
        }
        std::cout &lt;&lt; std::endl;
    }
};

int main() {
    Deque&lt;int&gt; deque;
    deque.addRear(1);
    deque.addRear(2);
    deque.addFront(0);
    deque.addRear(3);
    deque.display();  // Deque: 0 <-> 1 <-> 2 <-> 3
    
    std::cout &lt;&lt; "Remove front: " &lt;&lt; deque.removeFront() &lt;&lt; std::endl;  // 0
    std::cout &lt;&lt; "Remove rear: " &lt;&lt; deque.removeRear() &lt;&lt; std::endl;    // 3
    deque.display();  // Deque: 1 <-> 2
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Deque Implementation using Doubly Linked List
// All operations O(1)

public class Deque&lt;T&gt; {
    private class Node {
        T data;
        Node prev, next;
        Node(T data) { this.data = data; }
    }
    
    private Node frontNode, rearNode;
    private int size;
    
    public void addFront(T item) {
        Node newNode = new Node(item);
        if (isEmpty()) {
            frontNode = rearNode = newNode;
        } else {
            newNode.next = frontNode;
            frontNode.prev = newNode;
            frontNode = newNode;
        }
        size++;
    }
    
    public void addRear(T item) {
        Node newNode = new Node(item);
        if (isEmpty()) {
            frontNode = rearNode = newNode;
        } else {
            newNode.prev = rearNode;
            rearNode.next = newNode;
            rearNode = newNode;
        }
        size++;
    }
    
    public T removeFront() {
        if (isEmpty()) throw new java.util.NoSuchElementException("Deque is empty");
        T item = frontNode.data;
        frontNode = frontNode.next;
        if (frontNode != null) frontNode.prev = null;
        else rearNode = null;
        size--;
        return item;
    }
    
    public T removeRear() {
        if (isEmpty()) throw new java.util.NoSuchElementException("Deque is empty");
        T item = rearNode.data;
        rearNode = rearNode.prev;
        if (rearNode != null) rearNode.next = null;
        else frontNode = null;
        size--;
        return item;
    }
    
    public T peekFront() {
        if (isEmpty()) throw new java.util.NoSuchElementException("Deque is empty");
        return frontNode.data;
    }
    
    public T peekRear() {
        if (isEmpty()) throw new java.util.NoSuchElementException("Deque is empty");
        return rearNode.data;
    }
    
    public boolean isEmpty() { return frontNode == null; }
    public int size() { return size; }
    
    public void display() {
        StringBuilder sb = new StringBuilder("Deque: ");
        Node current = frontNode;
        while (current != null) {
            sb.append(current.data);
            if (current.next != null) sb.append(" <-> ");
            current = current.next;
        }
        System.out.println(sb);
    }
    
    public static void main(String[] args) {
        Deque&lt;Integer&gt; deque = new Deque&lt;&gt;();
        deque.addRear(1);
        deque.addRear(2);
        deque.addFront(0);
        deque.addRear(3);
        deque.display();  // Deque: 0 <-> 1 <-> 2 <-> 3
        
        System.out.println("Remove front: " + deque.removeFront());  // 0
        System.out.println("Remove rear: " + deque.removeRear());    // 3
        deque.display();  // Deque: 1 <-> 2
    }
}
</code></pre>

<pre><code class="language-python"># Python's collections.deque - Highly optimized implementation
from collections import deque

# Create deque
d = deque([1, 2, 3])

# Add to both ends
d.append(4)        # Add to right
d.appendleft(0)    # Add to left
print(d)  # deque([0, 1, 2, 3, 4])

# Remove from both ends
d.pop()            # Remove from right
d.popleft()        # Remove from left
print(d)  # deque([1, 2, 3])

# Rotation
d = deque([1, 2, 3, 4, 5])
d.rotate(2)   # Rotate right by 2
print(d)  # deque([4, 5, 1, 2, 3])

d.rotate(-2)  # Rotate left by 2
print(d)  # deque([1, 2, 3, 4, 5])

# Max length deque (automatically removes from opposite end)
bounded = deque(maxlen=3)
bounded.extend([1, 2, 3])
bounded.append(4)  # 1 is automatically removed
print(bounded)  # deque([2, 3, 4], maxlen=3)
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// C++ std::deque - Highly optimized double-ended queue
#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;

int main() {
    std::deque&lt;int&gt; d = {1, 2, 3};
    
    // Add to both ends
    d.push_back(4);      // Add to right
    d.push_front(0);     // Add to left
    // d = {0, 1, 2, 3, 4}
    
    // Remove from both ends
    d.pop_back();        // Remove from right
    d.pop_front();       // Remove from left
    // d = {1, 2, 3}
    
    // Access elements
    std::cout &lt;&lt; "Front: " &lt;&lt; d.front() &lt;&lt; std::endl;  // 1
    std::cout &lt;&lt; "Back: " &lt;&lt; d.back() &lt;&lt; std::endl;    // 3
    std::cout &lt;&lt; "Index 1: " &lt;&lt; d[1] &lt;&lt; std::endl;     // 2
    
    // Rotation using std::rotate
    d = {1, 2, 3, 4, 5};
    std::rotate(d.begin(), d.begin() + 2, d.end());  // Rotate left by 2
    // d = {3, 4, 5, 1, 2}
    
    // Print deque
    for (int val : d) std::cout &lt;&lt; val &lt;&lt; " ";
    std::cout &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Java's ArrayDeque - Highly optimized double-ended queue
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Collections;
import java.util.LinkedList;

public class DequeDemo {
    public static void main(String[] args) {
        Deque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;();
        d.add(1); d.add(2); d.add(3);  // d = [1, 2, 3]
        
        // Add to both ends
        d.addLast(4);      // Add to right
        d.addFirst(0);     // Add to left
        // d = [0, 1, 2, 3, 4]
        
        // Remove from both ends
        d.pollLast();      // Remove from right
        d.pollFirst();     // Remove from left
        // d = [1, 2, 3]
        
        // Access elements
        System.out.println("First: " + d.peekFirst());  // 1
        System.out.println("Last: " + d.peekLast());    // 3
        
        // Rotation using Collections (with LinkedList)
        LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        list.add(1); list.add(2); list.add(3); list.add(4); list.add(5);
        
        Collections.rotate(list, 2);  // Rotate right by 2
        System.out.println(list);  // [4, 5, 1, 2, 3]
        
        Collections.rotate(list, -2); // Rotate left by 2
        System.out.println(list);  // [1, 2, 3, 4, 5]
        
        // Print deque
        for (int val : d) System.out.print(val + " ");
        System.out.println();
    }
}
</code></pre>

                        <!-- Priority Queue -->
                        <h2 id="priority-queue"><i class="fas fa-sort-amount-up me-2" style="color: var(--color-teal);"></i>Priority Queue</h2>

                        <p>A priority queue serves elements based on their priority rather than insertion order. Typically implemented using a heap.</p>

<pre><code class="language-python"># Priority Queue using Python's heapq (Min-Heap)
import heapq

# Simple priority queue with heapq
class PriorityQueue:
    def __init__(self):
        self._heap = []
        self._index = 0  # For stable sorting of same priority
    
    def push(self, item, priority):
        """Add item with priority (lower priority = higher importance)"""
        heapq.heappush(self._heap, (priority, self._index, item))
        self._index += 1
    
    def pop(self):
        """Remove and return highest priority item"""
        if self.is_empty():
            raise IndexError("Priority queue is empty")
        return heapq.heappop(self._heap)[2]
    
    def peek(self):
        """Return highest priority item without removing"""
        if self.is_empty():
            raise IndexError("Priority queue is empty")
        return self._heap[0][2]
    
    def is_empty(self):
        return len(self._heap) == 0
    
    def size(self):
        return len(self._heap)

# Test Priority Queue
pq = PriorityQueue()
pq.push("Task C", 3)  # Low priority
pq.push("Task A", 1)  # High priority
pq.push("Task B", 2)  # Medium priority
pq.push("Task D", 1)  # Same high priority as Task A

# Pop in priority order
while not pq.is_empty():
    print(f"Processing: {pq.pop()}")
# Task A, Task D, Task B, Task C (ordered by priority, FIFO for same priority)
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Priority Queue using std::priority_queue (Max-Heap by default)
// For Min-Heap, use greater&lt;&gt; comparator
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

int main() {
    // Min-Heap Priority Queue with (priority, index, item)
    // Use greater&lt;&gt; for min-heap behavior
    using PQItem = std::tuple&lt;int, int, std::string&gt;;
    std::priority_queue&lt;PQItem, std::vector&lt;PQItem&gt;, std::greater&lt;PQItem&gt;&gt; pq;
    
    int index = 0;
    pq.push({3, index++, "Task C"});  // Low priority
    pq.push({1, index++, "Task A"});  // High priority
    pq.push({2, index++, "Task B"});  // Medium priority
    pq.push({1, index++, "Task D"});  // Same high priority as Task A
    
    // Pop in priority order
    while (!pq.empty()) {
        auto [priority, idx, item] = pq.top();
        pq.pop();
        std::cout &lt;&lt; "Processing: " &lt;&lt; item &lt;&lt; std::endl;
    }
    // Task A, Task D, Task B, Task C (ordered by priority, FIFO for same priority)
    
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Priority Queue using PriorityQueue (Min-Heap by default)
import java.util.PriorityQueue;
import java.util.Comparator;

public class PriorityQueueDemo {
    static class Task {
        String name;
        int priority;
        int index;  // For FIFO ordering of same priority
        
        Task(String name, int priority, int index) {
            this.name = name;
            this.priority = priority;
            this.index = index;
        }
    }
    
    public static void main(String[] args) {
        // Min-Heap: lower priority value = higher importance
        PriorityQueue&lt;Task&gt; pq = new PriorityQueue&lt;&gt;(
            Comparator.comparingInt((Task t) -&gt; t.priority)
                      .thenComparingInt(t -&gt; t.index)  // FIFO for same priority
        );
        
        int index = 0;
        pq.offer(new Task("Task C", 3, index++));  // Low priority
        pq.offer(new Task("Task A", 1, index++));  // High priority
        pq.offer(new Task("Task B", 2, index++));  // Medium priority
        pq.offer(new Task("Task D", 1, index++));  // Same high priority as Task A
        
        // Pop in priority order
        while (!pq.isEmpty()) {
            Task task = pq.poll();
            System.out.println("Processing: " + task.name);
        }
        // Task A, Task D, Task B, Task C (ordered by priority, FIFO for same priority)
    }
}
</code></pre>

<pre><code class="language-python"># Max-Heap Priority Queue (negate priorities)
import heapq

class MaxPriorityQueue:
    def __init__(self):
        self._heap = []
    
    def push(self, item, priority):
        """Add item with priority (higher priority = more important)"""
        heapq.heappush(self._heap, (-priority, item))
    
    def pop(self):
        """Remove and return highest priority item"""
        if not self._heap:
            raise IndexError("Empty")
        return heapq.heappop(self._heap)[1]
    
    def peek(self):
        return self._heap[0][1] if self._heap else None

# Test Max Priority Queue
max_pq = MaxPriorityQueue()
max_pq.push("Low", 1)
max_pq.push("High", 10)
max_pq.push("Medium", 5)

print(max_pq.pop())  # High
print(max_pq.pop())  # Medium
print(max_pq.pop())  # Low
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Max-Heap Priority Queue (default behavior in C++)
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;string&gt;

int main() {
    // Max-Heap: higher priority = higher importance (default)
    std::priority_queue&lt;std::pair&lt;int, std::string&gt;&gt; maxPQ;
    
    maxPQ.push({1, "Low"});
    maxPQ.push({10, "High"});
    maxPQ.push({5, "Medium"});
    
    while (!maxPQ.empty()) {
        auto [priority, item] = maxPQ.top();
        maxPQ.pop();
        std::cout &lt;&lt; item &lt;&lt; std::endl;
    }
    // High, Medium, Low
    
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Max-Heap Priority Queue (use reverseOrder comparator)
import java.util.PriorityQueue;
import java.util.Collections;
import java.util.Comparator;

public class MaxPriorityQueueDemo {
    public static void main(String[] args) {
        // Max-Heap: use reverseOrder or custom comparator
        PriorityQueue&lt;int[]&gt; maxPQ = new PriorityQueue&lt;&gt;(
            (a, b) -&gt; b[0] - a[0]  // Compare by priority descending
        );
        
        maxPQ.offer(new int[]{1, 0});   // {priority, index for "Low"}
        maxPQ.offer(new int[]{10, 1});  // {priority, index for "High"}
        maxPQ.offer(new int[]{5, 2});   // {priority, index for "Medium"}
        
        String[] items = {"Low", "High", "Medium"};
        
        while (!maxPQ.isEmpty()) {
            int[] entry = maxPQ.poll();
            System.out.println(items[entry[1]]);
        }
        // High, Medium, Low
        
        // Alternative: Simple max-heap for integers
        PriorityQueue&lt;Integer&gt; maxInts = new PriorityQueue&lt;&gt;(Collections.reverseOrder());
        maxInts.offer(1);
        maxInts.offer(10);
        maxInts.offer(5);
        
        while (!maxInts.isEmpty()) {
            System.out.print(maxInts.poll() + " ");  // 10 5 1
        }
        System.out.println();
    }
}
</code></pre>

                        <!-- Applications -->
                        <h2 id="applications"><i class="fas fa-tools me-2" style="color: var(--color-teal);"></i>Queue Applications</h2>

                        <h3 id="bfs">Breadth-First Search (BFS)</h3>

<pre><code class="language-python"># BFS - Classic Queue Application
from collections import deque

def bfs_graph(graph, start):
    """
    Breadth-First Search on a graph.
    Time: O(V + E), Space: O(V)
    """
    visited = set()
    queue = deque([start])
    visited.add(start)
    traversal = []
    
    while queue:
        node = queue.popleft()
        traversal.append(node)
        
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return traversal

# Test BFS
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

print("BFS traversal:", bfs_graph(graph, 'A'))
# ['A', 'B', 'C', 'D', 'E', 'F']
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// BFS - Classic Queue Application
// Time: O(V + E), Space: O(V)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;string&gt;

std::vector&lt;std::string&gt; bfsGraph(
    const std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt;&amp; graph,
    const std::string&amp; start
) {
    std::unordered_set&lt;std::string&gt; visited;
    std::queue&lt;std::string&gt; q;
    std::vector&lt;std::string&gt; traversal;
    
    q.push(start);
    visited.insert(start);
    
    while (!q.empty()) {
        std::string node = q.front();
        q.pop();
        traversal.push_back(node);
        
        if (graph.find(node) != graph.end()) {
            for (const auto&amp; neighbor : graph.at(node)) {
                if (visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    q.push(neighbor);
                }
            }
        }
    }
    return traversal;
}

int main() {
    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; graph = {
        {"A", {"B", "C"}},
        {"B", {"A", "D", "E"}},
        {"C", {"A", "F"}},
        {"D", {"B"}},
        {"E", {"B", "F"}},
        {"F", {"C", "E"}}
    };
    
    std::cout &lt;&lt; "BFS traversal: ";
    for (const auto&amp; node : bfsGraph(graph, "A")) {
        std::cout &lt;&lt; node &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;  // A B C D E F
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// BFS - Classic Queue Application
// Time: O(V + E), Space: O(V)
import java.util.*;

public class BFSGraph {
    public static List&lt;String&gt; bfsGraph(
        Map&lt;String, List&lt;String&gt;&gt; graph, String start
    ) {
        Set&lt;String&gt; visited = new HashSet&lt;&gt;();
        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();
        List&lt;String&gt; traversal = new ArrayList&lt;&gt;();
        
        queue.offer(start);
        visited.add(start);
        
        while (!queue.isEmpty()) {
            String node = queue.poll();
            traversal.add(node);
            
            for (String neighbor : graph.getOrDefault(node, List.of())) {
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    queue.offer(neighbor);
                }
            }
        }
        return traversal;
    }
    
    public static void main(String[] args) {
        Map&lt;String, List&lt;String&gt;&gt; graph = new HashMap&lt;&gt;();
        graph.put("A", Arrays.asList("B", "C"));
        graph.put("B", Arrays.asList("A", "D", "E"));
        graph.put("C", Arrays.asList("A", "F"));
        graph.put("D", Arrays.asList("B"));
        graph.put("E", Arrays.asList("B", "F"));
        graph.put("F", Arrays.asList("C", "E"));
        
        System.out.println("BFS traversal: " + bfsGraph(graph, "A"));
        // [A, B, C, D, E, F]
    }
}
</code></pre>

<pre><code class="language-python"># Level Order Traversal of Binary Tree
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def level_order_traversal(root):
    """
    Level-order traversal using queue.
    Time: O(n), Space: O(n)
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level)
    
    return result

# Test
#       1
#      / \
#     2   3
#    / \   \
#   4   5   6
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.right = TreeNode(6)

print("Level Order:", level_order_traversal(root))
# [[1], [2, 3], [4, 5, 6]]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Level Order Traversal of Binary Tree
// Time: O(n), Space: O(n)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

std::vector&lt;std::vector&lt;int&gt;&gt; levelOrderTraversal(TreeNode* root) {
    std::vector&lt;std::vector&lt;int&gt;&gt; result;
    if (!root) return result;
    
    std::queue&lt;TreeNode*&gt; q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        std::vector&lt;int&gt; level;
        
        for (int i = 0; i &lt; levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            level.push_back(node-&gt;val);
            
            if (node-&gt;left) q.push(node-&gt;left);
            if (node-&gt;right) q.push(node-&gt;right);
        }
        result.push_back(level);
    }
    return result;
}

int main() {
    //       1
    //      / \
    //     2   3
    //    / \   \
    //   4   5   6
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;left-&gt;left = new TreeNode(4);
    root-&gt;left-&gt;right = new TreeNode(5);
    root-&gt;right-&gt;right = new TreeNode(6);
    
    std::cout &lt;&lt; "Level Order: ";
    auto result = levelOrderTraversal(root);
    for (const auto&amp; level : result) {
        std::cout &lt;&lt; "[";
        for (int i = 0; i &lt; level.size(); i++) {
            std::cout &lt;&lt; level[i];
            if (i &lt; level.size() - 1) std::cout &lt;&lt; ", ";
        }
        std::cout &lt;&lt; "] ";
    }
    std::cout &lt;&lt; std::endl;  // [1] [2, 3] [4, 5, 6]
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Level Order Traversal of Binary Tree
// Time: O(n), Space: O(n)
import java.util.*;

public class LevelOrderTraversal {
    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) { this.val = val; }
    }
    
    public static List&lt;List&lt;Integer&gt;&gt; levelOrderTraversal(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null) return result;
        
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();
            
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            result.add(level);
        }
        return result;
    }
    
    public static void main(String[] args) {
        //       1
        //      / \
        //     2   3
        //    / \   \
        //   4   5   6
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.right = new TreeNode(6);
        
        System.out.println("Level Order: " + levelOrderTraversal(root));
        // [[1], [2, 3], [4, 5, 6]]
    }
}
</code></pre>

                        <h3 id="sliding-window">Sliding Window Maximum (Monotonic Deque)</h3>

<pre><code class="language-python"># Sliding Window Maximum using Monotonic Deque
from collections import deque

def max_sliding_window(nums, k):
    """
    Find maximum in each sliding window of size k.
    Uses monotonic decreasing deque.
    Time: O(n), Space: O(k)
    """
    if not nums or k == 0:
        return []
    
    deq = deque()  # Stores indices, values in decreasing order
    result = []
    
    for i in range(len(nums)):
        # Remove indices outside window
        while deq and deq[0] < i - k + 1:
            deq.popleft()
        
        # Remove smaller elements from back (maintain decreasing order)
        while deq and nums[deq[-1]] < nums[i]:
            deq.pop()
        
        deq.append(i)
        
        # Add to result once window is of size k
        if i >= k - 1:
            result.append(nums[deq[0]])
    
    return result

# Test
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(f"nums = {nums}, k = {k}")
print(f"Max in each window: {max_sliding_window(nums, k)}")
# [3, 3, 5, 5, 6, 7]

# Explanation:
# Window [1, 3, -1] max=3
# Window [3, -1, -3] max=3
# Window [-1, -3, 5] max=5
# Window [-3, 5, 3] max=5
# Window [5, 3, 6] max=6
# Window [3, 6, 7] max=7
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Sliding Window Maximum using Monotonic Deque
// Time: O(n), Space: O(k)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;

std::vector&lt;int&gt; maxSlidingWindow(const std::vector&lt;int&gt;&amp; nums, int k) {
    std::vector&lt;int&gt; result;
    if (nums.empty() || k == 0) return result;
    
    std::deque&lt;int&gt; dq;  // Stores indices, values in decreasing order
    
    for (int i = 0; i &lt; nums.size(); i++) {
        // Remove indices outside window
        while (!dq.empty() &amp;&amp; dq.front() &lt; i - k + 1) {
            dq.pop_front();
        }
        
        // Remove smaller elements from back (maintain decreasing order)
        while (!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        // Add to result once window is of size k
        if (i &gt;= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    return result;
}

int main() {
    std::vector&lt;int&gt; nums = {1, 3, -1, -3, 5, 3, 6, 7};
    int k = 3;
    
    std::cout &lt;&lt; "nums = [";
    for (int i = 0; i &lt; nums.size(); i++) {
        std::cout &lt;&lt; nums[i] &lt;&lt; (i &lt; nums.size() - 1 ? ", " : "");
    }
    std::cout &lt;&lt; "], k = " &lt;&lt; k &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "Max in each window: ";
    for (int val : maxSlidingWindow(nums, k)) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;  // 3 3 5 5 6 7
    return 0;
}
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Sliding Window Maximum using Monotonic Deque
// Time: O(n), Space: O(k)
import java.util.*;

public class SlidingWindowMax {
    public static int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0 || k == 0) {
            return new int[0];
        }
        
        int n = nums.length;
        int[] result = new int[n - k + 1];
        Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();  // Stores indices
        
        for (int i = 0; i &lt; n; i++) {
            // Remove indices outside window
            while (!dq.isEmpty() &amp;&amp; dq.peekFirst() &lt; i - k + 1) {
                dq.pollFirst();
            }
            
            // Remove smaller elements from back (maintain decreasing order)
            while (!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt; nums[i]) {
                dq.pollLast();
            }
            
            dq.offerLast(i);
            
            // Add to result once window is of size k
            if (i &gt;= k - 1) {
                result[i - k + 1] = nums[dq.peekFirst()];
            }
        }
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 3, -1, -3, 5, 3, 6, 7};
        int k = 3;
        
        System.out.println("nums = " + Arrays.toString(nums) + ", k = " + k);
        System.out.println("Max in each window: " + 
            Arrays.toString(maxSlidingWindow(nums, k)));
        // [3, 3, 5, 5, 6, 7]
    }
}
</code></pre>

                        <!-- LeetCode -->
                        <h2 id="leetcode"><i class="fas fa-laptop-code me-2" style="color: var(--color-teal);"></i>LeetCode Practice Problems</h2>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 232. Implement Queue using Stacks</h4>
                            <p>Implement a FIFO queue using only two stacks.</p>
<pre><code class="language-python"># LeetCode 232 - Implement Queue using Stacks
# Amortized O(1) for all operations

class MyQueue:
    def __init__(self):
        self.stack_in = []   # For enqueue
        self.stack_out = []  # For dequeue
    
    def push(self, x):
        """Add to rear - O(1)"""
        self.stack_in.append(x)
    
    def pop(self):
        """Remove from front - Amortized O(1)"""
        self._transfer()
        return self.stack_out.pop()
    
    def peek(self):
        """Get front - Amortized O(1)"""
        self._transfer()
        return self.stack_out[-1]
    
    def empty(self):
        return not self.stack_in and not self.stack_out
    
    def _transfer(self):
        """Move elements from stack_in to stack_out"""
        if not self.stack_out:
            while self.stack_in:
                self.stack_out.append(self.stack_in.pop())

# Test
queue = MyQueue()
queue.push(1)
queue.push(2)
print(queue.peek())   # 1
print(queue.pop())    # 1
print(queue.empty())  # False
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 232 - Implement Queue using Stacks
// Amortized O(1) for all operations
#include &lt;stack&gt;

class MyQueue {
private:
    std::stack&lt;int&gt; stackIn;   // For enqueue
    std::stack&lt;int&gt; stackOut;  // For dequeue
    
    void transfer() {
        if (stackOut.empty()) {
            while (!stackIn.empty()) {
                stackOut.push(stackIn.top());
                stackIn.pop();
            }
        }
    }

public:
    void push(int x) {
        stackIn.push(x);  // O(1)
    }
    
    int pop() {
        transfer();  // Amortized O(1)
        int val = stackOut.top();
        stackOut.pop();
        return val;
    }
    
    int peek() {
        transfer();  // Amortized O(1)
        return stackOut.top();
    }
    
    bool empty() {
        return stackIn.empty() &amp;&amp; stackOut.empty();
    }
};

// Usage:
// MyQueue queue;
// queue.push(1); queue.push(2);
// queue.peek();  // 1
// queue.pop();   // 1
// queue.empty(); // false
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 232 - Implement Queue using Stacks
// Amortized O(1) for all operations
import java.util.Stack;

class MyQueue {
    private Stack&lt;Integer&gt; stackIn;   // For enqueue
    private Stack&lt;Integer&gt; stackOut;  // For dequeue
    
    public MyQueue() {
        stackIn = new Stack&lt;&gt;();
        stackOut = new Stack&lt;&gt;();
    }
    
    private void transfer() {
        if (stackOut.isEmpty()) {
            while (!stackIn.isEmpty()) {
                stackOut.push(stackIn.pop());
            }
        }
    }
    
    public void push(int x) {
        stackIn.push(x);  // O(1)
    }
    
    public int pop() {
        transfer();  // Amortized O(1)
        return stackOut.pop();
    }
    
    public int peek() {
        transfer();  // Amortized O(1)
        return stackOut.peek();
    }
    
    public boolean empty() {
        return stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();
    }
}

// Usage:
// MyQueue queue = new MyQueue();
// queue.push(1); queue.push(2);
// queue.peek();  // 1
// queue.pop();   // 1
// queue.empty(); // false
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 622. Design Circular Queue</h4>
                            <p>Design a circular queue implementation.</p>
<pre><code class="language-python"># LeetCode 622 - Design Circular Queue
# All operations O(1)

class MyCircularQueue:
    def __init__(self, k):
        self.queue = [None] * k
        self.capacity = k
        self.size = 0
        self.front = 0
        self.rear = -1
    
    def enQueue(self, value):
        if self.isFull():
            return False
        self.rear = (self.rear + 1) % self.capacity
        self.queue[self.rear] = value
        self.size += 1
        return True
    
    def deQueue(self):
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        self.size -= 1
        return True
    
    def Front(self):
        return -1 if self.isEmpty() else self.queue[self.front]
    
    def Rear(self):
        return -1 if self.isEmpty() else self.queue[self.rear]
    
    def isEmpty(self):
        return self.size == 0
    
    def isFull(self):
        return self.size == self.capacity

# Test
cq = MyCircularQueue(3)
print(cq.enQueue(1))  # True
print(cq.enQueue(2))  # True
print(cq.enQueue(3))  # True
print(cq.enQueue(4))  # False (full)
print(cq.Rear())      # 3
print(cq.isFull())    # True
print(cq.deQueue())   # True
print(cq.enQueue(4))  # True
print(cq.Rear())      # 4
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 622 - Design Circular Queue
// All operations O(1)
#include &lt;vector&gt;

class MyCircularQueue {
private:
    std::vector&lt;int&gt; queue;
    int capacity;
    int size;
    int front;
    int rear;

public:
    MyCircularQueue(int k) : capacity(k), size(0), front(0), rear(-1) {
        queue.resize(k);
    }
    
    bool enQueue(int value) {
        if (isFull()) return false;
        rear = (rear + 1) % capacity;
        queue[rear] = value;
        size++;
        return true;
    }
    
    bool deQueue() {
        if (isEmpty()) return false;
        front = (front + 1) % capacity;
        size--;
        return true;
    }
    
    int Front() {
        return isEmpty() ? -1 : queue[front];
    }
    
    int Rear() {
        return isEmpty() ? -1 : queue[rear];
    }
    
    bool isEmpty() {
        return size == 0;
    }
    
    bool isFull() {
        return size == capacity;
    }
};

// Usage:
// MyCircularQueue cq(3);
// cq.enQueue(1);  // true
// cq.enQueue(2);  // true
// cq.enQueue(3);  // true
// cq.enQueue(4);  // false (full)
// cq.Rear();      // 3
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 622 - Design Circular Queue
// All operations O(1)

class MyCircularQueue {
    private int[] queue;
    private int capacity;
    private int size;
    private int front;
    private int rear;
    
    public MyCircularQueue(int k) {
        capacity = k;
        queue = new int[k];
        size = 0;
        front = 0;
        rear = -1;
    }
    
    public boolean enQueue(int value) {
        if (isFull()) return false;
        rear = (rear + 1) % capacity;
        queue[rear] = value;
        size++;
        return true;
    }
    
    public boolean deQueue() {
        if (isEmpty()) return false;
        front = (front + 1) % capacity;
        size--;
        return true;
    }
    
    public int Front() {
        return isEmpty() ? -1 : queue[front];
    }
    
    public int Rear() {
        return isEmpty() ? -1 : queue[rear];
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}

// Usage:
// MyCircularQueue cq = new MyCircularQueue(3);
// cq.enQueue(1);  // true
// cq.enQueue(2);  // true
// cq.enQueue(3);  // true
// cq.enQueue(4);  // false (full)
// cq.Rear();      // 3
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 102. Binary Tree Level Order Traversal</h4>
                            <p>Return the level order traversal of a binary tree.</p>
<pre><code class="language-python"># LeetCode 102 - Binary Tree Level Order Traversal
# Time: O(n), Space: O(n)
from collections import deque

def levelOrder(root):
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level)
    
    return result
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 102 - Binary Tree Level Order Traversal
// Time: O(n), Space: O(n)
#include &lt;vector&gt;
#include &lt;queue&gt;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    std::vector&lt;std::vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        std::vector&lt;std::vector&lt;int&gt;&gt; result;
        if (!root) return result;
        
        std::queue&lt;TreeNode*&gt; q;
        q.push(root);
        
        while (!q.empty()) {
            int levelSize = q.size();
            std::vector&lt;int&gt; level;
            
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode* node = q.front();
                q.pop();
                level.push_back(node-&gt;val);
                
                if (node-&gt;left) q.push(node-&gt;left);
                if (node-&gt;right) q.push(node-&gt;right);
            }
            result.push_back(level);
        }
        return result;
    }
};
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 102 - Binary Tree Level Order Traversal
// Time: O(n), Space: O(n)
import java.util.*;

class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null) return result;
        
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();
            
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            result.add(level);
        }
        return result;
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-hard">Hard</span> 239. Sliding Window Maximum</h4>
                            <p>Find the maximum in each sliding window.</p>
<pre><code class="language-python"># LeetCode 239 - Sliding Window Maximum
# Time: O(n), Space: O(k)
from collections import deque

def maxSlidingWindow(nums, k):
    if not nums:
        return []
    
    deq = deque()  # Indices with decreasing values
    result = []
    
    for i, num in enumerate(nums):
        # Remove indices outside window
        while deq and deq[0] < i - k + 1:
            deq.popleft()
        
        # Remove smaller elements
        while deq and nums[deq[-1]] < num:
            deq.pop()
        
        deq.append(i)
        
        # Add max when window is complete
        if i >= k - 1:
            result.append(nums[deq[0]])
    
    return result

# Test
print(maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3))
# [3, 3, 5, 5, 6, 7]
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 239 - Sliding Window Maximum
// Time: O(n), Space: O(k)
#include &lt;vector&gt;
#include &lt;deque&gt;

class Solution {
public:
    std::vector&lt;int&gt; maxSlidingWindow(std::vector&lt;int&gt;&amp; nums, int k) {
        std::vector&lt;int&gt; result;
        std::deque&lt;int&gt; dq;  // Indices with decreasing values
        
        for (int i = 0; i &lt; nums.size(); i++) {
            // Remove indices outside window
            while (!dq.empty() &amp;&amp; dq.front() &lt; i - k + 1) {
                dq.pop_front();
            }
            
            // Remove smaller elements
            while (!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) {
                dq.pop_back();
            }
            
            dq.push_back(i);
            
            // Add max when window is complete
            if (i &gt;= k - 1) {
                result.push_back(nums[dq.front()]);
            }
        }
        return result;
    }
};

// Test: maxSlidingWindow({1,3,-1,-3,5,3,6,7}, 3) = {3,3,5,5,6,7}
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 239 - Sliding Window Maximum
// Time: O(n), Space: O(k)
import java.util.*;

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0) return new int[0];
        
        int n = nums.length;
        int[] result = new int[n - k + 1];
        Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();  // Indices with decreasing values
        
        for (int i = 0; i &lt; n; i++) {
            // Remove indices outside window
            while (!dq.isEmpty() &amp;&amp; dq.peekFirst() &lt; i - k + 1) {
                dq.pollFirst();
            }
            
            // Remove smaller elements
            while (!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt; nums[i]) {
                dq.pollLast();
            }
            
            dq.offerLast(i);
            
            // Add max when window is complete
            if (i &gt;= k - 1) {
                result[i - k + 1] = nums[dq.peekFirst()];
            }
        }
        return result;
    }
}

// Test: maxSlidingWindow({1,3,-1,-3,5,3,6,7}, 3) = {3,3,5,5,6,7}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 621. Task Scheduler</h4>
                            <p>Schedule tasks with cooldown period.</p>
<pre><code class="language-python"># LeetCode 621 - Task Scheduler
# Time: O(n), Space: O(1)
from collections import Counter

def leastInterval(tasks, n):
    """
    Find minimum intervals to complete all tasks with cooldown.
    """
    freq = Counter(tasks)
    max_freq = max(freq.values())
    
    # Count tasks with max frequency
    max_count = sum(1 for f in freq.values() if f == max_freq)
    
    # Formula: (max_freq - 1) * (n + 1) + max_count
    # But result can't be less than total tasks
    result = (max_freq - 1) * (n + 1) + max_count
    
    return max(result, len(tasks))

# Test
print(leastInterval(["A","A","A","B","B","B"], 2))  # 8
# A -> B -> idle -> A -> B -> idle -> A -> B
</code></pre>

<h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">// LeetCode 621 - Task Scheduler
// Time: O(n), Space: O(1)
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class Solution {
public:
    int leastInterval(std::vector&lt;char&gt;&amp; tasks, int n) {
        // Count frequency of each task
        std::vector&lt;int&gt; freq(26, 0);
        for (char task : tasks) {
            freq[task - 'A']++;
        }
        
        int maxFreq = *std::max_element(freq.begin(), freq.end());
        
        // Count tasks with max frequency
        int maxCount = 0;
        for (int f : freq) {
            if (f == maxFreq) maxCount++;
        }
        
        // Formula: (maxFreq - 1) * (n + 1) + maxCount
        // But result can't be less than total tasks
        int result = (maxFreq - 1) * (n + 1) + maxCount;
        
        return std::max(result, static_cast&lt;int&gt;(tasks.size()));
    }
};

// Test: leastInterval({A,A,A,B,B,B}, 2) = 8
// A -> B -> idle -> A -> B -> idle -> A -> B
</code></pre>

<h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 621 - Task Scheduler
// Time: O(n), Space: O(1)
import java.util.*;

class Solution {
    public int leastInterval(char[] tasks, int n) {
        // Count frequency of each task
        int[] freq = new int[26];
        for (char task : tasks) {
            freq[task - 'A']++;
        }
        
        int maxFreq = Arrays.stream(freq).max().getAsInt();
        
        // Count tasks with max frequency
        int maxCount = 0;
        for (int f : freq) {
            if (f == maxFreq) maxCount++;
        }
        
        // Formula: (maxFreq - 1) * (n + 1) + maxCount
        // But result can't be less than total tasks
        int result = (maxFreq - 1) * (n + 1) + maxCount;
        
        return Math.max(result, tasks.length);
    }
}

// Test: leastInterval(['A','A','A','B','B','B'], 2) = 8
// A -> B -> idle -> A -> B -> idle -> A -> B
</code></pre>
                        </div>

                        <!-- Related Posts -->
                        <div class="related-posts">
                            <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 7: Stack</h5>
                                <p class="text-muted small mb-2">Stack implementations, expression evaluation, monotonic stack patterns.</p>
                                <a href="dsa-stack-applications.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 9: Trees</h5>
                                <p class="text-muted small mb-2">Binary trees, tree traversals, properties, and common operations.</p>
                                <a href="dsa-trees-fundamentals.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 10: BST & Balanced Trees</h5>
                                <p class="text-muted small mb-2">Binary search trees, AVL trees, Red-Black trees, and self-balancing.</p>
                                <a href="dsa-bst-avl-redblack.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest"><i class="fab fa-pinterest-p"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? â˜• <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Scroll-to-Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    <!-- Category Indicator -->
    <div id="categoryIndicator" class="category-indicator" title="Current Section">
        <i class="fas fa-tag"></i><span id="categoryText">Technology</span>
    </div>
    
    <!-- Cookie Consent JS -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>

    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    <!-- Scroll-to-Top Script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const scrollToTopBtn = document.getElementById('scrollToTop');
            window.addEventListener('scroll', function() {
                if (window.scrollY > 300) {
                    scrollToTopBtn.classList.add('show');
                } else {
                    scrollToTopBtn.classList.remove('show');
                }
            });
            scrollToTopBtn.addEventListener('click', function() {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });
    </script>

    <!-- Side Navigation Script -->
    <script>
        function openNav() {
            document.getElementById('tocSidenav').classList.add('open');
            document.getElementById('tocOverlay').classList.add('show');
            document.body.style.overflow = 'hidden';
        }
        function closeNav() {
            document.getElementById('tocSidenav').classList.remove('open');
            document.getElementById('tocOverlay').classList.remove('show');
            document.body.style.overflow = 'auto';
        }
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeNav();
        });
        document.addEventListener('DOMContentLoaded', function() {
            const sections = document.querySelectorAll('[id]');
            const tocLinks = document.querySelectorAll('.sidenav-toc a');
            function highlightActiveSection() {
                let currentSection = '';
                sections.forEach(section => {
                    const sectionTop = section.offsetTop;
                    if (window.scrollY >= sectionTop - 200) {
                        currentSection = section.getAttribute('id');
                    }
                });
                tocLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === '#' + currentSection) {
                        link.classList.add('active');
                    }
                });
            }
            window.addEventListener('scroll', highlightActiveSection);
            highlightActiveSection();
            tocLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetSection = document.querySelector(targetId);
                    if (targetSection) {
                        const offsetTop = targetSection.offsetTop - 80;
                        window.scrollTo({ top: offsetTop, behavior: 'smooth' });
                    }
                    setTimeout(closeNav, 300);
                });
            });
        });
    </script>

    <!-- Prism Theme Switcher -->
    <script>
        const themes = {
            'prism-theme': 'Tomorrow Night',
            'prism-default': 'Default',
            'prism-dark': 'Dark',
            'prism-twilight': 'Twilight',
            'prism-okaidia': 'Okaidia',
            'prism-solarizedlight': 'Solarized Light'
        };
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        function switchTheme(themeId) {
            Object.keys(themes).forEach(id => {
                const link = document.getElementById(id);
                if (link) link.disabled = true;
            });
            const selectedLink = document.getElementById(themeId);
            if (selectedLink) {
                selectedLink.disabled = false;
                localStorage.setItem('prism-theme', themeId);
            }
            document.querySelectorAll('div.code-toolbar select').forEach(dropdown => {
                dropdown.value = themeId;
            });
            setTimeout(() => Prism.highlightAll(), 10);
        }
        document.addEventListener('DOMContentLoaded', function() {
            switchTheme(savedTheme);
        });
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) {
            const select = document.createElement('select');
            select.setAttribute('aria-label', 'Select code theme');
            Object.keys(themes).forEach(themeId => {
                const option = document.createElement('option');
                option.value = themeId;
                option.textContent = themes[themeId];
                if (themeId === savedTheme) option.selected = true;
                select.appendChild(option);
            });
            select.addEventListener('change', function(e) {
                switchTheme(e.target.value);
            });
            return select;
        });
    </script>

            <!-- Scroll-to-Top and Category Indicator Script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const scrollToTopBtn = document.getElementById('scrollToTop');
            const categoryIndicator = document.getElementById('categoryIndicator');
            const categoryText = document.getElementById('categoryText');
            
            // Auto-detect H2 sections in the article (works with or without id)
            const h2Elements = document.querySelectorAll('.blog-content h2');
            const sections = [];
            h2Elements.forEach(function(h2, index) {
                // Get text without icon
                let text = h2.textContent.trim().replace(/^\d+\.\s*/, '');
                // Truncate to 25 chars
                if (text.length > 25) text = text.substring(0, 22) + '...';
                sections.push({ element: h2, name: text });
            });
            
            // Fallback to article category if no sections found
            const articleCategory = categoryText ? categoryText.textContent : 'Article';
            
            // Show/hide button on scroll and update section
            window.addEventListener('scroll', function() {
                if (window.scrollY > 300) {
                    if (scrollToTopBtn) scrollToTopBtn.classList.add('show');
                    if (categoryIndicator) categoryIndicator.classList.add('show');
                } else {
                    if (scrollToTopBtn) scrollToTopBtn.classList.remove('show');
                    if (categoryIndicator) categoryIndicator.classList.remove('show');
                }
                
                // Update current section
                updateCurrentSection();
            });
            
            // Update section based on viewport position
            function updateCurrentSection() {
                if (!categoryText || sections.length === 0) return;
                
                let currentSection = articleCategory;
                
                for (let section of sections) {
                    const rect = section.element.getBoundingClientRect();
                    if (rect.top <= window.innerHeight / 2) {
                        currentSection = section.name;
                    }
                }
                
                categoryText.textContent = currentSection;
            }
            
            // Smooth scroll to top on click
            if (scrollToTopBtn) {
                scrollToTopBtn.addEventListener('click', function() {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
            }
        });
    </script>
</body>
</html>
