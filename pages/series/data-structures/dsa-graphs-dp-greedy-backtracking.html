<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master Graphs, Dynamic Programming, Greedy Algorithms, and Backtracking for FAANG interviews. Complete guide with Python implementations, BFS/DFS, shortest paths, DP patterns, and classic problems.">
    <meta name="keywords" content="graph algorithms, dynamic programming, greedy algorithms, backtracking, BFS, DFS, Dijkstra, Python, data structures, FAANG interview, LeetCode">
    <meta name="author" content="Wasil Zafar">
    
    <!-- Open Graph / Social Media -->
    <meta property="og:title" content="DSA Part 12: Graphs, DP, Greedy & Backtracking | Wasil Zafar">
    <meta property="og:description" content="Complete guide to graphs, dynamic programming, greedy algorithms, and backtracking for technical interviews.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://wasilzafar.com/pag../series/data-structures/dsa-graphs-dp-greedy-backtracking.html">
    <meta property="article:published_time" content="2026-01-28">
    <meta property="article:author" content="Wasil Zafar">
    <meta property="article:section" content="Technology">
    
    <title>DSA Part 12: Graphs, DP, Greedy & Backtracking | Wasil Zafar</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../../../images/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Prism.js Syntax Highlighting - Multiple Themes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css">
    
    <!-- Main CSS -->
    <link rel="stylesheet" href="../../../css/main.css">

    <!-- Google tag (gtag.js) - Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'functionality_storage': 'granted',
            'personalization_storage': 'denied',
            'security_storage': 'granted',
            'wait_for_update': 500
        });
        
        gtag('set', 'ads_data_redaction', true);
        gtag('set', 'url_passthrough', true);
    </script>
    
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-PBS8M2JR');</script>
    
    </head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/">
                <span class="gradient-text">Wasil Zafar</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#about">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#skills">Skills</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#certifications">Certifications</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/#interests">Interests</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- TOC Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation TOC -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close">&times;</button>
        </div>
        <ol>
            <li><a href="#graphs" onclick="closeNav()">Graph Fundamentals</a></li>
            <li><a href="#graph-traversal" onclick="closeNav()">BFS & DFS</a></li>
            <li><a href="#shortest-path" onclick="closeNav()">Shortest Path</a></li>
            <li><a href="#topological" onclick="closeNav()">Topological Sort</a></li>
            <li><a href="#dp-intro" onclick="closeNav()">DP Introduction</a></li>
            <li><a href="#dp-patterns" onclick="closeNav()">DP Patterns</a></li>
            <li><a href="#greedy" onclick="closeNav()">Greedy Algorithms</a></li>
            <li><a href="#backtracking" onclick="closeNav()">Backtracking</a></li>
            <li><a href="#leetcode" onclick="closeNav()">LeetCode Problems</a></li>
            <li><a href="#series-nav" onclick="closeNav()">Complete Series</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link">
                    <i class="fas fa-arrow-left me-2"></i>Back to Technology
                </a>
                <h1 class="display-4 fw-bold mb-3">DSA Part 12: Graphs, DP, Greedy & Backtracking</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>January 28, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>35 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
                <p class="lead">Master graphs, dynamic programming, greedy algorithms, and backtracking - the final pillars for FAANG interview success with complete Python implementations.</p>
            </div>
        </div>
    </section>

    <!-- Blog Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">
                    <div class="blog-content">
                        
                        <!-- Graphs -->
                        <h2 id="graphs"><i class="fas fa-project-diagram me-2"></i>Graph Fundamentals</h2>
                        
                        <p>A <strong>Graph</strong> is a collection of nodes (vertices) and edges connecting them. Graphs model relationships and networks, appearing frequently in interview problems.</p>
                        
                        <div class="highlight-box">
                            <h4><i class="fas fa-lightbulb me-2"></i>Graph Terminology</h4>
                            <ul>
                                <li><strong>Directed:</strong> Edges have direction (A→B)</li>
                                <li><strong>Undirected:</strong> Edges go both ways (A—B)</li>
                                <li><strong>Weighted:</strong> Edges have costs/weights</li>
                                <li><strong>Cycle:</strong> Path that starts and ends at same node</li>
                                <li><strong>Connected:</strong> Path exists between all vertex pairs</li>
                            </ul>
                        </div>

                        <div class="experiment-card">
                            <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                            <div class="mb-2">
                                <span class="badge bg-teal me-2">12-Part Series</span>
                                <span class="badge bg-crimson">FAANG Interview Prep</span>
                            </div>
                            <ol>
                                <li><a href="dsa-foundations-memory-complexity.html">Foundations, Memory & Complexity</a></li>
                                <li><a href="dsa-recursion-complete-guide.html">Recursion Complete Guide</a></li>
                                <li><a href="dsa-arrays-adt-operations.html">Arrays & Array ADT</a></li>
                                <li><a href="dsa-strings-manipulation.html">Strings</a></li>
                                <li><a href="dsa-matrices-special-sparse.html">Matrices</a></li>
                                <li><a href="dsa-linked-lists-guide.html">Linked Lists</a></li>
                                <li><a href="dsa-stack-applications.html">Stack</a></li>
                                <li><a href="dsa-queue-implementations.html">Queue</a></li>
                                <li><a href="dsa-trees-fundamentals.html">Trees</a></li>
                                <li><a href="dsa-bst-avl-redblack.html">BST & Balanced Trees</a></li>
                                <li><a href="dsa-heaps-sorting-hashing.html">Heaps, Sorting & Hashing</a></li>
                                <li><strong>Graphs, DP, Greedy & Backtracking (This Guide)</strong></li>
                            </ol>
                        </div>

                        <h3>Graph Representations</h3>
                        
<pre><code class="language-python">from collections import defaultdict

# 1. Adjacency List (most common for sparse graphs)
class GraphAdjList:
    """
    Adjacency List representation
    Space: O(V + E)
    Best for: sparse graphs, most interview problems
    """
    def __init__(self, directed=False):
        self.graph = defaultdict(list)
        self.directed = directed
    
    def add_edge(self, u, v, weight=1):
        self.graph[u].append((v, weight))
        if not self.directed:
            self.graph[v].append((u, weight))
    
    def get_neighbors(self, u):
        return self.graph[u]
    
    def __str__(self):
        return str(dict(self.graph))

# Example
g = GraphAdjList(directed=False)
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(1, 2)
g.add_edge(2, 3)

print("Adjacency List:", g)
print("Neighbors of 0:", g.get_neighbors(0))
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Graph Adjacency List - O(V + E) space
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;iostream&gt;

class GraphAdjList {
private:
    std::unordered_map&lt;int, std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; graph;
    bool directed;
    
public:
    GraphAdjList(bool isDirected = false) : directed(isDirected) {}
    
    void addEdge(int u, int v, int weight = 1) {
        graph[u].push_back({v, weight});
        if (!directed) {
            graph[v].push_back({u, weight});
        }
    }
    
    std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; getNeighbors(int u) {
        return graph[u];
    }
    
    void display() {
        for (auto&amp; [node, neighbors] : graph) {
            std::cout &lt;&lt; node &lt;&lt; ": ";
            for (auto&amp; [v, w] : neighbors)
                std::cout &lt;&lt; "(" &lt;&lt; v &lt;&lt; "," &lt;&lt; w &lt;&lt; ") ";
            std::cout &lt;&lt; std::endl;
        }
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Graph Adjacency List - O(V + E) space
import java.util.*;

class GraphAdjList {
    private Map&lt;Integer, List&lt;int[]&gt;&gt; graph;
    private boolean directed;
    
    public GraphAdjList(boolean directed) {
        this.graph = new HashMap&lt;&gt;();
        this.directed = directed;
    }
    
    public void addEdge(int u, int v, int weight) {
        graph.computeIfAbsent(u, k -&gt; new ArrayList&lt;&gt;()).add(new int[]{v, weight});
        if (!directed) {
            graph.computeIfAbsent(v, k -&gt; new ArrayList&lt;&gt;()).add(new int[]{u, weight});
        }
    }
    
    public void addEdge(int u, int v) { addEdge(u, v, 1); }
    
    public List&lt;int[]&gt; getNeighbors(int u) {
        return graph.getOrDefault(u, new ArrayList&lt;&gt;());
    }
}
</code></pre>

<pre><code class="language-python">import numpy as np

# 2. Adjacency Matrix (good for dense graphs)
class GraphAdjMatrix:
    """
    Adjacency Matrix representation
    Space: O(V²)
    Best for: dense graphs, quick edge lookups
    """
    def __init__(self, num_vertices):
        self.V = num_vertices
        self.matrix = [[0] * num_vertices for _ in range(num_vertices)]
    
    def add_edge(self, u, v, weight=1):
        self.matrix[u][v] = weight
        self.matrix[v][u] = weight  # For undirected
    
    def has_edge(self, u, v):
        return self.matrix[u][v] != 0
    
    def get_neighbors(self, u):
        return [v for v in range(self.V) if self.matrix[u][v] != 0]
    
    def display(self):
        for row in self.matrix:
            print(row)

# Example
g = GraphAdjMatrix(4)
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(1, 2)
g.add_edge(2, 3)

print("Adjacency Matrix:")
g.display()
print("Neighbors of 2:", g.get_neighbors(2))
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Graph Adjacency Matrix - O(V²) space
#include &lt;vector&gt;
#include &lt;iostream&gt;

class GraphAdjMatrix {
private:
    int V;
    std::vector&lt;std::vector&lt;int&gt;&gt; matrix;
    
public:
    GraphAdjMatrix(int numVertices) : V(numVertices), matrix(V, std::vector&lt;int&gt;(V, 0)) {}
    
    void addEdge(int u, int v, int weight = 1) {
        matrix[u][v] = weight;
        matrix[v][u] = weight;  // Undirected
    }
    
    bool hasEdge(int u, int v) { return matrix[u][v] != 0; }
    
    std::vector&lt;int&gt; getNeighbors(int u) {
        std::vector&lt;int&gt; neighbors;
        for (int v = 0; v &lt; V; v++)
            if (matrix[u][v] != 0) neighbors.push_back(v);
        return neighbors;
    }
    
    void display() {
        for (auto&amp; row : matrix) {
            for (int val : row) std::cout &lt;&lt; val &lt;&lt; " ";
            std::cout &lt;&lt; std::endl;
        }
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Graph Adjacency Matrix - O(V²) space
import java.util.*;

class GraphAdjMatrix {
    private int V;
    private int[][] matrix;
    
    public GraphAdjMatrix(int numVertices) {
        V = numVertices;
        matrix = new int[V][V];
    }
    
    public void addEdge(int u, int v, int weight) {
        matrix[u][v] = weight;
        matrix[v][u] = weight;  // Undirected
    }
    
    public void addEdge(int u, int v) { addEdge(u, v, 1); }
    
    public boolean hasEdge(int u, int v) { return matrix[u][v] != 0; }
    
    public List&lt;Integer&gt; getNeighbors(int u) {
        List&lt;Integer&gt; neighbors = new ArrayList&lt;&gt;();
        for (int v = 0; v &lt; V; v++)
            if (matrix[u][v] != 0) neighbors.add(v);
        return neighbors;
    }
}
</code></pre>

<pre><code class="language-python"># 3. Edge List (simplest representation)
class GraphEdgeList:
    """
    Edge List representation
    Space: O(E)
    Best for: algorithms that iterate over all edges
    """
    def __init__(self):
        self.edges = []
    
    def add_edge(self, u, v, weight=1):
        self.edges.append((u, v, weight))
    
    def get_edges(self):
        return self.edges

# Example
g = GraphEdgeList()
g.add_edge(0, 1, 4)
g.add_edge(0, 2, 2)
g.add_edge(1, 2, 1)
g.add_edge(2, 3, 5)

print("Edge List:", g.get_edges())
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Graph Edge List - O(E) space
#include &lt;vector&gt;
#include &lt;tuple&gt;

class GraphEdgeList {
private:
    std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; edges;  // (u, v, weight)
    
public:
    void addEdge(int u, int v, int weight = 1) {
        edges.push_back({u, v, weight});
    }
    
    const std::vector&lt;std::tuple&lt;int, int, int&gt;&gt;&amp; getEdges() {
        return edges;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Graph Edge List - O(E) space
import java.util.*;

class GraphEdgeList {
    private List&lt;int[]&gt; edges;  // {u, v, weight}
    
    public GraphEdgeList() { edges = new ArrayList&lt;&gt;(); }
    
    public void addEdge(int u, int v, int weight) {
        edges.add(new int[]{u, v, weight});
    }
    
    public List&lt;int[]&gt; getEdges() { return edges; }
}
</code></pre>

                        <!-- Graph Traversal -->
                        <h2 id="graph-traversal"><i class="fas fa-route me-2"></i>BFS & DFS Traversal</h2>
                        
                        <h3>Breadth-First Search (BFS)</h3>
                        
<pre><code class="language-python">from collections import deque, defaultdict

def bfs(graph, start):
    """
    Breadth-First Search
    Time: O(V + E), Space: O(V)
    Use for: shortest path in unweighted graphs, level-order traversal
    """
    visited = set([start])
    queue = deque([start])
    result = []
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return result

def bfs_shortest_path(graph, start, end):
    """
    BFS for shortest path in unweighted graph
    Returns path from start to end
    """
    if start == end:
        return [start]
    
    visited = {start}
    queue = deque([(start, [start])])
    
    while queue:
        node, path = queue.popleft()
        
        for neighbor in graph[node]:
            if neighbor == end:
                return path + [neighbor]
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return []  # No path found

# Example
graph = defaultdict(list)
edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4)]
for u, v in edges:
    graph[u].append(v)
    graph[v].append(u)

print("BFS traversal:", bfs(graph, 0))
print("Shortest path 0→4:", bfs_shortest_path(graph, 0, 4))
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// BFS Traversal and Shortest Path
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;

class GraphBFS {
public:
    // BFS traversal - O(V + E) time
    static std::vector&lt;int&gt; bfs(std::unordered_map&lt;int, std::vector&lt;int&gt;&gt;&amp; graph, int start) {
        std::vector&lt;int&gt; result;
        std::unordered_set&lt;int&gt; visited;
        std::queue&lt;int&gt; q;
        
        visited.insert(start);
        q.push(start);
        
        while (!q.empty()) {
            int node = q.front(); q.pop();
            result.push_back(node);
            
            for (int neighbor : graph[node]) {
                if (visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    q.push(neighbor);
                }
            }
        }
        return result;
    }
    
    // Shortest path in unweighted graph
    static std::vector&lt;int&gt; shortestPath(std::unordered_map&lt;int, std::vector&lt;int&gt;&gt;&amp; graph, int start, int end) {
        if (start == end) return {start};
        
        std::unordered_set&lt;int&gt; visited;
        std::queue&lt;std::pair&lt;int, std::vector&lt;int&gt;&gt;&gt; q;
        
        visited.insert(start);
        q.push({start, {start}});
        
        while (!q.empty()) {
            auto [node, path] = q.front(); q.pop();
            
            for (int neighbor : graph[node]) {
                if (neighbor == end) {
                    path.push_back(neighbor);
                    return path;
                }
                if (visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    std::vector&lt;int&gt; newPath = path;
                    newPath.push_back(neighbor);
                    q.push({neighbor, newPath});
                }
            }
        }
        return {};  // No path
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// BFS Traversal and Shortest Path
import java.util.*;

class GraphBFS {
    // BFS traversal - O(V + E) time
    public static List&lt;Integer&gt; bfs(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int start) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        
        visited.add(start);
        queue.offer(start);
        
        while (!queue.isEmpty()) {
            int node = queue.poll();
            result.add(node);
            
            for (int neighbor : graph.getOrDefault(node, new ArrayList&lt;&gt;())) {
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    queue.offer(neighbor);
                }
            }
        }
        return result;
    }
    
    // Shortest path in unweighted graph
    public static List&lt;Integer&gt; shortestPath(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int start, int end) {
        if (start == end) return Arrays.asList(start);
        
        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
        Queue&lt;List&lt;Integer&gt;&gt; queue = new LinkedList&lt;&gt;();
        
        visited.add(start);
        queue.offer(new ArrayList&lt;&gt;(Arrays.asList(start)));
        
        while (!queue.isEmpty()) {
            List&lt;Integer&gt; path = queue.poll();
            int node = path.get(path.size() - 1);
            
            for (int neighbor : graph.getOrDefault(node, new ArrayList&lt;&gt;())) {
                if (neighbor == end) {
                    path.add(neighbor);
                    return path;
                }
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    List&lt;Integer&gt; newPath = new ArrayList&lt;&gt;(path);
                    newPath.add(neighbor);
                    queue.offer(newPath);
                }
            }
        }
        return new ArrayList&lt;&gt;();  // No path
    }
}
</code></pre>

                        <h3>Depth-First Search (DFS)</h3>
                        
<pre><code class="language-python">from collections import defaultdict

def dfs_recursive(graph, start, visited=None):
    """
    DFS - Recursive implementation
    Time: O(V + E), Space: O(V) for call stack
    """
    if visited is None:
        visited = set()
    
    visited.add(start)
    result = [start]
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            result.extend(dfs_recursive(graph, neighbor, visited))
    
    return result

def dfs_iterative(graph, start):
    """
    DFS - Iterative implementation using stack
    Time: O(V + E), Space: O(V)
    """
    visited = set()
    stack = [start]
    result = []
    
    while stack:
        node = stack.pop()
        
        if node not in visited:
            visited.add(node)
            result.append(node)
            
            # Add neighbors in reverse order for consistent ordering
            for neighbor in reversed(graph[node]):
                if neighbor not in visited:
                    stack.append(neighbor)
    
    return result

# Example
graph = defaultdict(list)
edges = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5)]
for u, v in edges:
    graph[u].append(v)
    graph[v].append(u)

print("DFS recursive:", dfs_recursive(graph, 0))
print("DFS iterative:", dfs_iterative(graph, 0))
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// DFS Traversal - Recursive and Iterative
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;

class GraphDFS {
public:
    // DFS recursive
    static std::vector&lt;int&gt; dfsRecursive(std::unordered_map&lt;int, std::vector&lt;int&gt;&gt;&amp; graph, 
                                          int node, std::unordered_set&lt;int&gt;&amp; visited) {
        std::vector&lt;int&gt; result;
        visited.insert(node);
        result.push_back(node);
        
        for (int neighbor : graph[node]) {
            if (visited.find(neighbor) == visited.end()) {
                auto subResult = dfsRecursive(graph, neighbor, visited);
                result.insert(result.end(), subResult.begin(), subResult.end());
            }
        }
        return result;
    }
    
    // DFS iterative
    static std::vector&lt;int&gt; dfsIterative(std::unordered_map&lt;int, std::vector&lt;int&gt;&gt;&amp; graph, int start) {
        std::vector&lt;int&gt; result;
        std::unordered_set&lt;int&gt; visited;
        std::stack&lt;int&gt; stk;
        
        stk.push(start);
        
        while (!stk.empty()) {
            int node = stk.top(); stk.pop();
            
            if (visited.find(node) == visited.end()) {
                visited.insert(node);
                result.push_back(node);
                
                // Add neighbors in reverse for consistent order
                auto&amp; neighbors = graph[node];
                for (auto it = neighbors.rbegin(); it != neighbors.rend(); ++it) {
                    if (visited.find(*it) == visited.end())
                        stk.push(*it);
                }
            }
        }
        return result;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// DFS Traversal - Recursive and Iterative
import java.util.*;

class GraphDFS {
    // DFS recursive
    public static void dfsRecursive(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int node,
                                     Set&lt;Integer&gt; visited, List&lt;Integer&gt; result) {
        visited.add(node);
        result.add(node);
        
        for (int neighbor : graph.getOrDefault(node, new ArrayList&lt;&gt;())) {
            if (!visited.contains(neighbor)) {
                dfsRecursive(graph, neighbor, visited, result);
            }
        }
    }
    
    // DFS iterative
    public static List&lt;Integer&gt; dfsIterative(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int start) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();
        
        stack.push(start);
        
        while (!stack.isEmpty()) {
            int node = stack.pop();
            
            if (!visited.contains(node)) {
                visited.add(node);
                result.add(node);
                
                List&lt;Integer&gt; neighbors = graph.getOrDefault(node, new ArrayList&lt;&gt;());
                for (int i = neighbors.size() - 1; i &gt;= 0; i--) {
                    if (!visited.contains(neighbors.get(i)))
                        stack.push(neighbors.get(i));
                }
            }
        }
        return result;
    }
}
</code></pre>

                        <h3>Number of Islands (Classic Graph Problem)</h3>
                        
<pre><code class="language-python">def num_islands(grid):
    """
    LeetCode 200: Number of Islands
    Time: O(m*n), Space: O(m*n) for recursion
    """
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    count = 0
    
    def dfs(r, c):
        # Boundary check and water/visited check
        if (r < 0 or r >= rows or 
            c < 0 or c >= cols or 
            grid[r][c] != '1'):
            return
        
        # Mark as visited
        grid[r][c] = '#'
        
        # Explore all 4 directions
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                count += 1
                dfs(r, c)
    
    return count

# Example
grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
]

print("Number of islands:", num_islands(grid))  # 3
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 200: Number of Islands
// Time: O(m*n), Space: O(m*n)
#include &lt;vector&gt;

class NumIslands {
public:
    int numIslands(std::vector&lt;std::vector&lt;char&gt;&gt;&amp; grid) {
        if (grid.empty()) return 0;
        
        int rows = grid.size(), cols = grid[0].size();
        int count = 0;
        
        for (int r = 0; r &lt; rows; r++) {
            for (int c = 0; c &lt; cols; c++) {
                if (grid[r][c] == '1') {
                    count++;
                    dfs(grid, r, c, rows, cols);
                }
            }
        }
        return count;
    }
    
private:
    void dfs(std::vector&lt;std::vector&lt;char&gt;&gt;&amp; grid, int r, int c, int rows, int cols) {
        if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols || grid[r][c] != '1')
            return;
        
        grid[r][c] = '#';  // Mark visited
        dfs(grid, r + 1, c, rows, cols);
        dfs(grid, r - 1, c, rows, cols);
        dfs(grid, r, c + 1, rows, cols);
        dfs(grid, r, c - 1, rows, cols);
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 200: Number of Islands
// Time: O(m*n), Space: O(m*n)

class NumIslands {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) return 0;
        
        int rows = grid.length, cols = grid[0].length;
        int count = 0;
        
        for (int r = 0; r &lt; rows; r++) {
            for (int c = 0; c &lt; cols; c++) {
                if (grid[r][c] == '1') {
                    count++;
                    dfs(grid, r, c, rows, cols);
                }
            }
        }
        return count;
    }
    
    private void dfs(char[][] grid, int r, int c, int rows, int cols) {
        if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols || grid[r][c] != '1')
            return;
        
        grid[r][c] = '#';  // Mark visited
        dfs(grid, r + 1, c, rows, cols);
        dfs(grid, r - 1, c, rows, cols);
        dfs(grid, r, c + 1, rows, cols);
        dfs(grid, r, c - 1, rows, cols);
    }
}
</code></pre>

                        <!-- Shortest Path -->
                        <h2 id="shortest-path"><i class="fas fa-map-marker-alt me-2"></i>Shortest Path Algorithms</h2>
                        
                        <h3>Dijkstra's Algorithm</h3>
                        
<pre><code class="language-python">import heapq
from collections import defaultdict

def dijkstra(graph, start):
    """
    Dijkstra's Algorithm for shortest paths
    Time: O((V + E) log V), Space: O(V)
    Works for non-negative weights only
    """
    # Distance to all nodes (infinity initially)
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    
    # Priority queue: (distance, node)
    pq = [(0, start)]
    
    # Track visited nodes
    visited = set()
    
    while pq:
        dist, node = heapq.heappop(pq)
        
        if node in visited:
            continue
        
        visited.add(node)
        
        for neighbor, weight in graph[node]:
            if neighbor not in visited:
                new_dist = dist + weight
                
                if new_dist < distances[neighbor]:
                    distances[neighbor] = new_dist
                    heapq.heappush(pq, (new_dist, neighbor))
    
    return distances

# Example: Weighted graph
graph = defaultdict(list)
edges = [
    (0, 1, 4), (0, 2, 1),
    (1, 3, 1),
    (2, 1, 2), (2, 3, 5),
    (3, 4, 3)
]

for u, v, w in edges:
    graph[u].append((v, w))

distances = dijkstra(graph, 0)
print("Shortest distances from 0:")
for node, dist in sorted(distances.items()):
    print(f"  To {node}: {dist}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Dijkstra's Algorithm - O((V + E) log V)
// Non-negative weights only
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;
#include &lt;limits&gt;

class Dijkstra {
public:
    static std::unordered_map&lt;int, int&gt; shortestPaths(
            std::unordered_map&lt;int, std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt;&amp; graph, int start) {
        
        std::unordered_map&lt;int, int&gt; distances;
        for (auto&amp; [node, _] : graph)
            distances[node] = std::numeric_limits&lt;int&gt;::max();
        distances[start] = 0;
        
        // Min heap: (distance, node)
        std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt;&gt;,
                           std::greater&lt;&gt;&gt; pq;
        pq.push({0, start});
        
        std::unordered_set&lt;int&gt; visited;
        
        while (!pq.empty()) {
            auto [dist, node] = pq.top(); pq.pop();
            
            if (visited.count(node)) continue;
            visited.insert(node);
            
            for (auto&amp; [neighbor, weight] : graph[node]) {
                int newDist = dist + weight;
                if (newDist &lt; distances[neighbor]) {
                    distances[neighbor] = newDist;
                    pq.push({newDist, neighbor});
                }
            }
        }
        return distances;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Dijkstra's Algorithm - O((V + E) log V)
// Non-negative weights only
import java.util.*;

class Dijkstra {
    public static Map&lt;Integer, Integer&gt; shortestPaths(
            Map&lt;Integer, List&lt;int[]&gt;&gt; graph, int start) {
        
        Map&lt;Integer, Integer&gt; distances = new HashMap&lt;&gt;();
        for (int node : graph.keySet())
            distances.put(node, Integer.MAX_VALUE);
        distances.put(start, 0);
        
        // Min heap: {distance, node}
        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; a[0] - b[0]);
        pq.offer(new int[]{0, start});
        
        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
        
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int dist = curr[0], node = curr[1];
            
            if (visited.contains(node)) continue;
            visited.add(node);
            
            for (int[] edge : graph.getOrDefault(node, new ArrayList&lt;&gt;())) {
                int neighbor = edge[0], weight = edge[1];
                int newDist = dist + weight;
                if (newDist &lt; distances.getOrDefault(neighbor, Integer.MAX_VALUE)) {
                    distances.put(neighbor, newDist);
                    pq.offer(new int[]{newDist, neighbor});
                }
            }
        }
        return distances;
    }
}
</code></pre>

                        <h3>Bellman-Ford Algorithm</h3>
                        
<pre><code class="language-python">def bellman_ford(vertices, edges, start):
    """
    Bellman-Ford Algorithm
    Time: O(V * E), Space: O(V)
    Handles negative weights, detects negative cycles
    """
    # Initialize distances
    distances = {v: float('inf') for v in vertices}
    distances[start] = 0
    
    # Relax edges V-1 times
    for _ in range(len(vertices) - 1):
        for u, v, weight in edges:
            if distances[u] != float('inf'):
                if distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight
    
    # Check for negative cycles
    for u, v, weight in edges:
        if distances[u] != float('inf'):
            if distances[u] + weight < distances[v]:
                return None  # Negative cycle detected
    
    return distances

# Example
vertices = [0, 1, 2, 3, 4]
edges = [
    (0, 1, 4), (0, 2, 1),
    (1, 3, 1),
    (2, 1, 2), (2, 3, 5),
    (3, 4, 3)
]

distances = bellman_ford(vertices, edges, 0)
print("Bellman-Ford distances from 0:")
for node, dist in sorted(distances.items()):
    print(f"  To {node}: {dist}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Bellman-Ford Algorithm - O(V * E)
// Handles negative weights, detects negative cycles
#include &lt;vector&gt;
#include &lt;limits&gt;
#include &lt;unordered_map&gt;

class BellmanFord {
public:
    static std::unordered_map&lt;int, int&gt; shortestPaths(
            std::vector&lt;int&gt;&amp; vertices,
            std::vector&lt;std::tuple&lt;int, int, int&gt;&gt;&amp; edges, int start) {
        
        std::unordered_map&lt;int, int&gt; distances;
        for (int v : vertices)
            distances[v] = std::numeric_limits&lt;int&gt;::max();
        distances[start] = 0;
        
        // Relax edges V-1 times
        for (int i = 0; i &lt; vertices.size() - 1; i++) {
            for (auto&amp; [u, v, weight] : edges) {
                if (distances[u] != std::numeric_limits&lt;int&gt;::max() &amp;&amp;
                    distances[u] + weight &lt; distances[v]) {
                    distances[v] = distances[u] + weight;
                }
            }
        }
        
        // Check for negative cycles
        for (auto&amp; [u, v, weight] : edges) {
            if (distances[u] != std::numeric_limits&lt;int&gt;::max() &amp;&amp;
                distances[u] + weight &lt; distances[v]) {
                return {};  // Negative cycle detected
            }
        }
        
        return distances;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Bellman-Ford Algorithm - O(V * E)
// Handles negative weights, detects negative cycles
import java.util.*;

class BellmanFord {
    public static Map&lt;Integer, Integer&gt; shortestPaths(
            int[] vertices, int[][] edges, int start) {
        
        Map&lt;Integer, Integer&gt; distances = new HashMap&lt;&gt;();
        for (int v : vertices)
            distances.put(v, Integer.MAX_VALUE);
        distances.put(start, 0);
        
        // Relax edges V-1 times
        for (int i = 0; i &lt; vertices.length - 1; i++) {
            for (int[] edge : edges) {
                int u = edge[0], v = edge[1], weight = edge[2];
                if (distances.get(u) != Integer.MAX_VALUE &amp;&amp;
                    distances.get(u) + weight &lt; distances.get(v)) {
                    distances.put(v, distances.get(u) + weight);
                }
            }
        }
        
        // Check for negative cycles
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1], weight = edge[2];
            if (distances.get(u) != Integer.MAX_VALUE &amp;&amp;
                distances.get(u) + weight &lt; distances.get(v)) {
                return null;  // Negative cycle detected
            }
        }
        
        return distances;
    }
}
</code></pre>

                        <!-- Topological Sort -->
                        <h2 id="topological"><i class="fas fa-sort-amount-down me-2"></i>Topological Sort</h2>
                        
<pre><code class="language-python">from collections import deque, defaultdict

def topological_sort_kahn(num_nodes, edges):
    """
    Kahn's Algorithm (BFS-based)
    Time: O(V + E), Space: O(V)
    Returns topological order or empty list if cycle exists
    """
    # Build graph and compute in-degrees
    graph = defaultdict(list)
    in_degree = [0] * num_nodes
    
    for u, v in edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    # Start with nodes having no prerequisites
    queue = deque([i for i in range(num_nodes) if in_degree[i] == 0])
    result = []
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Check if all nodes are included (no cycle)
    return result if len(result) == num_nodes else []

def topological_sort_dfs(num_nodes, edges):
    """
    DFS-based topological sort
    Time: O(V + E), Space: O(V)
    """
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    
    visited = [0] * num_nodes  # 0: unvisited, 1: visiting, 2: visited
    result = []
    
    def dfs(node):
        if visited[node] == 1:  # Cycle detected
            return False
        if visited[node] == 2:
            return True
        
        visited[node] = 1  # Mark as visiting
        
        for neighbor in graph[node]:
            if not dfs(neighbor):
                return False
        
        visited[node] = 2  # Mark as visited
        result.append(node)
        return True
    
    for i in range(num_nodes):
        if visited[i] == 0:
            if not dfs(i):
                return []  # Cycle detected
    
    return result[::-1]  # Reverse for topological order

# Example: Course Schedule
# 0 -> 1 -> 3
#      |
# 2 ---+
num_courses = 4
prerequisites = [(0, 1), (1, 3), (2, 1)]

print("Topological order (Kahn):", topological_sort_kahn(num_courses, prerequisites))
print("Topological order (DFS):", topological_sort_dfs(num_courses, prerequisites))
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Topological Sort - Kahn's Algorithm (BFS)
// Time: O(V + E), Space: O(V)
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;

class TopologicalSort {
public:
    // Kahn's Algorithm (BFS)
    static std::vector&lt;int&gt; kahnSort(int numNodes, std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; edges) {
        std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; graph;
        std::vector&lt;int&gt; inDegree(numNodes, 0);
        
        for (auto&amp; [u, v] : edges) {
            graph[u].push_back(v);
            inDegree[v]++;
        }
        
        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt; numNodes; i++)
            if (inDegree[i] == 0) q.push(i);
        
        std::vector&lt;int&gt; result;
        while (!q.empty()) {
            int node = q.front(); q.pop();
            result.push_back(node);
            
            for (int neighbor : graph[node]) {
                if (--inDegree[neighbor] == 0)
                    q.push(neighbor);
            }
        }
        
        return (result.size() == numNodes) ? result : std::vector&lt;int&gt;();
    }
    
    // DFS-based topological sort
    static std::vector&lt;int&gt; dfsSort(int numNodes, std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; edges) {
        std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; graph;
        for (auto&amp; [u, v] : edges)
            graph[u].push_back(v);
        
        std::vector&lt;int&gt; visited(numNodes, 0);  // 0=unvisited, 1=visiting, 2=visited
        std::vector&lt;int&gt; result;
        
        std::function&lt;bool(int)&gt; dfs = [&amp;](int node) {
            if (visited[node] == 1) return false;  // Cycle
            if (visited[node] == 2) return true;
            
            visited[node] = 1;
            for (int neighbor : graph[node])
                if (!dfs(neighbor)) return false;
            
            visited[node] = 2;
            result.push_back(node);
            return true;
        };
        
        for (int i = 0; i &lt; numNodes; i++)
            if (visited[i] == 0 &amp;&amp; !dfs(i)) return {};
        
        std::reverse(result.begin(), result.end());
        return result;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Topological Sort - Kahn's Algorithm (BFS) and DFS
import java.util.*;

class TopologicalSort {
    // Kahn's Algorithm (BFS)
    public static List&lt;Integer&gt; kahnSort(int numNodes, int[][] edges) {
        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();
        int[] inDegree = new int[numNodes];
        
        for (int[] edge : edges) {
            graph.computeIfAbsent(edge[0], k -&gt; new ArrayList&lt;&gt;()).add(edge[1]);
            inDegree[edge[1]]++;
        }
        
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; numNodes; i++)
            if (inDegree[i] == 0) queue.offer(i);
        
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        while (!queue.isEmpty()) {
            int node = queue.poll();
            result.add(node);
            
            for (int neighbor : graph.getOrDefault(node, new ArrayList&lt;&gt;())) {
                if (--inDegree[neighbor] == 0)
                    queue.offer(neighbor);
            }
        }
        
        return (result.size() == numNodes) ? result : new ArrayList&lt;&gt;();
    }
    
    // DFS-based topological sort
    public static List&lt;Integer&gt; dfsSort(int numNodes, int[][] edges) {
        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();
        for (int[] edge : edges)
            graph.computeIfAbsent(edge[0], k -&gt; new ArrayList&lt;&gt;()).add(edge[1]);
        
        int[] visited = new int[numNodes];  // 0=unvisited, 1=visiting, 2=visited
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        
        for (int i = 0; i &lt; numNodes; i++)
            if (visited[i] == 0 &amp;&amp; !dfs(graph, i, visited, result))
                return new ArrayList&lt;&gt;();
        
        Collections.reverse(result);
        return result;
    }
    
    private static boolean dfs(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int node,
                               int[] visited, List&lt;Integer&gt; result) {
        if (visited[node] == 1) return false;  // Cycle
        if (visited[node] == 2) return true;
        
        visited[node] = 1;
        for (int neighbor : graph.getOrDefault(node, new ArrayList&lt;&gt;()))
            if (!dfs(graph, neighbor, visited, result)) return false;
        
        visited[node] = 2;
        result.add(node);
        return true;
    }
}
</code></pre>

                        <!-- DP Introduction -->
                        <h2 id="dp-intro"><i class="fas fa-brain me-2"></i>Dynamic Programming Introduction</h2>
                        
                        <p><strong>Dynamic Programming (DP)</strong> solves problems by breaking them into overlapping subproblems, storing solutions to avoid recomputation. It's essential for optimization problems.</p>
                        
                        <div class="highlight-box">
                            <h4><i class="fas fa-key me-2"></i>DP Characteristics</h4>
                            <ul>
                                <li><strong>Optimal Substructure:</strong> Optimal solution contains optimal solutions to subproblems</li>
                                <li><strong>Overlapping Subproblems:</strong> Same subproblems solved multiple times</li>
                                <li><strong>Memoization:</strong> Top-down approach with caching</li>
                                <li><strong>Tabulation:</strong> Bottom-up approach building solution iteratively</li>
                            </ul>
                        </div>

                        <h3>Fibonacci - DP Example</h3>
                        
<pre><code class="language-python">def fib_recursive(n):
    """
    Naive recursive - O(2^n) time!
    """
    if n <= 1:
        return n
    return fib_recursive(n-1) + fib_recursive(n-2)

def fib_memoization(n, memo=None):
    """
    Top-down with memoization - O(n) time, O(n) space
    """
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]
    
    if n <= 1:
        return n
    
    memo[n] = fib_memoization(n-1, memo) + fib_memoization(n-2, memo)
    return memo[n]

def fib_tabulation(n):
    """
    Bottom-up tabulation - O(n) time, O(n) space
    """
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

def fib_optimized(n):
    """
    Space-optimized - O(n) time, O(1) space
    """
    if n <= 1:
        return n
    
    prev2, prev1 = 0, 1
    
    for _ in range(2, n + 1):
        curr = prev1 + prev2
        prev2 = prev1
        prev1 = curr
    
    return prev1

# Compare all approaches
n = 30
print(f"Fibonacci({n}):")
print(f"  Memoization: {fib_memoization(n)}")
print(f"  Tabulation: {fib_tabulation(n)}")
print(f"  Optimized: {fib_optimized(n)}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Fibonacci - DP Approaches
#include &lt;vector&gt;
#include &lt;unordered_map&gt;

class Fibonacci {
public:
    // Top-down with memoization - O(n) time, O(n) space
    static int memoization(int n, std::unordered_map&lt;int, int&gt;&amp; memo) {
        if (n &lt;= 1) return n;
        if (memo.count(n)) return memo[n];
        return memo[n] = memoization(n - 1, memo) + memoization(n - 2, memo);
    }
    
    // Bottom-up tabulation - O(n) time, O(n) space
    static int tabulation(int n) {
        if (n &lt;= 1) return n;
        std::vector&lt;int&gt; dp(n + 1);
        dp[0] = 0; dp[1] = 1;
        for (int i = 2; i &lt;= n; i++)
            dp[i] = dp[i-1] + dp[i-2];
        return dp[n];
    }
    
    // Space-optimized - O(n) time, O(1) space
    static int optimized(int n) {
        if (n &lt;= 1) return n;
        int prev2 = 0, prev1 = 1;
        for (int i = 2; i &lt;= n; i++) {
            int curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Fibonacci - DP Approaches
import java.util.*;

class Fibonacci {
    // Top-down with memoization - O(n) time, O(n) space
    public static int memoization(int n, Map&lt;Integer, Integer&gt; memo) {
        if (n &lt;= 1) return n;
        if (memo.containsKey(n)) return memo.get(n);
        int result = memoization(n - 1, memo) + memoization(n - 2, memo);
        memo.put(n, result);
        return result;
    }
    
    // Bottom-up tabulation - O(n) time, O(n) space
    public static int tabulation(int n) {
        if (n &lt;= 1) return n;
        int[] dp = new int[n + 1];
        dp[0] = 0; dp[1] = 1;
        for (int i = 2; i &lt;= n; i++)
            dp[i] = dp[i-1] + dp[i-2];
        return dp[n];
    }
    
    // Space-optimized - O(n) time, O(1) space
    public static int optimized(int n) {
        if (n &lt;= 1) return n;
        int prev2 = 0, prev1 = 1;
        for (int i = 2; i &lt;= n; i++) {
            int curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
}
</code></pre>

                        <!-- DP Patterns -->
                        <h2 id="dp-patterns"><i class="fas fa-puzzle-piece me-2"></i>Common DP Patterns</h2>
                        
                        <h3>1D DP: Climbing Stairs</h3>
                        
<pre><code class="language-python">def climb_stairs(n):
    """
    LeetCode 70: Climbing Stairs
    Ways to reach top climbing 1 or 2 steps at a time
    Time: O(n), Space: O(1)
    """
    if n <= 2:
        return n
    
    prev2, prev1 = 1, 2
    
    for i in range(3, n + 1):
        curr = prev1 + prev2
        prev2 = prev1
        prev1 = curr
    
    return prev1

# Example
for n in [2, 3, 4, 5]:
    print(f"Ways to climb {n} stairs: {climb_stairs(n)}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 70: Climbing Stairs
// Time: O(n), Space: O(1)

class ClimbStairs {
public:
    static int climbStairs(int n) {
        if (n &lt;= 2) return n;
        
        int prev2 = 1, prev1 = 2;
        for (int i = 3; i &lt;= n; i++) {
            int curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 70: Climbing Stairs
// Time: O(n), Space: O(1)

class ClimbStairs {
    public static int climbStairs(int n) {
        if (n &lt;= 2) return n;
        
        int prev2 = 1, prev1 = 2;
        for (int i = 3; i &lt;= n; i++) {
            int curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
}
</code></pre>

                        <h3>1D DP: House Robber</h3>
                        
<pre><code class="language-python">def house_robber(nums):
    """
    LeetCode 198: House Robber
    Max money robbing non-adjacent houses
    Time: O(n), Space: O(1)
    """
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    # dp[i] = max(rob this house + dp[i-2], skip this house + dp[i-1])
    prev2 = nums[0]
    prev1 = max(nums[0], nums[1])
    
    for i in range(2, len(nums)):
        curr = max(nums[i] + prev2, prev1)
        prev2 = prev1
        prev1 = curr
    
    return prev1

# Example
houses = [2, 7, 9, 3, 1]
print(f"Houses: {houses}")
print(f"Max robbery: {house_robber(houses)}")  # 12 (2 + 9 + 1)
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 198: House Robber
// Time: O(n), Space: O(1)
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class HouseRobber {
public:
    static int rob(std::vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;
        if (nums.size() == 1) return nums[0];
        
        int prev2 = nums[0];
        int prev1 = std::max(nums[0], nums[1]);
        
        for (int i = 2; i &lt; nums.size(); i++) {
            int curr = std::max(nums[i] + prev2, prev1);
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 198: House Robber
// Time: O(n), Space: O(1)

class HouseRobber {
    public static int rob(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        if (nums.length == 1) return nums[0];
        
        int prev2 = nums[0];
        int prev1 = Math.max(nums[0], nums[1]);
        
        for (int i = 2; i &lt; nums.length; i++) {
            int curr = Math.max(nums[i] + prev2, prev1);
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
}
</code></pre>

                        <h3>2D DP: Longest Common Subsequence</h3>
                        
<pre><code class="language-python">def longest_common_subsequence(text1, text2):
    """
    LeetCode 1143: Longest Common Subsequence
    Time: O(m*n), Space: O(m*n)
    """
    m, n = len(text1), len(text2)
    
    # dp[i][j] = LCS of text1[0:i] and text2[0:j]
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

# Example
text1 = "abcde"
text2 = "ace"
print(f"LCS of '{text1}' and '{text2}': {longest_common_subsequence(text1, text2)}")  # 3
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 1143: Longest Common Subsequence
// Time: O(m*n), Space: O(m*n)
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class LongestCommonSubsequence {
public:
    static int longestCommonSubsequence(std::string text1, std::string text2) {
        int m = text1.size(), n = text2.size();
        std::vector&lt;std::vector&lt;int&gt;&gt; dp(m + 1, std::vector&lt;int&gt;(n + 1, 0));
        
        for (int i = 1; i &lt;= m; i++) {
            for (int j = 1; j &lt;= n; j++) {
                if (text1[i-1] == text2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = std::max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[m][n];
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 1143: Longest Common Subsequence
// Time: O(m*n), Space: O(m*n)

class LongestCommonSubsequence {
    public static int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i &lt;= m; i++) {
            for (int j = 1; j &lt;= n; j++) {
                if (text1.charAt(i-1) == text2.charAt(j-1))
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[m][n];
    }
}
</code></pre>

                        <h3>2D DP: Coin Change</h3>
                        
<pre><code class="language-python">def coin_change(coins, amount):
    """
    LeetCode 322: Coin Change
    Minimum coins to make amount
    Time: O(amount * len(coins)), Space: O(amount)
    """
    # dp[i] = minimum coins to make amount i
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1

def coin_change_ways(coins, amount):
    """
    LeetCode 518: Coin Change 2
    Number of ways to make amount
    """
    dp = [0] * (amount + 1)
    dp[0] = 1
    
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    
    return dp[amount]

# Examples
coins = [1, 2, 5]
amount = 11
print(f"Coins: {coins}, Amount: {amount}")
print(f"Min coins: {coin_change(coins, amount)}")  # 3 (5+5+1)
print(f"Number of ways: {coin_change_ways(coins, amount)}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 322: Coin Change (min coins)
// LeetCode 518: Coin Change 2 (number of ways)
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;limits&gt;

class CoinChange {
public:
    // Min coins to make amount
    static int coinChange(std::vector&lt;int&gt;&amp; coins, int amount) {
        std::vector&lt;int&gt; dp(amount + 1, std::numeric_limits&lt;int&gt;::max());
        dp[0] = 0;
        
        for (int i = 1; i &lt;= amount; i++) {
            for (int coin : coins) {
                if (coin &lt;= i &amp;&amp; dp[i - coin] != std::numeric_limits&lt;int&gt;::max())
                    dp[i] = std::min(dp[i], dp[i - coin] + 1);
            }
        }
        return dp[amount] == std::numeric_limits&lt;int&gt;::max() ? -1 : dp[amount];
    }
    
    // Number of ways to make amount
    static int coinChangeWays(std::vector&lt;int&gt;&amp; coins, int amount) {
        std::vector&lt;int&gt; dp(amount + 1, 0);
        dp[0] = 1;
        
        for (int coin : coins) {
            for (int i = coin; i &lt;= amount; i++)
                dp[i] += dp[i - coin];
        }
        return dp[amount];
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 322: Coin Change (min coins)
// LeetCode 518: Coin Change 2 (number of ways)
import java.util.*;

class CoinChange {
    // Min coins to make amount
    public static int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        
        for (int i = 1; i &lt;= amount; i++) {
            for (int coin : coins) {
                if (coin &lt;= i &amp;&amp; dp[i - coin] != Integer.MAX_VALUE)
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
    
    // Number of ways to make amount
    public static int coinChangeWays(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        
        for (int coin : coins) {
            for (int i = coin; i &lt;= amount; i++)
                dp[i] += dp[i - coin];
        }
        return dp[amount];
    }
}
</code></pre>

                        <h3>Knapsack Problem</h3>
                        
<pre><code class="language-python">def knapsack_01(weights, values, capacity):
    """
    0/1 Knapsack Problem
    Each item can be taken at most once
    Time: O(n * capacity), Space: O(capacity)
    """
    n = len(weights)
    
    # Space-optimized: 1D array
    dp = [0] * (capacity + 1)
    
    for i in range(n):
        # Traverse backwards to avoid using same item twice
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]

def knapsack_unbounded(weights, values, capacity):
    """
    Unbounded Knapsack
    Each item can be taken multiple times
    """
    dp = [0] * (capacity + 1)
    
    for w in range(1, capacity + 1):
        for i in range(len(weights)):
            if weights[i] <= w:
                dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]

# Example
weights = [1, 2, 3, 4]
values = [10, 20, 30, 40]
capacity = 5

print(f"Weights: {weights}")
print(f"Values: {values}")
print(f"Capacity: {capacity}")
print(f"0/1 Knapsack: {knapsack_01(weights, values, capacity)}")  # 50
print(f"Unbounded Knapsack: {knapsack_unbounded(weights, values, capacity)}")  # 50
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Knapsack Problems
// 0/1 Knapsack and Unbounded Knapsack
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class Knapsack {
public:
    // 0/1 Knapsack - each item at most once
    static int knapsack01(std::vector&lt;int&gt;&amp; weights, std::vector&lt;int&gt;&amp; values, int capacity) {
        int n = weights.size();
        std::vector&lt;int&gt; dp(capacity + 1, 0);
        
        for (int i = 0; i &lt; n; i++) {
            // Traverse backwards to avoid using same item twice
            for (int w = capacity; w &gt;= weights[i]; w--)
                dp[w] = std::max(dp[w], dp[w - weights[i]] + values[i]);
        }
        return dp[capacity];
    }
    
    // Unbounded Knapsack - unlimited of each item
    static int knapsackUnbounded(std::vector&lt;int&gt;&amp; weights, std::vector&lt;int&gt;&amp; values, int capacity) {
        std::vector&lt;int&gt; dp(capacity + 1, 0);
        
        for (int w = 1; w &lt;= capacity; w++) {
            for (int i = 0; i &lt; weights.size(); i++) {
                if (weights[i] &lt;= w)
                    dp[w] = std::max(dp[w], dp[w - weights[i]] + values[i]);
            }
        }
        return dp[capacity];
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Knapsack Problems
// 0/1 Knapsack and Unbounded Knapsack

class Knapsack {
    // 0/1 Knapsack - each item at most once
    public static int knapsack01(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[] dp = new int[capacity + 1];
        
        for (int i = 0; i &lt; n; i++) {
            // Traverse backwards to avoid using same item twice
            for (int w = capacity; w &gt;= weights[i]; w--)
                dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
        }
        return dp[capacity];
    }
    
    // Unbounded Knapsack - unlimited of each item
    public static int knapsackUnbounded(int[] weights, int[] values, int capacity) {
        int[] dp = new int[capacity + 1];
        
        for (int w = 1; w &lt;= capacity; w++) {
            for (int i = 0; i &lt; weights.length; i++) {
                if (weights[i] &lt;= w)
                    dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
            }
        }
        return dp[capacity];
    }
}
</code></pre>

                        <!-- Greedy Algorithms -->
                        <h2 id="greedy"><i class="fas fa-star me-2"></i>Greedy Algorithms</h2>
                        
                        <p><strong>Greedy algorithms</strong> make locally optimal choices at each step, hoping to find a global optimum. They work when the problem has the greedy-choice property.</p>
                        
                        <h3>Activity Selection</h3>
                        
<pre><code class="language-python">def activity_selection(activities):
    """
    Select maximum non-overlapping activities
    activities: list of (start, end) tuples
    Time: O(n log n), Space: O(1)
    """
    # Sort by end time
    activities = sorted(activities, key=lambda x: x[1])
    
    selected = [activities[0]]
    last_end = activities[0][1]
    
    for start, end in activities[1:]:
        if start >= last_end:  # Non-overlapping
            selected.append((start, end))
            last_end = end
    
    return selected

# Example
activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)]
result = activity_selection(activities)
print(f"Activities: {len(activities)}")
print(f"Max selected: {len(result)}")
print(f"Selected: {result}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Activity Selection - Maximum non-overlapping activities
// Time: O(n log n), Space: O(1)
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class ActivitySelection {
public:
    static std::vector&lt;std::pair&lt;int, int&gt;&gt; select(
            std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; activities) {
        // Sort by end time
        std::sort(activities.begin(), activities.end(),
                  [](auto&amp; a, auto&amp; b) { return a.second &lt; b.second; });
        
        std::vector&lt;std::pair&lt;int, int&gt;&gt; selected;
        selected.push_back(activities[0]);
        int lastEnd = activities[0].second;
        
        for (int i = 1; i &lt; activities.size(); i++) {
            if (activities[i].first &gt;= lastEnd) {
                selected.push_back(activities[i]);
                lastEnd = activities[i].second;
            }
        }
        return selected;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Activity Selection - Maximum non-overlapping activities
// Time: O(n log n), Space: O(1)
import java.util.*;

class ActivitySelection {
    public static List&lt;int[]&gt; select(int[][] activities) {
        // Sort by end time
        Arrays.sort(activities, (a, b) -&gt; a[1] - b[1]);
        
        List&lt;int[]&gt; selected = new ArrayList&lt;&gt;();
        selected.add(activities[0]);
        int lastEnd = activities[0][1];
        
        for (int i = 1; i &lt; activities.length; i++) {
            if (activities[i][0] &gt;= lastEnd) {
                selected.add(activities[i]);
                lastEnd = activities[i][1];
            }
        }
        return selected;
    }
}
</code></pre>

                        <h3>Jump Game</h3>
                        
<pre><code class="language-python">def can_jump(nums):
    """
    LeetCode 55: Jump Game
    Can you reach the last index?
    Time: O(n), Space: O(1)
    """
    max_reach = 0
    
    for i, jump in enumerate(nums):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + jump)
    
    return True

def min_jumps(nums):
    """
    LeetCode 45: Jump Game II
    Minimum jumps to reach end
    Time: O(n), Space: O(1)
    """
    if len(nums) <= 1:
        return 0
    
    jumps = 0
    current_end = 0
    farthest = 0
    
    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        
        if i == current_end:
            jumps += 1
            current_end = farthest
            
            if current_end >= len(nums) - 1:
                break
    
    return jumps

# Examples
nums1 = [2, 3, 1, 1, 4]
print(f"Array: {nums1}")
print(f"Can reach end: {can_jump(nums1)}")  # True
print(f"Min jumps: {min_jumps(nums1)}")  # 2

nums2 = [3, 2, 1, 0, 4]
print(f"\nArray: {nums2}")
print(f"Can reach end: {can_jump(nums2)}")  # False
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 55: Jump Game & LeetCode 45: Jump Game II
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class JumpGame {
public:
    // Can reach the last index?
    static bool canJump(std::vector&lt;int&gt;&amp; nums) {
        int maxReach = 0;
        for (int i = 0; i &lt; nums.size(); i++) {
            if (i &gt; maxReach) return false;
            maxReach = std::max(maxReach, i + nums[i]);
        }
        return true;
    }
    
    // Minimum jumps to reach end
    static int minJumps(std::vector&lt;int&gt;&amp; nums) {
        if (nums.size() &lt;= 1) return 0;
        
        int jumps = 0, currentEnd = 0, farthest = 0;
        for (int i = 0; i &lt; nums.size() - 1; i++) {
            farthest = std::max(farthest, i + nums[i]);
            if (i == currentEnd) {
                jumps++;
                currentEnd = farthest;
                if (currentEnd &gt;= nums.size() - 1) break;
            }
        }
        return jumps;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 55: Jump Game & LeetCode 45: Jump Game II

class JumpGame {
    // Can reach the last index?
    public static boolean canJump(int[] nums) {
        int maxReach = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            if (i &gt; maxReach) return false;
            maxReach = Math.max(maxReach, i + nums[i]);
        }
        return true;
    }
    
    // Minimum jumps to reach end
    public static int minJumps(int[] nums) {
        if (nums.length &lt;= 1) return 0;
        
        int jumps = 0, currentEnd = 0, farthest = 0;
        for (int i = 0; i &lt; nums.length - 1; i++) {
            farthest = Math.max(farthest, i + nums[i]);
            if (i == currentEnd) {
                jumps++;
                currentEnd = farthest;
                if (currentEnd &gt;= nums.length - 1) break;
            }
        }
        return jumps;
    }
}
</code></pre>

                        <h3>Interval Scheduling</h3>
                        
<pre><code class="language-python">def erase_overlap_intervals(intervals):
    """
    LeetCode 435: Non-overlapping Intervals
    Minimum intervals to remove for no overlap
    Time: O(n log n), Space: O(1)
    """
    if not intervals:
        return 0
    
    # Sort by end time
    intervals.sort(key=lambda x: x[1])
    
    removals = 0
    prev_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] < prev_end:  # Overlap
            removals += 1
        else:
            prev_end = intervals[i][1]
    
    return removals

def merge_intervals(intervals):
    """
    LeetCode 56: Merge Intervals
    Time: O(n log n), Space: O(n)
    """
    if not intervals:
        return []
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    merged = [intervals[0]]
    
    for start, end in intervals[1:]:
        if start <= merged[-1][1]:  # Overlap
            merged[-1][1] = max(merged[-1][1], end)
        else:
            merged.append([start, end])
    
    return merged

# Examples
intervals1 = [[1, 2], [2, 3], [3, 4], [1, 3]]
print(f"Intervals: {intervals1}")
print(f"Remove to eliminate overlap: {erase_overlap_intervals(intervals1)}")  # 1

intervals2 = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(f"\nIntervals: {intervals2}")
print(f"Merged: {merge_intervals(intervals2)}")  # [[1,6],[8,10],[15,18]]
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 435: Non-overlapping Intervals
// LeetCode 56: Merge Intervals
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class IntervalScheduling {
public:
    // Min removals for no overlap
    static int eraseOverlapIntervals(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; intervals) {
        if (intervals.empty()) return 0;
        
        std::sort(intervals.begin(), intervals.end(),
                  [](auto&amp; a, auto&amp; b) { return a[1] &lt; b[1]; });
        
        int removals = 0, prevEnd = intervals[0][1];
        for (int i = 1; i &lt; intervals.size(); i++) {
            if (intervals[i][0] &lt; prevEnd)
                removals++;
            else
                prevEnd = intervals[i][1];
        }
        return removals;
    }
    
    // Merge overlapping intervals
    static std::vector&lt;std::vector&lt;int&gt;&gt; mergeIntervals(
            std::vector&lt;std::vector&lt;int&gt;&gt;&amp; intervals) {
        if (intervals.empty()) return {};
        
        std::sort(intervals.begin(), intervals.end());
        std::vector&lt;std::vector&lt;int&gt;&gt; merged = {intervals[0]};
        
        for (int i = 1; i &lt; intervals.size(); i++) {
            if (intervals[i][0] &lt;= merged.back()[1])
                merged.back()[1] = std::max(merged.back()[1], intervals[i][1]);
            else
                merged.push_back(intervals[i]);
        }
        return merged;
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 435: Non-overlapping Intervals
// LeetCode 56: Merge Intervals
import java.util.*;

class IntervalScheduling {
    // Min removals for no overlap
    public static int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 0) return 0;
        
        Arrays.sort(intervals, (a, b) -&gt; a[1] - b[1]);
        
        int removals = 0, prevEnd = intervals[0][1];
        for (int i = 1; i &lt; intervals.length; i++) {
            if (intervals[i][0] &lt; prevEnd)
                removals++;
            else
                prevEnd = intervals[i][1];
        }
        return removals;
    }
    
    // Merge overlapping intervals
    public static int[][] mergeIntervals(int[][] intervals) {
        if (intervals.length == 0) return new int[][]{};
        
        Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]);
        List&lt;int[]&gt; merged = new ArrayList&lt;&gt;();
        merged.add(intervals[0]);
        
        for (int i = 1; i &lt; intervals.length; i++) {
            int[] last = merged.get(merged.size() - 1);
            if (intervals[i][0] &lt;= last[1])
                last[1] = Math.max(last[1], intervals[i][1]);
            else
                merged.add(intervals[i]);
        }
        return merged.toArray(new int[merged.size()][]);
    }
}
</code></pre>

                        <!-- Backtracking -->
                        <h2 id="backtracking"><i class="fas fa-undo me-2"></i>Backtracking</h2>
                        
                        <p><strong>Backtracking</strong> is a systematic way to explore all possible solutions by building candidates incrementally and abandoning ("backtracking") candidates that fail to satisfy constraints.</p>
                        
                        <div class="highlight-box">
                            <h4><i class="fas fa-code me-2"></i>Backtracking Template</h4>
                            <pre><code>def backtrack(candidate):
    if is_solution(candidate):
        output(candidate)
        return
    
    for choice in choices:
        if is_valid(choice):
            make_choice(choice)
            backtrack(candidate)
            undo_choice(choice)  # Backtrack</code></pre>
                        </div>

                        <h3>Permutations</h3>
                        
<pre><code class="language-python">def permute(nums):
    """
    LeetCode 46: Permutations
    Generate all permutations
    Time: O(n! * n), Space: O(n)
    """
    result = []
    
    def backtrack(current, remaining):
        if not remaining:
            result.append(current[:])
            return
        
        for i in range(len(remaining)):
            # Make choice
            current.append(remaining[i])
            
            # Recurse with remaining elements
            backtrack(current, remaining[:i] + remaining[i+1:])
            
            # Undo choice
            current.pop()
    
    backtrack([], nums)
    return result

# Example
nums = [1, 2, 3]
print(f"Permutations of {nums}:")
for perm in permute(nums):
    print(f"  {perm}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 46: Permutations
// Time: O(n! * n), Space: O(n)
#include &lt;vector&gt;

class Permutations {
public:
    static std::vector&lt;std::vector&lt;int&gt;&gt; permute(std::vector&lt;int&gt;&amp; nums) {
        std::vector&lt;std::vector&lt;int&gt;&gt; result;
        std::vector&lt;int&gt; current;
        std::vector&lt;bool&gt; used(nums.size(), false);
        backtrack(nums, current, used, result);
        return result;
    }
    
private:
    static void backtrack(std::vector&lt;int&gt;&amp; nums, std::vector&lt;int&gt;&amp; current,
                          std::vector&lt;bool&gt;&amp; used, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; result) {
        if (current.size() == nums.size()) {
            result.push_back(current);
            return;
        }
        
        for (int i = 0; i &lt; nums.size(); i++) {
            if (used[i]) continue;
            
            current.push_back(nums[i]);
            used[i] = true;
            backtrack(nums, current, used, result);
            current.pop_back();
            used[i] = false;
        }
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 46: Permutations
// Time: O(n! * n), Space: O(n)
import java.util.*;

class Permutations {
    public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        backtrack(nums, new ArrayList&lt;&gt;(), new boolean[nums.length], result);
        return result;
    }
    
    private static void backtrack(int[] nums, List&lt;Integer&gt; current,
                                   boolean[] used, List&lt;List&lt;Integer&gt;&gt; result) {
        if (current.size() == nums.length) {
            result.add(new ArrayList&lt;&gt;(current));
            return;
        }
        
        for (int i = 0; i &lt; nums.length; i++) {
            if (used[i]) continue;
            
            current.add(nums[i]);
            used[i] = true;
            backtrack(nums, current, used, result);
            current.remove(current.size() - 1);
            used[i] = false;
        }
    }
}
</code></pre>

                        <h3>Subsets</h3>
                        
<pre><code class="language-python">def subsets(nums):
    """
    LeetCode 78: Subsets
    Generate all subsets (power set)
    Time: O(2^n * n), Space: O(n)
    """
    result = []
    
    def backtrack(start, current):
        result.append(current[:])
        
        for i in range(start, len(nums)):
            current.append(nums[i])
            backtrack(i + 1, current)
            current.pop()
    
    backtrack(0, [])
    return result

def subsets_with_dup(nums):
    """
    LeetCode 90: Subsets II (with duplicates)
    """
    result = []
    nums.sort()
    
    def backtrack(start, current):
        result.append(current[:])
        
        for i in range(start, len(nums)):
            # Skip duplicates
            if i > start and nums[i] == nums[i-1]:
                continue
            current.append(nums[i])
            backtrack(i + 1, current)
            current.pop()
    
    backtrack(0, [])
    return result

# Example
nums = [1, 2, 3]
print(f"Subsets of {nums}:")
for subset in subsets(nums):
    print(f"  {subset}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 78: Subsets & LeetCode 90: Subsets II
// Time: O(2^n * n), Space: O(n)
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class Subsets {
public:
    static std::vector&lt;std::vector&lt;int&gt;&gt; subsets(std::vector&lt;int&gt;&amp; nums) {
        std::vector&lt;std::vector&lt;int&gt;&gt; result;
        std::vector&lt;int&gt; current;
        backtrack(nums, 0, current, result);
        return result;
    }
    
    // With duplicates
    static std::vector&lt;std::vector&lt;int&gt;&gt; subsetsWithDup(std::vector&lt;int&gt;&amp; nums) {
        std::sort(nums.begin(), nums.end());
        std::vector&lt;std::vector&lt;int&gt;&gt; result;
        std::vector&lt;int&gt; current;
        backtrackWithDup(nums, 0, current, result);
        return result;
    }
    
private:
    static void backtrack(std::vector&lt;int&gt;&amp; nums, int start,
                          std::vector&lt;int&gt;&amp; current, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; result) {
        result.push_back(current);
        for (int i = start; i &lt; nums.size(); i++) {
            current.push_back(nums[i]);
            backtrack(nums, i + 1, current, result);
            current.pop_back();
        }
    }
    
    static void backtrackWithDup(std::vector&lt;int&gt;&amp; nums, int start,
                                  std::vector&lt;int&gt;&amp; current, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; result) {
        result.push_back(current);
        for (int i = start; i &lt; nums.size(); i++) {
            if (i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue;  // Skip dups
            current.push_back(nums[i]);
            backtrackWithDup(nums, i + 1, current, result);
            current.pop_back();
        }
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 78: Subsets & LeetCode 90: Subsets II
import java.util.*;

class Subsets {
    public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        backtrack(nums, 0, new ArrayList&lt;&gt;(), result);
        return result;
    }
    
    // With duplicates
    public static List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        backtrackWithDup(nums, 0, new ArrayList&lt;&gt;(), result);
        return result;
    }
    
    private static void backtrack(int[] nums, int start,
                                   List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result) {
        result.add(new ArrayList&lt;&gt;(current));
        for (int i = start; i &lt; nums.length; i++) {
            current.add(nums[i]);
            backtrack(nums, i + 1, current, result);
            current.remove(current.size() - 1);
        }
    }
    
    private static void backtrackWithDup(int[] nums, int start,
                                          List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result) {
        result.add(new ArrayList&lt;&gt;(current));
        for (int i = start; i &lt; nums.length; i++) {
            if (i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue;  // Skip dups
            current.add(nums[i]);
            backtrackWithDup(nums, i + 1, current, result);
            current.remove(current.size() - 1);
        }
    }
}
</code></pre>

                        <h3>Combination Sum</h3>
                        
<pre><code class="language-python">def combination_sum(candidates, target):
    """
    LeetCode 39: Combination Sum
    Find combinations that sum to target (can reuse)
    Time: O(2^target), Space: O(target)
    """
    result = []
    
    def backtrack(start, current, remaining):
        if remaining == 0:
            result.append(current[:])
            return
        
        if remaining < 0:
            return
        
        for i in range(start, len(candidates)):
            current.append(candidates[i])
            # Can reuse same element, so pass i (not i+1)
            backtrack(i, current, remaining - candidates[i])
            current.pop()
    
    backtrack(0, [], target)
    return result

# Example
candidates = [2, 3, 6, 7]
target = 7
print(f"Candidates: {candidates}, Target: {target}")
print(f"Combinations:")
for combo in combination_sum(candidates, target):
    print(f"  {combo}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 39: Combination Sum
// Time: O(2^target), Space: O(target)
#include &lt;vector&gt;

class CombinationSum {
public:
    static std::vector&lt;std::vector&lt;int&gt;&gt; combinationSum(
            std::vector&lt;int&gt;&amp; candidates, int target) {
        std::vector&lt;std::vector&lt;int&gt;&gt; result;
        std::vector&lt;int&gt; current;
        backtrack(candidates, target, 0, current, result);
        return result;
    }
    
private:
    static void backtrack(std::vector&lt;int&gt;&amp; candidates, int remaining, int start,
                          std::vector&lt;int&gt;&amp; current, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; result) {
        if (remaining == 0) {
            result.push_back(current);
            return;
        }
        if (remaining &lt; 0) return;
        
        for (int i = start; i &lt; candidates.size(); i++) {
            current.push_back(candidates[i]);
            backtrack(candidates, remaining - candidates[i], i, current, result);  // i, not i+1
            current.pop_back();
        }
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 39: Combination Sum
// Time: O(2^target), Space: O(target)
import java.util.*;

class CombinationSum {
    public static List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        backtrack(candidates, target, 0, new ArrayList&lt;&gt;(), result);
        return result;
    }
    
    private static void backtrack(int[] candidates, int remaining, int start,
                                   List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result) {
        if (remaining == 0) {
            result.add(new ArrayList&lt;&gt;(current));
            return;
        }
        if (remaining &lt; 0) return;
        
        for (int i = start; i &lt; candidates.length; i++) {
            current.add(candidates[i]);
            backtrack(candidates, remaining - candidates[i], i, current, result);  // i, not i+1
            current.remove(current.size() - 1);
        }
    }
}
</code></pre>

                        <h3>N-Queens</h3>
                        
<pre><code class="language-python">def solve_n_queens(n):
    """
    LeetCode 51: N-Queens
    Place n queens on n×n board with no attacks
    Time: O(n!), Space: O(n)
    """
    result = []
    board = [['.'] * n for _ in range(n)]
    
    # Track columns and diagonals under attack
    cols = set()
    diag1 = set()  # row - col
    diag2 = set()  # row + col
    
    def backtrack(row):
        if row == n:
            result.append([''.join(row) for row in board])
            return
        
        for col in range(n):
            if col in cols or (row - col) in diag1 or (row + col) in diag2:
                continue
            
            # Place queen
            board[row][col] = 'Q'
            cols.add(col)
            diag1.add(row - col)
            diag2.add(row + col)
            
            backtrack(row + 1)
            
            # Remove queen
            board[row][col] = '.'
            cols.remove(col)
            diag1.remove(row - col)
            diag2.remove(row + col)
    
    backtrack(0)
    return result

# Example
n = 4
solutions = solve_n_queens(n)
print(f"{n}-Queens has {len(solutions)} solutions:")
for i, sol in enumerate(solutions):
    print(f"\nSolution {i+1}:")
    for row in sol:
        print(f"  {row}")
</code></pre>

<h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// LeetCode 51: N-Queens
// Time: O(n!), Space: O(n)
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;

class NQueens {
public:
    static std::vector&lt;std::vector&lt;std::string&gt;&gt; solveNQueens(int n) {
        std::vector&lt;std::vector&lt;std::string&gt;&gt; result;
        std::vector&lt;std::string&gt; board(n, std::string(n, '.'));
        std::unordered_set&lt;int&gt; cols, diag1, diag2;
        backtrack(n, 0, board, cols, diag1, diag2, result);
        return result;
    }
    
private:
    static void backtrack(int n, int row, std::vector&lt;std::string&gt;&amp; board,
                          std::unordered_set&lt;int&gt;&amp; cols,
                          std::unordered_set&lt;int&gt;&amp; diag1,
                          std::unordered_set&lt;int&gt;&amp; diag2,
                          std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; result) {
        if (row == n) {
            result.push_back(board);
            return;
        }
        
        for (int col = 0; col &lt; n; col++) {
            if (cols.count(col) || diag1.count(row - col) || diag2.count(row + col))
                continue;
            
            board[row][col] = 'Q';
            cols.insert(col);
            diag1.insert(row - col);
            diag2.insert(row + col);
            
            backtrack(n, row + 1, board, cols, diag1, diag2, result);
            
            board[row][col] = '.';
            cols.erase(col);
            diag1.erase(row - col);
            diag2.erase(row + col);
        }
    }
};
</code></pre>

<h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// LeetCode 51: N-Queens
// Time: O(n!), Space: O(n)
import java.util.*;

class NQueens {
    public static List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {
        List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();
        char[][] board = new char[n][n];
        for (char[] row : board) Arrays.fill(row, '.');
        Set&lt;Integer&gt; cols = new HashSet&lt;&gt;();
        Set&lt;Integer&gt; diag1 = new HashSet&lt;&gt;();
        Set&lt;Integer&gt; diag2 = new HashSet&lt;&gt;();
        backtrack(n, 0, board, cols, diag1, diag2, result);
        return result;
    }
    
    private static void backtrack(int n, int row, char[][] board,
                                   Set&lt;Integer&gt; cols, Set&lt;Integer&gt; diag1, Set&lt;Integer&gt; diag2,
                                   List&lt;List&lt;String&gt;&gt; result) {
        if (row == n) {
            List&lt;String&gt; solution = new ArrayList&lt;&gt;();
            for (char[] r : board) solution.add(new String(r));
            result.add(solution);
            return;
        }
        
        for (int col = 0; col &lt; n; col++) {
            if (cols.contains(col) || diag1.contains(row - col) || diag2.contains(row + col))
                continue;
            
            board[row][col] = 'Q';
            cols.add(col);
            diag1.add(row - col);
            diag2.add(row + col);
            
            backtrack(n, row + 1, board, cols, diag1, diag2, result);
            
            board[row][col] = '.';
            cols.remove(col);
            diag1.remove(row - col);
            diag2.remove(row + col);
        }
    }
}
</code></pre>

                        <!-- LeetCode Problems -->
                        <h2 id="leetcode"><i class="fas fa-code me-2"></i>LeetCode Practice Problems</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-tasks me-2"></i>Essential Problems</h4>
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>#</th>
                                        <th>Problem</th>
                                        <th>Difficulty</th>
                                        <th>Key Concept</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>200</td>
                                        <td>Number of Islands</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Graph DFS/BFS</td>
                                    </tr>
                                    <tr>
                                        <td>207</td>
                                        <td>Course Schedule</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Topological Sort</td>
                                    </tr>
                                    <tr>
                                        <td>743</td>
                                        <td>Network Delay Time</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Dijkstra</td>
                                    </tr>
                                    <tr>
                                        <td>70</td>
                                        <td>Climbing Stairs</td>
                                        <td><span class="badge badge-easy">Easy</span></td>
                                        <td>1D DP</td>
                                    </tr>
                                    <tr>
                                        <td>198</td>
                                        <td>House Robber</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>1D DP</td>
                                    </tr>
                                    <tr>
                                        <td>322</td>
                                        <td>Coin Change</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>DP - Unbounded Knapsack</td>
                                    </tr>
                                    <tr>
                                        <td>1143</td>
                                        <td>Longest Common Subsequence</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>2D DP</td>
                                    </tr>
                                    <tr>
                                        <td>55</td>
                                        <td>Jump Game</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Greedy</td>
                                    </tr>
                                    <tr>
                                        <td>46</td>
                                        <td>Permutations</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Backtracking</td>
                                    </tr>
                                    <tr>
                                        <td>51</td>
                                        <td>N-Queens</td>
                                        <td><span class="badge badge-hard">Hard</span></td>
                                        <td>Backtracking</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Series Navigation -->
                        <h2 id="series-nav"><i class="fas fa-book me-2"></i>Complete DSA Series</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-graduation-cap me-2"></i>FAANG Interview Preparation - Series Complete! 🎉</h4>
                            <div class="row">
                                <div class="col-md-6">
                                    <ol>
                                        <li><a href="dsa-foundations-memory-complexity.html">Foundations & Complexity</a></li>
                                        <li><a href="dsa-recursion-complete-guide.html">Recursion Deep Dive</a></li>
                                        <li><a href="dsa-arrays-adt-operations.html">Arrays & ADT</a></li>
                                        <li><a href="dsa-strings-manipulation.html">Strings & Manipulation</a></li>
                                        <li><a href="dsa-matrices-special-sparse.html">Matrices & Sparse</a></li>
                                        <li><a href="dsa-linked-lists-guide.html">Linked Lists</a></li>
                                    </ol>
                                </div>
                                <div class="col-md-6">
                                    <ol start="7">
                                        <li><a href="dsa-stack-applications.html">Stack & Applications</a></li>
                                        <li><a href="dsa-queue-implementations.html">Queue & Variants</a></li>
                                        <li><a href="dsa-trees-fundamentals.html">Trees & Traversals</a></li>
                                        <li><a href="dsa-bst-avl-redblack.html">BST & Balanced Trees</a></li>
                                        <li><a href="dsa-heaps-sorting-hashing.html">Heaps, Sorting & Hashing</a></li>
                                        <li><strong>Graphs, DP, Greedy & Backtracking (You are here)</strong></li>
                                    </ol>
                                </div>
                            </div>
                            <div class="alert alert-success mt-3">
                                <i class="fas fa-check-circle me-2"></i><strong>Congratulations!</strong> You've completed the entire 12-part DSA series. Practice these concepts consistently on LeetCode, and you'll be well-prepared for FAANG interviews!
                            </div>
                        </div>

                        <!-- Related Posts -->
                        <div class="related-posts">
                            <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 11: Heaps, Sorting & Hashing</h5>
                                <p class="text-muted small mb-2">Priority queues, sorting algorithms, and hash table implementations.</p>
                                <a href="dsa-heaps-sorting-hashing.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 1: DSA Foundations</h5>
                                <p class="text-muted small mb-2">Start from the beginning with memory, complexity analysis, and Big O notation.</p>
                                <a href="dsa-foundations-memory-complexity.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 10: BST & Balanced Trees</h5>
                                <p class="text-muted small mb-2">Binary Search Trees, AVL Trees, and Red-Black Trees with rotations.</p>
                                <a href="dsa-bst-avl-redblack.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest"><i class="fab fa-pinterest-p"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Scroll to Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Cookie Consent -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>
    
    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    </body>
</html>
