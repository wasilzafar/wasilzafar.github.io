<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Part 2 of the Complete DSA Series: Master recursion fundamentals, types (tail, head, tree, indirect, nested), call stack tracing, recurrence relations, Master Theorem, and classic problems for FAANG interviews." />
    <meta name="author" content="Wasil Zafar" />
    <meta name="keywords" content="Recursion, DSA, Call Stack, Tail Recursion, Head Recursion, Tree Recursion, Master Theorem, Recurrence Relations, Fibonacci, Tower of Hanoi, FAANG Interview, LeetCode" />
    <meta property="og:title" content="Complete DSA Series Part 2: Recursion Complete Guide" />
    <meta property="og:description" content="Master recursion: types, call stack tracing, recurrence relations, Master Theorem, and classic problems for FAANG interviews." />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2026-01-27" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />
    
    <title>Complete DSA Series Part 2: Recursion Complete Guide - Wasil Zafar</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />

    <!-- Prism.js Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <!-- Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE']
        });
        gtag('consent', 'default', {
            'ad_storage': 'granted',
            'ad_user_data': 'granted',
            'ad_personalization': 'granted',
            'analytics_storage': 'granted'
        });
        gtag('set', 'url_passthrough', true);
    </script>

    <!-- Google Tag Manager -->
    <script>
        (function(w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s),
                dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-PBS8M2JR');
    </script>

    <style>
        /* Blog Hero */
        .blog-hero {
            background: linear-gradient(135deg, var(--color-navy) 0%, var(--color-blue) 100%);
            color: white;
            padding: 80px 0;
        }
        .blog-meta {
            font-size: 0.95rem;
            color: var(--color-teal);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        .print-btn {
            background: var(--color-teal);
            color: white;
            border: none;
            padding: 0.4rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        .print-btn:hover {
            background: var(--color-crimson);
            transform: translateY(-1px);
        }
        .reading-time {
            display: inline-block;
            background: var(--color-crimson);
            color: white;
            padding: 0.3rem 0.8rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .back-link {
            display: inline-block;
            color: white;
            text-decoration: none;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
            opacity: 0.9;
        }
        .back-link:hover {
            color: var(--color-teal);
            opacity: 1;
            transform: translateX(-5px);
        }

        /* Print Styles */
        @media print {
            .print-btn, nav, .navbar, footer, .back-link, .related-posts,
            .scroll-to-top, .toc-toggle-btn, .sidenav-toc, .sidenav-overlay { 
                display: none !important; 
            }
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            .blog-content h2 { color: var(--color-navy) !important; border-bottom: 3px solid var(--color-teal) !important; }
            .blog-content h3 { color: var(--color-blue) !important; }
            .blog-content h4 { color: var(--color-crimson) !important; }
            .highlight-box { background: rgba(59, 151, 151, 0.1) !important; border-left: 4px solid var(--color-teal) !important; }
            pre[class*="language-"] { page-break-inside: avoid; border: 1px solid #ddd !important; }
            body { font-size: 12pt; line-height: 1.6; }
        }

        /* Blog Content */
        .blog-content {
            max-width: 900px;
            margin: 0 auto;
            font-size: 1.05rem;
            line-height: 1.8;
            color: #333;
        }
        .blog-content h2 {
            font-size: 1.8rem;
            font-weight: 700;
            margin-top: 2.5rem;
            margin-bottom: 1.5rem;
            color: var(--color-navy);
            border-bottom: 3px solid var(--color-teal);
            padding-bottom: 0.5rem;
        }
        .blog-content h3 {
            font-size: 1.3rem;
            font-weight: 600;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: var(--color-blue);
        }
        .blog-content h4 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--color-crimson);
        }
        .blog-content p {
            margin-bottom: 1.2rem;
            text-align: justify;
        }
        .blog-content strong {
            color: var(--color-crimson);
        }

        /* Components */
        .highlight-box {
            background: rgba(59, 151, 151, 0.1);
            border-left: 4px solid var(--color-teal);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 4px;
        }
        .experiment-card {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: all 0.3s ease;
        }
        .experiment-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }
        .experiment-card h4 {
            color: var(--color-crimson);
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        /* Code Blocks */
        pre[class*="language-"] {
            position: relative;
            margin: 1.5rem 0;
            padding-top: 3rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        div.code-toolbar > .toolbar {
            opacity: 1;
            display: flex;
            gap: 0.5rem;
        }
        div.code-toolbar > .toolbar > .toolbar-item > button {
            background: var(--color-teal);
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        div.code-toolbar > .toolbar > .toolbar-item > button:hover {
            background: var(--color-blue);
        }
        div.code-toolbar > .toolbar > .toolbar-item > select {
            background: var(--color-navy);
            color: white;
            border: 1px solid var(--color-teal);
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
        }
        div.code-toolbar > .toolbar > .toolbar-item > select:hover {
            background: var(--color-blue);
        }

        /* TOC Toggle Button */
        .toc-toggle-btn {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            width: 50px;
            height: 50px;
            background: var(--color-teal);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 151, 151, 0.4);
            transition: all 0.3s ease;
            z-index: 1049;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .toc-toggle-btn:hover {
            background: var(--color-crimson);
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(191, 9, 47, 0.5);
        }

        .toc-toggle-btn:active {
            transform: scale(0.95);
        }

        /* Side Navigation */
        .sidenav-toc {
            height: calc(100% - 64px);
            width: 0;
            position: fixed;
            z-index: 1050;
            top: 64px;
            left: 0;
            background: linear-gradient(135deg, var(--color-navy) 0%, var(--color-blue) 100%);
            overflow-x: hidden;
            overflow-y: auto;
            transition: width 0.4s ease;
            padding-top: 30px;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3);
        }
        .sidenav-toc.open { width: 350px; }
        .sidenav-toc .toc-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 30px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--color-teal);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        .sidenav-toc.open .toc-header { opacity: 1; visibility: visible; }
        .sidenav-toc .closebtn {
            font-size: 32px;
            color: white;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .sidenav-toc .closebtn:hover { color: var(--color-crimson); transform: rotate(90deg); }
        .sidenav-toc h3 { color: white; margin: 0; font-weight: 700; font-size: 1.3rem; }
        .sidenav-toc ol { list-style: decimal; padding-left: 30px; margin: 0; color: rgba(255, 255, 255, 0.9); }
        .sidenav-toc ol li { margin-bottom: 8px; }
        .sidenav-toc ul { list-style-type: lower-alpha; padding-left: 30px; margin: 8px 0; }
        .sidenav-toc ul li { margin-bottom: 6px; }
        .sidenav-toc a {
            padding: 12px 30px;
            text-decoration: none;
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.85);
            display: block;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
            position: relative;
        }
        .sidenav-toc a:hover { color: white; background: rgba(59, 151, 151, 0.2); border-left-color: var(--color-teal); padding-left: 35px; }
        .sidenav-toc a.active { color: white; background: rgba(191, 9, 47, 0.3); border-left-color: var(--color-crimson); font-weight: 600; }
        .sidenav-toc a.active::before { content: '▶'; position: absolute; left: 15px; font-size: 0.7rem; color: var(--color-crimson); }
        .sidenav-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1049;
        }
        .sidenav-overlay.show { display: block; }

        /* Scroll-to-Top */
        .scroll-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            background: var(--color-teal);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(59, 151, 151, 0.3);
            z-index: 999;
        }
        .scroll-to-top.show { opacity: 1; visibility: visible; }
        .scroll-to-top:hover { background: var(--color-crimson); transform: translateY(-3px); }

        /* Related Posts */
        .related-posts {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 2rem;
            margin-top: 3rem;
        }
        .related-posts h3 { color: var(--color-navy); margin-bottom: 1.5rem; }
        .related-post-item {
            padding: 1rem;
            border-left: 3px solid var(--color-teal);
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }
        .related-post-item:hover { background: white; border-left-color: var(--color-crimson); }
        .related-post-item a { color: var(--color-blue); text-decoration: none; font-weight: 600; }
        .related-post-item a:hover { color: var(--color-crimson); }

        /* Badges */
        .badge.bg-teal { background-color: var(--color-teal) !important; }
        .badge.bg-crimson { background-color: var(--color-crimson) !important; }
        .leetcode-badge { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.3rem 0.8rem; border-radius: 4px; font-size: 0.85rem; font-weight: 600; margin: 0.25rem; }
        .leetcode-easy { background: #00b8a3; color: white; }
        .leetcode-medium { background: #ffc01e; color: #333; }
        .leetcode-hard { background: #ff375f; color: white; }

        @media (max-width: 768px) {
            .sidenav-toc.open { width: 280px; }
            .toc-toggle-btn, .scroll-to-top { width: 45px; height: 45px; font-size: 1rem; }
            .toc-toggle-btn { left: 1rem; bottom: 1rem; }
            .scroll-to-top { right: 1rem; bottom: 1rem; }
        }

        html { scroll-behavior: smooth; }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link">
                    <i class="fas fa-arrow-left me-2"></i>Back to Technology
                </a>
                <h1 class="display-4 fw-bold mb-3">Complete DSA Series Part 2: Recursion Complete Guide</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>January 27, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>30 min read</span>
                    <button onclick="window.print()" class="print-btn" title="Print this article">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
                <p class="lead">Master recursion—the foundation for divide-and-conquer algorithms, tree traversals, and dynamic programming. Learn all recursion types, call stack tracing, recurrence relations, and the Master Theorem.</p>
            </div>
        </div>
    </section>

    <!-- TOC Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents" aria-label="Open Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()" aria-label="Close">&times;</button>
        </div>
        <ol>
            <li>
                <a href="#introduction" onclick="closeNav()">Recursion Fundamentals</a>
                <ul>
                    <li><a href="#introduction" onclick="closeNav()">How Recursion Works</a></li>
                    <li><a href="#call-stack" onclick="closeNav()">Call Stack Tracing</a></li>
                </ul>
            </li>
            <li>
                <a href="#types" onclick="closeNav()">Types of Recursion</a>
                <ul>
                    <li><a href="#tail-recursion" onclick="closeNav()">Tail Recursion</a></li>
                    <li><a href="#head-recursion" onclick="closeNav()">Head Recursion</a></li>
                    <li><a href="#tree-recursion" onclick="closeNav()">Tree Recursion</a></li>
                    <li><a href="#indirect-recursion" onclick="closeNav()">Indirect Recursion</a></li>
                    <li><a href="#nested-recursion" onclick="closeNav()">Nested Recursion</a></li>
                </ul>
            </li>
            <li>
                <a href="#recurrence" onclick="closeNav()">Recurrence Relations</a>
                <ul>
                    <li><a href="#recurrence" onclick="closeNav()">Solving Recurrences</a></li>
                    <li><a href="#master-theorem" onclick="closeNav()">Master Theorem</a></li>
                </ul>
            </li>
            <li>
                <a href="#classic-problems" onclick="closeNav()">Classic Problems</a>
                <ul>
                    <li><a href="#fibonacci" onclick="closeNav()">Fibonacci</a></li>
                    <li><a href="#tower-of-hanoi" onclick="closeNav()">Tower of Hanoi</a></li>
                    <li><a href="#power-function" onclick="closeNav()">Power Function</a></li>
                </ul>
            </li>
            <li>
                <a href="#leetcode" onclick="closeNav()">Practice & Next Steps</a>
                <ul>
                    <li><a href="#leetcode" onclick="closeNav()">LeetCode Problems</a></li>
                    <li><a href="#next-steps" onclick="closeNav()">Next in Series</a></li>
                </ul>
            </li>
        </ol>
    </div>

    <!-- Overlay -->
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Main Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">
                    <div class="blog-content">

                        <!-- Introduction -->
                        <h2 id="introduction"><i class="fas fa-sync-alt me-2" style="color: var(--color-teal);"></i>How Recursion Works</h2>
                        
                        <p>Recursion is a method where a function calls itself to solve a problem by breaking it down into smaller, similar subproblems. Every recursive solution needs two essential components.</p>

                        <div class="experiment-card">
                            <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                            <div class="mb-2">
                                <span class="badge bg-teal me-2">12-Part Series</span>
                                <span class="badge bg-crimson">FAANG Interview Prep</span>
                            </div>
                            <ol>
                                <li><a href="dsa-foundations-memory-complexity.html">Foundations, Memory & Complexity</a></li>
                                <li><strong>Recursion Complete Guide (This Guide)</strong></li>
                                <li><a href="dsa-arrays-adt-operations.html">Arrays & Array ADT</a></li>
                                <li><a href="dsa-strings-manipulation.html">Strings</a></li>
                                <li><a href="dsa-matrices-special-sparse.html">Matrices</a></li>
                                <li><a href="dsa-linked-lists-guide.html">Linked Lists</a></li>
                                <li><a href="dsa-stack-applications.html">Stack</a></li>
                                <li><a href="dsa-queue-implementations.html">Queue</a></li>
                                <li><a href="dsa-trees-fundamentals.html">Trees</a></li>
                                <li><a href="dsa-bst-avl-redblack.html">BST & Balanced Trees</a></li>
                                <li><a href="dsa-heaps-sorting-hashing.html">Heaps, Sorting & Hashing</a></li>
                                <li><a href="dsa-graphs-dp-greedy-backtracking.html">Graphs, DP, Greedy & Backtracking</a></li>
                            </ol>
                        </div>

                        <div class="highlight-box">
                            <h4><i class="fas fa-key me-2"></i>Two Essential Components</h4>
                            <ol class="mb-0">
                                <li><strong>Base Case:</strong> The condition that stops recursion (prevents infinite calls)</li>
                                <li><strong>Recursive Case:</strong> The function calling itself with a modified input that moves toward the base case</li>
                            </ol>
                        </div>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Basic Recursion Structure
def factorial(n):
    # Base Case: Stop when n reaches 0 or 1
    if n <= 1:
        return 1
    
    # Recursive Case: n! = n × (n-1)!
    return n * factorial(n - 1)

# Test
print(f"5! = {factorial(5)}")  # Output: 120
print(f"0! = {factorial(0)}")  # Output: 1
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Basic Recursion Structure in C++
#include &lt;iostream&gt;
using namespace std;

int factorial(int n) {
    // Base Case: Stop when n reaches 0 or 1
    if (n <= 1) {
        return 1;
    }
    
    // Recursive Case: n! = n × (n-1)!
    return n * factorial(n - 1);
}

int main() {
    cout << "5! = " << factorial(5) << endl;  // Output: 120
    cout << "0! = " << factorial(0) << endl;  // Output: 1
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Basic Recursion Structure in Java
public class Factorial {
    // Recursive factorial method
    public static int factorial(int n) {
        // Base Case: Stop when n reaches 0 or 1
        if (n <= 1) {
            return 1;
        }
        
        // Recursive Case: n! = n × (n-1)!
        return n * factorial(n - 1);
    }
    
    public static void main(String[] args) {
        System.out.println("5! = " + factorial(5));  // Output: 120
        System.out.println("0! = " + factorial(0));  // Output: 1
    }
}
</code></pre>

                        <!-- Call Stack -->
                        <h2 id="call-stack"><i class="fas fa-layer-group me-2" style="color: var(--color-teal);"></i>Call Stack Tracing</h2>
                        
                        <p>Understanding how the call stack works is crucial for mastering recursion. Each recursive call creates a new stack frame with its own local variables.</p>

                        <div class="highlight-box">
                            <h4><i class="fas fa-info-circle me-2"></i>What is a Stack Frame?</h4>
                            <p class="mb-0">Every time a function is called, a <strong>stack frame</strong> is pushed onto the call stack containing: the return address, function parameters, and local variables. When the function returns, its frame is popped off. In recursion, each call adds a new frame until the base case is reached, then frames are popped as results are returned.</p>
                        </div>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Visualizing Call Stack for factorial(4)

def factorial_traced(n, depth=0):
    """Factorial with call stack visualization"""
    indent = "  " * depth
    print(f"{indent}factorial({n}) called")
    
    if n <= 1:
        print(f"{indent}factorial({n}) returns 1 (base case)")
        return 1
    
    result = n * factorial_traced(n - 1, depth + 1)
    print(f"{indent}factorial({n}) returns {result}")
    return result

# Trace factorial(4)
print("Call Stack Trace:")
result = factorial_traced(4)
print(f"\nFinal Result: {result}")

# Output:
# factorial(4) called
#   factorial(3) called
#     factorial(2) called
#       factorial(1) called
#       factorial(1) returns 1 (base case)
#     factorial(2) returns 2
#   factorial(3) returns 6
# factorial(4) returns 24
# Final Result: 24
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Visualizing Call Stack for factorial(4) in C++
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int factorial_traced(int n, int depth = 0) {
    string indent(depth * 2, ' ');  // Create indentation
    cout << indent << "factorial(" << n << ") called" << endl;
    
    if (n <= 1) {
        cout << indent << "factorial(" << n << ") returns 1 (base case)" << endl;
        return 1;
    }
    
    int result = n * factorial_traced(n - 1, depth + 1);
    cout << indent << "factorial(" << n << ") returns " << result << endl;
    return result;
}

int main() {
    cout << "Call Stack Trace:" << endl;
    int result = factorial_traced(4);
    cout << "\nFinal Result: " << result << endl;
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Visualizing Call Stack for factorial(4) in Java
public class CallStackTrace {
    public static int factorialTraced(int n, int depth) {
        String indent = "  ".repeat(depth);  // Create indentation
        System.out.println(indent + "factorial(" + n + ") called");
        
        if (n <= 1) {
            System.out.println(indent + "factorial(" + n + ") returns 1 (base case)");
            return 1;
        }
        
        int result = n * factorialTraced(n - 1, depth + 1);
        System.out.println(indent + "factorial(" + n + ") returns " + result);
        return result;
    }
    
    public static void main(String[] args) {
        System.out.println("Call Stack Trace:");
        int result = factorialTraced(4, 0);
        System.out.println("\nFinal Result: " + result);
    }
}
</code></pre>

                        <!-- Types of Recursion -->
                        <h2 id="types"><i class="fas fa-sitemap me-2" style="color: var(--color-teal);"></i>Types of Recursion</h2>

                        <h3 id="tail-recursion">1. Tail Recursion</h3>
                        <p>The recursive call is the <strong>last operation</strong> in the function. Can be optimized by compilers to use constant stack space (Tail Call Optimization).</p>

                        <div class="highlight-box">
                            <h4><i class="fas fa-bolt me-2"></i>Why Tail Recursion Matters</h4>
                            <p class="mb-0">In tail recursion, there's no pending computation after the recursive call returns. This means compilers can reuse the same stack frame for each call (Tail Call Optimization), converting O(n) space to O(1). Languages like Scheme guarantee TCO; C++ and Java do not, but understanding it helps write efficient code.</p>
                        </div>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Tail Recursion - recursive call is last operation
def factorial_tail(n, accumulator=1):
    """
    Tail-recursive factorial
    All computation done BEFORE the recursive call
    """
    if n <= 1:
        return accumulator
    return factorial_tail(n - 1, n * accumulator)  # Last operation

# Test
print(f"Tail recursive: {factorial_tail(5)}")  # Output: 120
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Tail Recursion in C++
#include &lt;iostream&gt;
using namespace std;

int factorial_tail(int n, int accumulator = 1) {
    // Base case
    if (n <= 1) {
        return accumulator;
    }
    // Tail recursive call - computation done before call
    return factorial_tail(n - 1, n * accumulator);
}

int main() {
    cout << "Tail recursive: " << factorial_tail(5) << endl;  // Output: 120
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Tail Recursion in Java
public class TailRecursion {
    public static int factorialTail(int n, int accumulator) {
        // Base case
        if (n <= 1) {
            return accumulator;
        }
        // Tail recursive call
        return factorialTail(n - 1, n * accumulator);
    }
    
    public static void main(String[] args) {
        System.out.println("Tail recursive: " + factorialTail(5, 1));  // Output: 120
    }
}
</code></pre>

                        <h3 id="head-recursion">2. Head Recursion</h3>
                        <p>The recursive call is made <strong>before</strong> any other processing. Work is done during the "unwinding" phase.</p>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Head Recursion - processing after recursive call
def print_numbers_head(n):
    """
    Head-recursive: prints numbers 1 to n
    Processing happens AFTER the recursive call returns
    """
    if n == 0:
        return
    print_numbers_head(n - 1)  # Recursive call FIRST
    print(n)  # Processing AFTER

# Test
print("Head Recursion (1 to 5):")
print_numbers_head(5)  # Output: 1, 2, 3, 4, 5
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Head Recursion in C++
#include &lt;iostream&gt;
using namespace std;

void printNumbersHead(int n) {
    if (n == 0) {
        return;
    }
    printNumbersHead(n - 1);  // Recursive call FIRST
    cout << n << " ";         // Processing AFTER
}

int main() {
    cout << "Head Recursion (1 to 5): ";
    printNumbersHead(5);  // Output: 1 2 3 4 5
    cout << endl;
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Head Recursion in Java
public class HeadRecursion {
    public static void printNumbersHead(int n) {
        if (n == 0) {
            return;
        }
        printNumbersHead(n - 1);  // Recursive call FIRST
        System.out.print(n + " ");  // Processing AFTER
    }
    
    public static void main(String[] args) {
        System.out.print("Head Recursion (1 to 5): ");
        printNumbersHead(5);  // Output: 1 2 3 4 5
        System.out.println();
    }
}
</code></pre>

                        <h3 id="tree-recursion">3. Tree Recursion</h3>
                        <p>The function makes <strong>multiple recursive calls</strong> in each invocation, creating a tree-like call structure.</p>

                        <div class="highlight-box">
                            <h4><i class="fas fa-exclamation-triangle me-2"></i>Warning: Exponential Growth</h4>
                            <p class="mb-0">Tree recursion often leads to exponential time complexity O(2ⁿ) because each call spawns multiple new calls. For Fibonacci, fib(40) makes over 300 million function calls! Always consider memoization or iterative solutions for tree recursive problems.</p>
                        </div>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Tree Recursion - multiple recursive calls
def fibonacci_tree(n):
    """
    Tree-recursive Fibonacci
    Each call branches into two more calls
    Time: O(2^n) - exponential!
    """
    if n <= 1:
        return n
    return fibonacci_tree(n - 1) + fibonacci_tree(n - 2)  # Two calls

# Test
print(f"Fibonacci(10) = {fibonacci_tree(10)}")  # Output: 55
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Tree Recursion in C++
#include &lt;iostream&gt;
using namespace std;

int fibonacci_tree(int n) {
    // Base case
    if (n <= 1) {
        return n;
    }
    // Tree recursion - two recursive calls
    return fibonacci_tree(n - 1) + fibonacci_tree(n - 2);
}

int main() {
    cout << "Fibonacci(10) = " << fibonacci_tree(10) << endl;  // Output: 55
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Tree Recursion in Java
public class TreeRecursion {
    public static int fibonacciTree(int n) {
        // Base case
        if (n <= 1) {
            return n;
        }
        // Tree recursion - two recursive calls
        return fibonacciTree(n - 1) + fibonacciTree(n - 2);
    }
    
    public static void main(String[] args) {
        System.out.println("Fibonacci(10) = " + fibonacciTree(10));  // Output: 55
    }
}
</code></pre>

                        <h3 id="indirect-recursion">4. Indirect Recursion</h3>
                        <p>Function A calls function B, which calls function A (or through more functions in a cycle).</p>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Indirect Recursion - functions call each other
def is_even(n):
    if n == 0:
        return True
    return is_odd(n - 1)

def is_odd(n):
    if n == 0:
        return False
    return is_even(n - 1)

# Test
print(f"is_even(4) = {is_even(4)}")  # True
print(f"is_odd(5) = {is_odd(5)}")    # True
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Indirect Recursion in C++
#include &lt;iostream&gt;
using namespace std;

// Forward declaration needed for indirect recursion
bool isOdd(int n);

bool isEven(int n) {
    if (n == 0) return true;
    return isOdd(n - 1);
}

bool isOdd(int n) {
    if (n == 0) return false;
    return isEven(n - 1);
}

int main() {
    cout << "isEven(4) = " << (isEven(4) ? "true" : "false") << endl;  // true
    cout << "isOdd(5) = " << (isOdd(5) ? "true" : "false") << endl;    // true
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Indirect Recursion in Java
public class IndirectRecursion {
    public static boolean isEven(int n) {
        if (n == 0) return true;
        return isOdd(n - 1);
    }
    
    public static boolean isOdd(int n) {
        if (n == 0) return false;
        return isEven(n - 1);
    }
    
    public static void main(String[] args) {
        System.out.println("isEven(4) = " + isEven(4));  // true
        System.out.println("isOdd(5) = " + isOdd(5));    // true
    }
}
</code></pre>

                        <h3 id="nested-recursion">5. Nested Recursion</h3>
                        <p>A recursive call is used as an <strong>argument</strong> to another recursive call.</p>

                        <div class="highlight-box">
                            <h4><i class="fas fa-infinity me-2"></i>The Ackermann Function</h4>
                            <p class="mb-0">The Ackermann function is the classic example of nested recursion. It grows incredibly fast—A(4,2) has over 19,000 digits! It's used in computer science to demonstrate that not all computable functions are primitive recursive.</p>
                        </div>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Nested Recursion - recursive call as argument
def ackermann(m, n):
    """
    Ackermann function - classic nested recursion example
    Grows EXTREMELY fast
    """
    if m == 0:
        return n + 1
    if n == 0:
        return ackermann(m - 1, 1)
    return ackermann(m - 1, ackermann(m, n - 1))  # Nested!

# Test (only small values!)
print(f"ackermann(2, 2) = {ackermann(2, 2)}")  # Output: 7
print(f"ackermann(3, 2) = {ackermann(3, 2)}")  # Output: 29
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Nested Recursion - Ackermann Function in C++
#include &lt;iostream&gt;
using namespace std;

int ackermann(int m, int n) {
    if (m == 0) {
        return n + 1;
    }
    if (n == 0) {
        return ackermann(m - 1, 1);
    }
    // Nested recursion - inner call's result becomes argument
    return ackermann(m - 1, ackermann(m, n - 1));
}

int main() {
    cout << "ackermann(2, 2) = " << ackermann(2, 2) << endl;  // Output: 7
    cout << "ackermann(3, 2) = " << ackermann(3, 2) << endl;  // Output: 29
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Nested Recursion - Ackermann Function in Java
public class NestedRecursion {
    public static int ackermann(int m, int n) {
        if (m == 0) {
            return n + 1;
        }
        if (n == 0) {
            return ackermann(m - 1, 1);
        }
        // Nested recursion - inner call's result becomes argument
        return ackermann(m - 1, ackermann(m, n - 1));
    }
    
    public static void main(String[] args) {
        System.out.println("ackermann(2, 2) = " + ackermann(2, 2));  // Output: 7
        System.out.println("ackermann(3, 2) = " + ackermann(3, 2));  // Output: 29
    }
}
</code></pre>

                        <!-- Recurrence Relations -->
                        <h2 id="recurrence"><i class="fas fa-calculator me-2" style="color: var(--color-teal);"></i>Recurrence Relations</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-question-circle me-2"></i>What is a Recurrence Relation?</h4>
                            <p>A recurrence relation is a mathematical equation that defines a sequence where each term is expressed in terms of preceding terms. In algorithm analysis, we use recurrence relations to describe the time complexity of recursive algorithms.</p>
                            <p class="mb-0"><strong>General form:</strong> T(n) = [number of subproblems] × T([subproblem size]) + [work done outside recursive calls]</p>
                        </div>

                        <div class="highlight-box">
                            <h4><i class="fas fa-lightbulb me-2"></i>Breaking Down a Recurrence</h4>
                            <p>Consider Merge Sort's recurrence: <strong>T(n) = 2T(n/2) + O(n)</strong></p>
                            <ul>
                                <li><strong>2</strong> = number of subproblems (we split into two halves)</li>
                                <li><strong>T(n/2)</strong> = each subproblem is half the size</li>
                                <li><strong>O(n)</strong> = work to merge the two halves back together</li>
                            </ul>
                            <p class="mb-0">Understanding how to write and solve these equations is crucial for analyzing recursive algorithms!</p>
                        </div>

                        <h3>Common Recurrence Patterns</h3>
                        <p>Here are the most frequently encountered recurrence patterns in algorithm analysis:</p>

                        <div class="experiment-card">
                            <h4><i class="fas fa-chart-bar me-2"></i>Pattern Reference Table</h4>
                            <table class="table table-bordered">
                                <thead class="table-light">
                                    <tr>
                                        <th>Recurrence</th>
                                        <th>Result</th>
                                        <th>Example Algorithm</th>
                                        <th>Explanation</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>T(n) = T(n-1) + O(1)</code></td>
                                        <td>O(n)</td>
                                        <td>Factorial, Linear Search</td>
                                        <td>Constant work, n calls deep</td>
                                    </tr>
                                    <tr>
                                        <td><code>T(n) = T(n-1) + O(n)</code></td>
                                        <td>O(n²)</td>
                                        <td>Selection Sort (recursive)</td>
                                        <td>n + (n-1) + ... + 1 = n(n+1)/2</td>
                                    </tr>
                                    <tr>
                                        <td><code>T(n) = 2T(n/2) + O(n)</code></td>
                                        <td>O(n log n)</td>
                                        <td>Merge Sort, Quick Sort (avg)</td>
                                        <td>n work at each of log n levels</td>
                                    </tr>
                                    <tr>
                                        <td><code>T(n) = 2T(n/2) + O(1)</code></td>
                                        <td>O(n)</td>
                                        <td>Binary tree traversal</td>
                                        <td>Visit each of n nodes once</td>
                                    </tr>
                                    <tr>
                                        <td><code>T(n) = T(n/2) + O(1)</code></td>
                                        <td>O(log n)</td>
                                        <td>Binary Search</td>
                                        <td>Halve problem each step</td>
                                    </tr>
                                    <tr>
                                        <td><code>T(n) = T(n/2) + O(n)</code></td>
                                        <td>O(n)</td>
                                        <td>Finding median</td>
                                        <td>n + n/2 + n/4 + ... = 2n</td>
                                    </tr>
                                    <tr>
                                        <td><code>T(n) = 2T(n-1) + O(1)</code></td>
                                        <td>O(2ⁿ)</td>
                                        <td>Naive Fibonacci, Tower of Hanoi</td>
                                        <td>Exponential - avoid if possible!</td>
                                    </tr>
                                    <tr>
                                        <td><code>T(n) = T(n-1) + T(n-2)</code></td>
                                        <td>O(φⁿ)</td>
                                        <td>Fibonacci (φ ≈ 1.618)</td>
                                        <td>Golden ratio growth</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <h3>Solving Recurrences: Step-by-Step Example</h3>
                        <p>Let's solve T(n) = 2T(n/2) + n using the <strong>substitution method</strong>:</p>

<pre class="ascii-diagram">
Step 1: Expand the recurrence (unroll it)

T(n) = 2T(n/2) + n
     = 2[2T(n/4) + n/2] + n
     = 4T(n/4) + n + n
     = 4[2T(n/8) + n/4] + 2n
     = 8T(n/8) + n + n + n
     = 8T(n/8) + 3n

Step 2: Find the pattern

After k iterations: T(n) = 2ᵏ T(n/2ᵏ) + kn

Step 3: Find when to stop (base case)

When n/2ᵏ = 1, so 2ᵏ = n, meaning k = log₂(n)

Step 4: Substitute back

T(n) = n × T(1) + n × log₂(n)
     = n × O(1) + n log n
     = O(n log n)  ✓
</pre>

                        <!-- Master Theorem -->
                        <h2 id="master-theorem"><i class="fas fa-graduation-cap me-2" style="color: var(--color-teal);"></i>Master Theorem</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-magic me-2"></i>The Power of the Master Theorem</h4>
                            <p>The Master Theorem is a "cookbook" method that lets you instantly determine the complexity of many divide-and-conquer algorithms without manual expansion. It works for recurrences of this form:</p>
                            <p class="mb-0" style="font-size: 1.2rem; text-align: center;"><strong>T(n) = aT(n/b) + f(n)</strong></p>
                            <p class="mt-2">Where:</p>
                            <ul class="mb-0">
                                <li><strong>a ≥ 1</strong> = number of subproblems</li>
                                <li><strong>b > 1</strong> = factor by which input size is divided</li>
                                <li><strong>f(n)</strong> = cost of work done outside the recursive calls</li>
                            </ul>
                        </div>

                        <div class="highlight-box">
                            <h4><i class="fas fa-book me-2"></i>The Three Cases</h4>
                            <p>Let <strong>k = log<sub>b</sub>(a)</strong> (this represents the "work done by recursion"). Compare f(n) to n<sup>k</sup>:</p>
                            <table class="table table-bordered">
                                <thead class="table-light">
                                    <tr>
                                        <th>Case</th>
                                        <th>Condition</th>
                                        <th>Result</th>
                                        <th>Intuition</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>1</strong></td>
                                        <td>f(n) = O(n<sup>c</sup>) where c < k</td>
                                        <td>T(n) = Θ(n<sup>k</sup>)</td>
                                        <td>Recursion dominates</td>
                                    </tr>
                                    <tr>
                                        <td><strong>2</strong></td>
                                        <td>f(n) = Θ(n<sup>k</sup>)</td>
                                        <td>T(n) = Θ(n<sup>k</sup> log n)</td>
                                        <td>Work is evenly distributed</td>
                                    </tr>
                                    <tr>
                                        <td><strong>3</strong></td>
                                        <td>f(n) = Ω(n<sup>c</sup>) where c > k</td>
                                        <td>T(n) = Θ(f(n))</td>
                                        <td>Non-recursive work dominates</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <h3>Master Theorem Examples</h3>

                        <div class="experiment-card">
                            <h4><span class="bias-tag">Example 1</span> Merge Sort: T(n) = 2T(n/2) + O(n)</h4>
                            <ul>
                                <li><strong>a = 2</strong> (two subproblems)</li>
                                <li><strong>b = 2</strong> (each is half the size)</li>
                                <li><strong>f(n) = n</strong> (merging takes linear time)</li>
                                <li><strong>k = log₂(2) = 1</strong></li>
                                <li>f(n) = n = Θ(n¹) = Θ(n<sup>k</sup>) → <strong>Case 2!</strong></li>
                                <li><strong>Result: T(n) = Θ(n log n)</strong></li>
                            </ul>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="bias-tag">Example 2</span> Binary Search: T(n) = T(n/2) + O(1)</h4>
                            <ul>
                                <li><strong>a = 1</strong> (one subproblem)</li>
                                <li><strong>b = 2</strong> (half the size)</li>
                                <li><strong>f(n) = 1</strong> (constant comparison)</li>
                                <li><strong>k = log₂(1) = 0</strong></li>
                                <li>f(n) = 1 = Θ(n⁰) = Θ(n<sup>k</sup>) → <strong>Case 2!</strong></li>
                                <li><strong>Result: T(n) = Θ(log n)</strong></li>
                            </ul>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="bias-tag">Example 3</span> Karatsuba Multiplication: T(n) = 3T(n/2) + O(n)</h4>
                            <ul>
                                <li><strong>a = 3</strong> (three subproblems)</li>
                                <li><strong>b = 2</strong> (each is half the size)</li>
                                <li><strong>f(n) = n</strong> (linear work to combine)</li>
                                <li><strong>k = log₂(3) ≈ 1.585</strong></li>
                                <li>f(n) = n = O(n¹), and 1 < 1.585 → <strong>Case 1!</strong></li>
                                <li><strong>Result: T(n) = Θ(n<sup>1.585</sup>) ≈ O(n<sup>1.58</sup>)</strong></li>
                            </ul>
                            <p class="mb-0"><em>This is better than the naive O(n²) multiplication!</em></p>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="bias-tag">Example 4</span> Strassen's Matrix Multiplication: T(n) = 7T(n/2) + O(n²)</h4>
                            <ul>
                                <li><strong>a = 7</strong> (seven subproblems)</li>
                                <li><strong>b = 2</strong> (each matrix is half the dimension)</li>
                                <li><strong>f(n) = n²</strong> (matrix additions)</li>
                                <li><strong>k = log₂(7) ≈ 2.807</strong></li>
                                <li>f(n) = n² = O(n²), and 2 < 2.807 → <strong>Case 1!</strong></li>
                                <li><strong>Result: T(n) = Θ(n<sup>2.807</sup>) ≈ O(n<sup>2.81</sup>)</strong></li>
                            </ul>
                            <p class="mb-0"><em>Better than naive O(n³) matrix multiplication!</em></p>
                        </div>

                        <div class="highlight-box">
                            <h4><i class="fas fa-exclamation-triangle me-2"></i>When Master Theorem Doesn't Apply</h4>
                            <p>The Master Theorem has limitations. It <strong>doesn't work</strong> for:</p>
                            <ul>
                                <li>Non-constant subproblem sizes: T(n) = T(n/2) + T(n/3) + n</li>
                                <li>Subtract recurrences: T(n) = T(n-1) + n (use substitution instead)</li>
                                <li>Non-polynomial f(n): T(n) = 2T(n/2) + n log n (special case, use extended theorem)</li>
                                <li>a < 1 or b ≤ 1 (violates theorem prerequisites)</li>
                            </ul>
                            <p class="mb-0">For these cases, use the <strong>substitution method</strong> or <strong>recursion tree method</strong>.</p>
                        </div>

                        <!-- Classic Problems -->
                        <h2 id="classic-problems"><i class="fas fa-trophy me-2" style="color: var(--color-teal);"></i>Classic Recursive Problems</h2>

                        <h3 id="fibonacci">Fibonacci Sequence</h3>

                        <div class="experiment-card">
                            <h4><i class="fas fa-seedling me-2"></i>The Fibonacci Story</h4>
                            <p>The Fibonacci sequence was introduced to Western mathematics by Italian mathematician Leonardo of Pisa (nicknamed Fibonacci) in his 1202 book "Liber Abaci". He used it to model rabbit population growth:</p>
                            <ul>
                                <li>Month 1: Start with 1 pair of rabbits</li>
                                <li>Month 2: Still 1 pair (too young to reproduce)</li>
                                <li>Month 3: 2 pairs (original pair has 1 offspring)</li>
                                <li>Month 4: 3 pairs (original pair has another offspring)</li>
                                <li>Month 5: 5 pairs, Month 6: 8 pairs, and so on...</li>
                            </ul>
                            <p class="mb-0"><strong>The sequence:</strong> 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144... where each number is the sum of the two preceding ones.</p>
                        </div>

                        <div class="highlight-box">
                            <h4><i class="fas fa-book me-2"></i>Mathematical Definition</h4>
                            <p>The Fibonacci sequence is defined recursively as:</p>
                            <ul>
                                <li><strong>Base cases:</strong> F(0) = 0, F(1) = 1</li>
                                <li><strong>Recursive case:</strong> F(n) = F(n-1) + F(n-2) for n ≥ 2</li>
                            </ul>
                            <p class="mb-0">This naturally leads to a recursive solution, but the naive approach has exponential time complexity due to repeated calculations. We'll explore three approaches to optimize it.</p>
                        </div>

                        <h4>Approach 1: Naive Tree Recursion - O(2<sup>n</sup>)</h4>
                        <p>The simplest implementation directly follows the mathematical definition, but it's extremely inefficient because it recalculates the same values many times:</p>

<pre class="ascii-diagram">
                    fib(5)
                   /      \
              fib(4)      fib(3)
             /    \        /    \
         fib(3)  fib(2)  fib(2)  fib(1)
         /   \    /   \    /   \
     fib(2) fib(1) ...  ...  ...

Notice how fib(3) is calculated twice, fib(2) is calculated 3 times!
This exponential growth makes naive recursion impractical for n > 40.
</pre>

                        <h4><i class="fab fa-python me-2"></i>Python - Naive Fibonacci</h4>
<pre><code class="language-python"># Fibonacci - Naive Tree Recursion
# Time Complexity: O(2^n) - exponential
# Space Complexity: O(n) - recursion stack depth

def fib_naive(n):
    """Calculate nth Fibonacci number using naive recursion."""
    # Base cases
    if n <= 1:
        return n
    # Recursive case: F(n) = F(n-1) + F(n-2)
    return fib_naive(n - 1) + fib_naive(n - 2)

# Test - only works reasonably for small n
for i in range(11):
    print(f"F({i}) = {fib_naive(i)}")
# Output: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++ - Naive Fibonacci</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// Naive Tree Recursion - O(2^n) time
int fib_naive(int n) {
    // Base cases
    if (n <= 1) {
        return n;
    }
    // Recursive case
    return fib_naive(n - 1) + fib_naive(n - 2);
}

int main() {
    cout << "Fibonacci Sequence (Naive):" << endl;
    for (int i = 0; i <= 10; i++) {
        cout << "F(" << i << ") = " << fib_naive(i) << endl;
    }
    // Output: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java - Naive Fibonacci</h4>
<pre><code class="language-java">public class FibonacciNaive {
    // Naive Tree Recursion - O(2^n) time
    public static int fibNaive(int n) {
        // Base cases
        if (n <= 1) {
            return n;
        }
        // Recursive case
        return fibNaive(n - 1) + fibNaive(n - 2);
    }
    
    public static void main(String[] args) {
        System.out.println("Fibonacci Sequence (Naive):");
        for (int i = 0; i <= 10; i++) {
            System.out.println("F(" + i + ") = " + fibNaive(i));
        }
        // Output: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
    }
}
</code></pre>

                        <h4>Approach 2: Memoization (Top-Down DP) - O(n)</h4>
                        <p>We can dramatically improve performance by storing already-computed values in a cache (memo). This technique is called <strong>memoization</strong> and is the foundation of Dynamic Programming:</p>

                        <h4><i class="fab fa-python me-2"></i>Python - Memoized Fibonacci</h4>
<pre><code class="language-python"># Fibonacci - Memoization (Top-Down DP)
# Time Complexity: O(n) - each value computed once
# Space Complexity: O(n) - memo dictionary + recursion stack

def fib_memo(n, memo=None):
    """Calculate nth Fibonacci with memoization."""
    if memo is None:
        memo = {}
    
    # Check if already computed
    if n in memo:
        return memo[n]
    
    # Base cases
    if n <= 1:
        return n
    
    # Compute and store in memo
    memo[n] = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)
    return memo[n]

# Now we can calculate much larger values efficiently!
print(f"F(50) = {fib_memo(50)}")   # 12586269025
print(f"F(100) = {fib_memo(100)}") # 354224848179261915075
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++ - Memoized Fibonacci</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
using namespace std;

// Memoization using hash map - O(n) time
unordered_map&lt;int, long long&gt; memo;

long long fib_memo(int n) {
    // Check if already computed
    if (memo.find(n) != memo.end()) {
        return memo[n];
    }
    
    // Base cases
    if (n <= 1) {
        return n;
    }
    
    // Compute and store in memo
    memo[n] = fib_memo(n - 1) + fib_memo(n - 2);
    return memo[n];
}

int main() {
    cout << "Fibonacci with Memoization:" << endl;
    cout << "F(50) = " << fib_memo(50) << endl;  // 12586269025
    
    // Reset memo for clean test
    memo.clear();
    for (int i = 0; i <= 15; i++) {
        cout << "F(" << i << ") = " << fib_memo(i) << endl;
    }
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java - Memoized Fibonacci</h4>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;

public class FibonacciMemo {
    // Use HashMap for memoization
    private static Map&lt;Integer, Long&gt; memo = new HashMap&lt;&gt;();
    
    public static long fibMemo(int n) {
        // Check if already computed
        if (memo.containsKey(n)) {
            return memo.get(n);
        }
        
        // Base cases
        if (n <= 1) {
            return n;
        }
        
        // Compute and store in memo
        long result = fibMemo(n - 1) + fibMemo(n - 2);
        memo.put(n, result);
        return result;
    }
    
    public static void main(String[] args) {
        System.out.println("Fibonacci with Memoization:");
        System.out.println("F(50) = " + fibMemo(50));  // 12586269025
        
        // Print sequence
        memo.clear();
        for (int i = 0; i <= 15; i++) {
            System.out.println("F(" + i + ") = " + fibMemo(i));
        }
    }
}
</code></pre>

                        <h4>Approach 3: Iterative (Bottom-Up DP) - O(n) time, O(1) space</h4>
                        <p>The most efficient approach uses iteration instead of recursion. We only need to track the last two values, reducing space complexity to O(1):</p>

                        <h4><i class="fab fa-python me-2"></i>Python - Iterative Fibonacci</h4>
<pre><code class="language-python"># Fibonacci - Iterative (Bottom-Up DP)
# Time Complexity: O(n)
# Space Complexity: O(1) - only two variables!

def fib_iterative(n):
    """Calculate nth Fibonacci iteratively - most efficient!"""
    if n <= 1:
        return n
    
    # Only track the last two values
    prev2, prev1 = 0, 1  # F(0), F(1)
    
    for i in range(2, n + 1):
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    
    return prev1

# Test all three approaches
print("Iterative approach (O(1) space):")
print(f"F(50) = {fib_iterative(50)}")   # 12586269025
print(f"F(100) = {fib_iterative(100)}") # 354224848179261915075
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++ - Iterative Fibonacci</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// Iterative approach - O(n) time, O(1) space
long long fib_iterative(int n) {
    if (n <= 1) {
        return n;
    }
    
    // Only track the last two values
    long long prev2 = 0, prev1 = 1;
    
    for (int i = 2; i <= n; i++) {
        long long current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }
    
    return prev1;
}

int main() {
    cout << "Fibonacci Iterative (O(1) space):" << endl;
    cout << "F(50) = " << fib_iterative(50) << endl;  // 12586269025
    
    // Print sequence
    for (int i = 0; i <= 15; i++) {
        cout << "F(" << i << ") = " << fib_iterative(i) << endl;
    }
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java - Iterative Fibonacci</h4>
<pre><code class="language-java">public class FibonacciIterative {
    // Iterative approach - O(n) time, O(1) space
    public static long fibIterative(int n) {
        if (n <= 1) {
            return n;
        }
        
        // Only track the last two values
        long prev2 = 0, prev1 = 1;
        
        for (int i = 2; i <= n; i++) {
            long current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
    }
    
    public static void main(String[] args) {
        System.out.println("Fibonacci Iterative (O(1) space):");
        System.out.println("F(50) = " + fibIterative(50));  // 12586269025
        
        // Print sequence
        for (int i = 0; i <= 15; i++) {
            System.out.println("F(" + i + ") = " + fibIterative(i));
        }
    }
}
</code></pre>

                        <div class="highlight-box">
                            <h4><i class="fas fa-balance-scale me-2"></i>Complexity Comparison</h4>
                            <table class="table table-bordered">
                                <thead class="table-light">
                                    <tr>
                                        <th>Approach</th>
                                        <th>Time</th>
                                        <th>Space</th>
                                        <th>When to Use</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Naive Recursion</td>
                                        <td>O(2<sup>n</sup>)</td>
                                        <td>O(n)</td>
                                        <td>Only for teaching purposes</td>
                                    </tr>
                                    <tr>
                                        <td>Memoization</td>
                                        <td>O(n)</td>
                                        <td>O(n)</td>
                                        <td>When you need recursion structure</td>
                                    </tr>
                                    <tr>
                                        <td>Iterative</td>
                                        <td>O(n)</td>
                                        <td>O(1)</td>
                                        <td>Best for production code</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <h3 id="tower-of-hanoi">Tower of Hanoi</h3>

                        <div class="experiment-card">
                            <h4><i class="fas fa-history me-2"></i>The Legend</h4>
                            <p>The Tower of Hanoi is a mathematical puzzle invented by French mathematician Édouard Lucas in 1883. Legend has it that in a temple in Hanoi, monks have been moving 64 golden disks between three diamond pegs since the beginning of time. When they finish, the world will end!</p>
                            <p class="mb-0"><strong>Fun fact:</strong> With 64 disks, it would take 2<sup>64</sup> - 1 moves ≈ 18.4 quintillion moves. At one move per second, that's about 585 billion years!</p>
                        </div>

                        <div class="highlight-box">
                            <h4><i class="fas fa-puzzle-piece me-2"></i>Problem Statement</h4>
                            <p>You have 3 pegs (rods) labeled A, B, and C. Peg A has n disks stacked in decreasing size (largest at bottom). Goal: Move all disks from A to C.</p>
                            <p class="mb-0"><strong>Rules:</strong><br>
                            1. Only one disk can be moved at a time<br>
                            2. Each move takes the top disk from one peg and places it on another<br>
                            3. No disk may be placed on top of a smaller disk</p>
                        </div>

                        <h4><i class="fas fa-lightbulb me-2"></i>The Recursive Insight</h4>
                        <p>The key insight is to think recursively: to move n disks from A to C, we need to:</p>
                        <ol>
                            <li><strong>Move n-1 disks</strong> from A to B (using C as helper)</li>
                            <li><strong>Move the largest disk</strong> from A to C</li>
                            <li><strong>Move n-1 disks</strong> from B to C (using A as helper)</li>
                        </ol>

                        <h4><i class="fas fa-project-diagram me-2"></i>Visual Trace for 3 Disks</h4>
<pre><code class="language-plaintext">Initial State:          After Move 1:           After Move 2:
    |     |     |           |     |     |           |     |     |
   [1]    |     |           |     |     |          [1]    |     |
   [2]    |     |          [2]    |     |          [2]    |     |
   [3]    |     |          [3]   [1]    |          [3]   [1]    |
  ─────  ─────  ─────     ─────  ─────  ─────     ─────  ─────  ─────
    A      B      C           A      B      C         A      B      C

After Move 3:           After Move 4:           After Move 5:
    |     |     |           |     |     |           |     |     |
    |     |     |           |     |     |           |     |    [1]
   [2]    |     |           |     |     |           |     |    [2]
   [3]   [1]   [2]          |    [1]   [2]          |    [1]   [2]
  ─────  ─────  ─────     ─────  ─────  ─────     ─────  ─────  ─────
    A      B      C           A      B      C         A      B      C

After Move 6:           After Move 7 (DONE!):
    |     |     |           |     |     |
    |     |    [1]          |     |    [1]
    |     |    [2]          |     |    [2]
   [3]    |     |          [3]    |    [3]
  ─────  ─────  ─────     ─────  ─────  ─────
    A      B      C           A      B      C

The 7 moves: (2^3 - 1 = 7)
1. Move disk 1 from A to C
2. Move disk 2 from A to B
3. Move disk 1 from C to B
4. Move disk 3 from A to C  ← The crucial "middle" move
5. Move disk 1 from B to A
6. Move disk 2 from B to C
7. Move disk 1 from A to C
</code></pre>

                        <h4><i class="fab fa-python me-2"></i>Python</h4>
<pre><code class="language-python"># Tower of Hanoi - Classic Recursion Problem
def tower_of_hanoi(n, source, auxiliary, destination):
    """
    Solve Tower of Hanoi for n disks
    Time Complexity: O(2^n) - must make 2^n - 1 moves
    Space Complexity: O(n) - recursion depth
    """
    if n == 1:
        print(f"Move disk 1 from {source} to {destination}")
        return
    
    # Step 1: Move n-1 disks from source to auxiliary (using destination as helper)
    tower_of_hanoi(n - 1, source, destination, auxiliary)
    
    # Step 2: Move the largest disk from source to destination
    print(f"Move disk {n} from {source} to {destination}")
    
    # Step 3: Move n-1 disks from auxiliary to destination (using source as helper)
    tower_of_hanoi(n - 1, auxiliary, source, destination)

# Test with 3 disks
print("Tower of Hanoi with 3 disks:")
tower_of_hanoi(3, 'A', 'B', 'C')
print(f"\nTotal moves for n disks: 2^n - 1 = {2**3 - 1} moves")
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++</h4>
<pre><code class="language-cpp">// Tower of Hanoi in C++
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

void towerOfHanoi(int n, char source, char auxiliary, char destination) {
    // Base case: only one disk
    if (n == 1) {
        cout << "Move disk 1 from " << source << " to " << destination << endl;
        return;
    }
    
    // Step 1: Move n-1 disks from source to auxiliary
    towerOfHanoi(n - 1, source, destination, auxiliary);
    
    // Step 2: Move largest disk from source to destination
    cout << "Move disk " << n << " from " << source << " to " << destination << endl;
    
    // Step 3: Move n-1 disks from auxiliary to destination
    towerOfHanoi(n - 1, auxiliary, source, destination);
}

int main() {
    int n = 3;
    cout << "Tower of Hanoi with " << n << " disks:" << endl;
    towerOfHanoi(n, 'A', 'B', 'C');
    cout << "\nTotal moves: " << (1 << n) - 1 << endl;  // 2^n - 1
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java</h4>
<pre><code class="language-java">// Tower of Hanoi in Java
public class TowerOfHanoi {
    public static void towerOfHanoi(int n, char source, char auxiliary, char destination) {
        // Base case: only one disk
        if (n == 1) {
            System.out.println("Move disk 1 from " + source + " to " + destination);
            return;
        }
        
        // Step 1: Move n-1 disks from source to auxiliary
        towerOfHanoi(n - 1, source, destination, auxiliary);
        
        // Step 2: Move largest disk from source to destination
        System.out.println("Move disk " + n + " from " + source + " to " + destination);
        
        // Step 3: Move n-1 disks from auxiliary to destination
        towerOfHanoi(n - 1, auxiliary, source, destination);
    }
    
    public static void main(String[] args) {
        int n = 3;
        System.out.println("Tower of Hanoi with " + n + " disks:");
        towerOfHanoi(n, 'A', 'B', 'C');
        System.out.println("\nTotal moves: " + ((1 << n) - 1));  // 2^n - 1
    }
}
</code></pre>

                        <div class="experiment-card">
                            <h4><i class="fas fa-calculator me-2"></i>Tower of Hanoi Complexity Analysis</h4>
                            <p><strong>Recurrence Relation:</strong> T(n) = 2T(n-1) + 1</p>
                            <p><strong>Solving:</strong></p>
                            <ul>
                                <li>T(1) = 1</li>
                                <li>T(2) = 2(1) + 1 = 3</li>
                                <li>T(3) = 2(3) + 1 = 7</li>
                                <li>T(n) = 2ⁿ - 1</li>
                            </ul>
                            <p class="mb-0"><strong>Time Complexity:</strong> O(2ⁿ) — exponential, unavoidable for this problem<br>
                            <strong>Space Complexity:</strong> O(n) — recursion stack depth</p>
                        </div>

                        <h3 id="power-function">Power Function</h3>

                        <div class="experiment-card">
                            <h4><i class="fas fa-bolt me-2"></i>The Exponentiation Problem</h4>
                            <p>Computing x<sup>n</sup> (x raised to the power n) is a fundamental operation in mathematics and computing. While we could simply multiply x by itself n times (O(n) time), there's a brilliant technique called <strong>exponentiation by squaring</strong> that reduces this to O(log n)!</p>
                            <p class="mb-0"><strong>Key insight:</strong> x<sup>8</sup> = ((x<sup>2</sup>)<sup>2</sup>)<sup>2</sup> — only 3 multiplications instead of 7!</p>
                        </div>

                        <div class="highlight-box">
                            <h4><i class="fas fa-book me-2"></i>Mathematical Basis</h4>
                            <p>Exponentiation by squaring exploits two properties:</p>
                            <ul>
                                <li><strong>Even exponent:</strong> x<sup>n</sup> = (x<sup>n/2</sup>)<sup>2</sup></li>
                                <li><strong>Odd exponent:</strong> x<sup>n</sup> = x × x<sup>n-1</sup></li>
                            </ul>
                            <p class="mb-0">This halves the problem size at each step, giving us O(log n) time complexity!</p>
                        </div>

                        <h4>Approach 1: Naive Recursion - O(n)</h4>
                        <p>The straightforward approach multiplies the base n times:</p>

                        <h4><i class="fab fa-python me-2"></i>Python - Naive Power</h4>
<pre><code class="language-python"># Power Function - Naive Recursion
# Time Complexity: O(n) - makes n recursive calls
# Space Complexity: O(n) - recursion stack depth

def power_naive(base, exp):
    """Calculate base^exp using naive recursion."""
    # Base case: x^0 = 1
    if exp == 0:
        return 1
    # Recursive case: x^n = x * x^(n-1)
    return base * power_naive(base, exp - 1)

# Test
print(f"2^10 = {power_naive(2, 10)}")  # 1024
print(f"3^5 = {power_naive(3, 5)}")    # 243
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++ - Naive Power</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// Naive recursion - O(n) time
long long power_naive(int base, int exp) {
    // Base case: x^0 = 1
    if (exp == 0) {
        return 1;
    }
    // Recursive case: x^n = x * x^(n-1)
    return base * power_naive(base, exp - 1);
}

int main() {
    cout << "2^10 = " << power_naive(2, 10) << endl;  // 1024
    cout << "3^5 = " << power_naive(3, 5) << endl;    // 243
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java - Naive Power</h4>
<pre><code class="language-java">public class PowerNaive {
    // Naive recursion - O(n) time
    public static long powerNaive(int base, int exp) {
        // Base case: x^0 = 1
        if (exp == 0) {
            return 1;
        }
        // Recursive case: x^n = x * x^(n-1)
        return base * powerNaive(base, exp - 1);
    }
    
    public static void main(String[] args) {
        System.out.println("2^10 = " + powerNaive(2, 10));  // 1024
        System.out.println("3^5 = " + powerNaive(3, 5));    // 243
    }
}
</code></pre>

                        <h4>Approach 2: Fast Power (Exponentiation by Squaring) - O(log n)</h4>
                        <p>The optimized approach halves the exponent at each step:</p>

<pre class="ascii-diagram">
Computing 2^10 using Fast Power:

2^10 → exp is even → (2^5)^2
    2^5 → exp is odd → 2 × 2^4
        2^4 → exp is even → (2^2)^2
            2^2 → exp is even → (2^1)^2
                2^1 → exp is odd → 2 × 2^0
                    2^0 = 1

Unrolling:
2^0 = 1
2^1 = 2 × 1 = 2
2^2 = 2^2 = 4
2^4 = 4^2 = 16
2^5 = 2 × 16 = 32
2^10 = 32^2 = 1024

Only 4 multiplications instead of 10!
</pre>

                        <h4><i class="fab fa-python me-2"></i>Python - Fast Power</h4>
<pre><code class="language-python"># Power Function - Exponentiation by Squaring
# Time Complexity: O(log n) - halves problem each step
# Space Complexity: O(log n) - recursion stack depth

def power_fast(base, exp):
    """
    Fast exponentiation using squaring technique.
    x^n = (x^(n/2))^2 if n is even
    x^n = x * x^(n-1) if n is odd
    """
    # Base case
    if exp == 0:
        return 1
    
    # Even exponent: square the half-power
    if exp % 2 == 0:
        half = power_fast(base, exp // 2)
        return half * half
    
    # Odd exponent: reduce by 1 and multiply by base
    else:
        return base * power_fast(base, exp - 1)

# Test - works efficiently for large exponents
print(f"2^10 = {power_fast(2, 10)}")    # 1024
print(f"2^30 = {power_fast(2, 30)}")    # 1073741824
print(f"3^20 = {power_fast(3, 20)}")    # 3486784401
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++ - Fast Power</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// Fast power - O(log n) time
long long power_fast(int base, int exp) {
    // Base case
    if (exp == 0) {
        return 1;
    }
    
    // Even exponent: square the half-power
    if (exp % 2 == 0) {
        long long half = power_fast(base, exp / 2);
        return half * half;
    }
    
    // Odd exponent: reduce by 1 and multiply by base
    return base * power_fast(base, exp - 1);
}

int main() {
    cout << "2^10 = " << power_fast(2, 10) << endl;   // 1024
    cout << "2^30 = " << power_fast(2, 30) << endl;   // 1073741824
    cout << "3^20 = " << power_fast(3, 20) << endl;   // 3486784401
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java - Fast Power</h4>
<pre><code class="language-java">public class PowerFast {
    // Fast power - O(log n) time
    public static long powerFast(int base, int exp) {
        // Base case
        if (exp == 0) {
            return 1;
        }
        
        // Even exponent: square the half-power
        if (exp % 2 == 0) {
            long half = powerFast(base, exp / 2);
            return half * half;
        }
        
        // Odd exponent: reduce by 1 and multiply by base
        return base * powerFast(base, exp - 1);
    }
    
    public static void main(String[] args) {
        System.out.println("2^10 = " + powerFast(2, 10));   // 1024
        System.out.println("2^30 = " + powerFast(2, 30));   // 1073741824
        System.out.println("3^20 = " + powerFast(3, 20));   // 3486784401
    }
}
</code></pre>

                        <h4>Approach 3: Iterative Fast Power - O(log n) time, O(1) space</h4>
                        <p>We can eliminate the recursion stack using an iterative approach with bit manipulation:</p>

                        <h4><i class="fab fa-python me-2"></i>Python - Iterative Fast Power</h4>
<pre><code class="language-python"># Power Function - Iterative with Bit Manipulation
# Time Complexity: O(log n)
# Space Complexity: O(1) - no recursion stack!

def power_iterative(base, exp):
    """
    Iterative fast power using binary representation.
    Example: 2^13 = 2^(1101 in binary) = 2^8 * 2^4 * 2^1
    """
    result = 1
    
    while exp > 0:
        # If current bit is 1, multiply result by base
        if exp % 2 == 1:  # or: if exp & 1:
            result *= base
        # Square the base for next bit
        base *= base
        # Move to next bit
        exp //= 2  # or: exp >>= 1
    
    return result

# Test
print(f"2^10 iterative = {power_iterative(2, 10)}")  # 1024
print(f"3^13 iterative = {power_iterative(3, 13)}")  # 1594323
</code></pre>

                        <h4><i class="fab fa-cuttlefish me-2"></i>C++ - Iterative Fast Power</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// Iterative fast power - O(log n) time, O(1) space
long long power_iterative(int base, int exp) {
    long long result = 1;
    long long b = base;  // Use long long to prevent overflow
    
    while (exp > 0) {
        // If current bit is 1, multiply result by base
        if (exp & 1) {  // Same as exp % 2 == 1
            result *= b;
        }
        // Square the base for next bit
        b *= b;
        // Move to next bit
        exp >>= 1;  // Same as exp /= 2
    }
    
    return result;
}

int main() {
    cout << "2^10 iterative = " << power_iterative(2, 10) << endl;  // 1024
    cout << "3^13 iterative = " << power_iterative(3, 13) << endl;  // 1594323
    return 0;
}
</code></pre>

                        <h4><i class="fab fa-java me-2"></i>Java - Iterative Fast Power</h4>
<pre><code class="language-java">public class PowerIterative {
    // Iterative fast power - O(log n) time, O(1) space
    public static long powerIterative(int base, int exp) {
        long result = 1;
        long b = base;  // Use long to prevent overflow
        
        while (exp > 0) {
            // If current bit is 1, multiply result by base
            if ((exp & 1) == 1) {  // Same as exp % 2 == 1
                result *= b;
            }
            // Square the base for next bit
            b *= b;
            // Move to next bit
            exp >>= 1;  // Same as exp /= 2
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        System.out.println("2^10 iterative = " + powerIterative(2, 10));  // 1024
        System.out.println("3^13 iterative = " + powerIterative(3, 13));  // 1594323
    }
}
</code></pre>

                        <div class="highlight-box">
                            <h4><i class="fas fa-balance-scale me-2"></i>Complexity Comparison</h4>
                            <table class="table table-bordered">
                                <thead class="table-light">
                                    <tr>
                                        <th>Approach</th>
                                        <th>Time</th>
                                        <th>Space</th>
                                        <th>When to Use</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Naive</td>
                                        <td>O(n)</td>
                                        <td>O(n)</td>
                                        <td>Small exponents, teaching</td>
                                    </tr>
                                    <tr>
                                        <td>Fast (Recursive)</td>
                                        <td>O(log n)</td>
                                        <td>O(log n)</td>
                                        <td>When recursion is preferred</td>
                                    </tr>
                                    <tr>
                                        <td>Fast (Iterative)</td>
                                        <td>O(log n)</td>
                                        <td>O(1)</td>
                                        <td>Best for production code</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p class="mb-0"><strong>Pro tip:</strong> For modular exponentiation (x<sup>n</sup> mod m), used in cryptography, just add <code>% mod</code> after each multiplication!</p>
                        </div>

                        <!-- LeetCode -->
                        <h2 id="leetcode"><i class="fas fa-code me-2" style="color: var(--color-teal);"></i>LeetCode Practice Problems</h2>

                        <p>Practice these classic recursion problems to solidify your understanding. Each problem is presented with solutions in all three languages.</p>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 509. Fibonacci Number</h4>
                            <p><strong>Problem:</strong> Given n, calculate F(n), where F(n) is the nth Fibonacci number. F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2).</p>
                            
                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 509 - Fibonacci Number
# Time: O(n) with memoization, Space: O(n)

class Solution:
    def fib(self, n: int) -> int:
        memo = {0: 0, 1: 1}
        
        def helper(n):
            if n in memo:
                return memo[n]
            memo[n] = helper(n - 1) + helper(n - 2)
            return memo[n]
        
        return helper(n)

# Test
sol = Solution()
print(sol.fib(10))  # Output: 55
print(sol.fib(20))  # Output: 6765
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
using namespace std;

// LeetCode 509 - Fibonacci Number
// Time: O(n) with memoization
class Solution {
private:
    unordered_map&lt;int, int&gt; memo;
    
    int helper(int n) {
        if (memo.find(n) != memo.end()) {
            return memo[n];
        }
        memo[n] = helper(n - 1) + helper(n - 2);
        return memo[n];
    }
    
public:
    int fib(int n) {
        memo[0] = 0;
        memo[1] = 1;
        return helper(n);
    }
};

int main() {
    Solution sol;
    cout << sol.fib(10) << endl;  // Output: 55
    return 0;
}
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;

// LeetCode 509 - Fibonacci Number
// Time: O(n) with memoization
class Solution {
    private Map&lt;Integer, Integer&gt; memo = new HashMap&lt;&gt;();
    
    public int fib(int n) {
        memo.put(0, 0);
        memo.put(1, 1);
        return helper(n);
    }
    
    private int helper(int n) {
        if (memo.containsKey(n)) {
            return memo.get(n);
        }
        int result = helper(n - 1) + helper(n - 2);
        memo.put(n, result);
        return result;
    }
    
    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(sol.fib(10));  // Output: 55
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 206. Reverse Linked List</h4>
                            <p><strong>Problem:</strong> Given the head of a singly linked list, reverse the list, and return the reversed list.</p>
                            <p><strong>Key Insight:</strong> The recursive approach first reverses the rest of the list, then fixes the links by making the next node point back to current node.</p>
                            
                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 206 - Reverse Linked List (Recursive)
# Time: O(n), Space: O(n) for call stack

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # Base case: empty list or single node
        if not head or not head.next:
            return head
        
        # Recursively reverse the rest of the list
        new_head = self.reverseList(head.next)
        
        # Fix the links: make next node point back to current
        head.next.next = head
        head.next = None  # Current node is now the tail
        
        return new_head

# Helper to create and print list
def create_list(arr):
    if not arr:
        return None
    head = ListNode(arr[0])
    curr = head
    for val in arr[1:]:
        curr.next = ListNode(val)
        curr = curr.next
    return head

def print_list(head):
    vals = []
    while head:
        vals.append(str(head.val))
        head = head.next
    print(" -> ".join(vals))

# Test
sol = Solution()
head = create_list([1, 2, 3, 4, 5])
print("Original:", end=" ")
print_list(head)
reversed_head = sol.reverseList(head)
print("Reversed:", end=" ")
print_list(reversed_head)
# Output: 5 -> 4 -> 3 -> 2 -> 1
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// LeetCode 206 - Reverse Linked List
// Time: O(n), Space: O(n) for call stack

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // Base case: empty list or single node
        if (!head || !head->next) {
            return head;
        }
        
        // Recursively reverse the rest
        ListNode* newHead = reverseList(head->next);
        
        // Fix the links
        head->next->next = head;
        head->next = nullptr;
        
        return newHead;
    }
};

// Helper function to print list
void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Create list: 1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);
    
    cout << "Original: ";
    printList(head);
    
    Solution sol;
    ListNode* reversed = sol.reverseList(head);
    
    cout << "Reversed: ";
    printList(reversed);
    // Output: 5 -> 4 -> 3 -> 2 -> 1
    
    return 0;
}
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 206 - Reverse Linked List
// Time: O(n), Space: O(n) for call stack

class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

class Solution {
    public ListNode reverseList(ListNode head) {
        // Base case: empty list or single node
        if (head == null || head.next == null) {
            return head;
        }
        
        // Recursively reverse the rest
        ListNode newHead = reverseList(head.next);
        
        // Fix the links
        head.next.next = head;
        head.next = null;
        
        return newHead;
    }
    
    // Helper to print list
    public void printList(ListNode head) {
        while (head != null) {
            System.out.print(head.val);
            if (head.next != null) System.out.print(" -> ");
            head = head.next;
        }
        System.out.println();
    }
    
    public static void main(String[] args) {
        // Create list: 1 -> 2 -> 3 -> 4 -> 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        
        Solution sol = new Solution();
        System.out.print("Original: ");
        sol.printList(head);
        
        ListNode reversed = sol.reverseList(head);
        System.out.print("Reversed: ");
        sol.printList(reversed);
        // Output: 5 -> 4 -> 3 -> 2 -> 1
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-medium">Medium</span> 50. Pow(x, n)</h4>
                            <p><strong>Problem:</strong> Implement pow(x, n), which calculates x raised to the power n.</p>
                            <p><strong>Key Insight:</strong> Use fast exponentiation. Handle negative exponents by computing 1/x and using positive n.</p>
                            
                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 50 - Pow(x, n)
# Time: O(log n), Space: O(log n) for recursion stack

class Solution:
    def myPow(self, x: float, n: int) -> float:
        # Handle negative exponent
        if n < 0:
            x = 1 / x
            n = -n
        
        return self.fastPow(x, n)
    
    def fastPow(self, x: float, n: int) -> float:
        # Base case
        if n == 0:
            return 1.0
        
        # Use fast exponentiation
        if n % 2 == 0:
            half = self.fastPow(x, n // 2)
            return half * half
        else:
            return x * self.fastPow(x, n - 1)

# Test
sol = Solution()
print(f"2^10 = {sol.myPow(2, 10)}")     # 1024.0
print(f"2^(-2) = {sol.myPow(2, -2)}")   # 0.25
print(f"2.1^3 = {sol.myPow(2.1, 3)}")   # 9.261
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// LeetCode 50 - Pow(x, n)
// Time: O(log n), Space: O(log n)

class Solution {
public:
    double myPow(double x, int n) {
        // Use long long to handle INT_MIN case
        long long N = n;
        
        // Handle negative exponent
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }
        
        return fastPow(x, N);
    }
    
private:
    double fastPow(double x, long long n) {
        // Base case
        if (n == 0) {
            return 1.0;
        }
        
        // Fast exponentiation
        if (n % 2 == 0) {
            double half = fastPow(x, n / 2);
            return half * half;
        } else {
            return x * fastPow(x, n - 1);
        }
    }
};

int main() {
    Solution sol;
    cout << "2^10 = " << sol.myPow(2, 10) << endl;   // 1024
    cout << "2^(-2) = " << sol.myPow(2, -2) << endl; // 0.25
    cout << "2.1^3 = " << sol.myPow(2.1, 3) << endl; // 9.261
    return 0;
}
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 50 - Pow(x, n)
// Time: O(log n), Space: O(log n)

class Solution {
    public double myPow(double x, int n) {
        // Use long to handle Integer.MIN_VALUE case
        long N = n;
        
        // Handle negative exponent
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }
        
        return fastPow(x, N);
    }
    
    private double fastPow(double x, long n) {
        // Base case
        if (n == 0) {
            return 1.0;
        }
        
        // Fast exponentiation
        if (n % 2 == 0) {
            double half = fastPow(x, n / 2);
            return half * half;
        } else {
            return x * fastPow(x, n - 1);
        }
    }
    
    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println("2^10 = " + sol.myPow(2, 10));   // 1024.0
        System.out.println("2^(-2) = " + sol.myPow(2, -2)); // 0.25
        System.out.println("2.1^3 = " + sol.myPow(2.1, 3)); // 9.261
    }
}
</code></pre>
                        </div>

                        <div class="experiment-card">
                            <h4><span class="leetcode-badge leetcode-easy">Easy</span> 21. Merge Two Sorted Lists</h4>
                            <p><strong>Problem:</strong> Merge two sorted linked lists and return it as a sorted list.</p>
                            <p><strong>Key Insight:</strong> Compare heads, take the smaller one, then recursively merge the rest.</p>
                            
                            <h5><i class="fab fa-python me-2"></i>Python</h5>
<pre><code class="language-python"># LeetCode 21 - Merge Two Sorted Lists
# Time: O(n + m), Space: O(n + m) for recursion stack

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        # Base cases
        if not l1:
            return l2
        if not l2:
            return l1
        
        # Recursive case: take smaller head, merge rest
        if l1.val <= l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2

# Test
def create_list(arr):
    if not arr:
        return None
    head = ListNode(arr[0])
    curr = head
    for val in arr[1:]:
        curr.next = ListNode(val)
        curr = curr.next
    return head

def print_list(head):
    vals = []
    while head:
        vals.append(str(head.val))
        head = head.next
    print(" -> ".join(vals))

sol = Solution()
l1 = create_list([1, 2, 4])
l2 = create_list([1, 3, 4])
merged = sol.mergeTwoLists(l1, l2)
print_list(merged)  # 1 -> 1 -> 2 -> 3 -> 4 -> 4
</code></pre>

                            <h5><i class="fab fa-cuttlefish me-2"></i>C++</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// LeetCode 21 - Merge Two Sorted Lists
// Time: O(n + m), Space: O(n + m)

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // Base cases
        if (!l1) return l2;
        if (!l2) return l1;
        
        // Take smaller head, merge rest
        if (l1->val <= l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};

void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Create l1: 1 -> 2 -> 4
    ListNode* l1 = new ListNode(1);
    l1->next = new ListNode(2);
    l1->next->next = new ListNode(4);
    
    // Create l2: 1 -> 3 -> 4
    ListNode* l2 = new ListNode(1);
    l2->next = new ListNode(3);
    l2->next->next = new ListNode(4);
    
    Solution sol;
    ListNode* merged = sol.mergeTwoLists(l1, l2);
    printList(merged);  // 1 -> 1 -> 2 -> 3 -> 4 -> 4
    
    return 0;
}
</code></pre>

                            <h5><i class="fab fa-java me-2"></i>Java</h5>
<pre><code class="language-java">// LeetCode 21 - Merge Two Sorted Lists
// Time: O(n + m), Space: O(n + m)

class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // Base cases
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        
        // Take smaller head, merge rest
        if (l1.val <= l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
    
    public void printList(ListNode head) {
        while (head != null) {
            System.out.print(head.val);
            if (head.next != null) System.out.print(" -> ");
            head = head.next;
        }
        System.out.println();
    }
    
    public static void main(String[] args) {
        // Create l1: 1 -> 2 -> 4
        ListNode l1 = new ListNode(1);
        l1.next = new ListNode(2);
        l1.next.next = new ListNode(4);
        
        // Create l2: 1 -> 3 -> 4
        ListNode l2 = new ListNode(1);
        l2.next = new ListNode(3);
        l2.next.next = new ListNode(4);
        
        Solution sol = new Solution();
        ListNode merged = sol.mergeTwoLists(l1, l2);
        sol.printList(merged);  // 1 -> 1 -> 2 -> 3 -> 4 -> 4
    }
}
</code></pre>
                        </div>

                        <div class="highlight-box">
                            <h4><i class="fas fa-tasks me-2"></i>More Practice Problems</h4>
                            <p>Try these additional recursion problems on LeetCode:</p>
                            <ul class="mb-0">
                                <li><strong>Easy:</strong> 70. Climbing Stairs, 344. Reverse String, 226. Invert Binary Tree</li>
                                <li><strong>Medium:</strong> 779. K-th Symbol in Grammar, 894. All Possible Full Binary Trees, 247. Strobogrammatic Number II</li>
                                <li><strong>Hard:</strong> 761. Special Binary String, 44. Wildcard Matching, 10. Regular Expression Matching</li>
                            </ul>
                        </div>

                        <!-- Related Posts -->
                        <div class="related-posts">
                            <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 1: Foundations, Memory & Complexity</h5>
                                <p class="text-muted small mb-2">DSA foundations, physical vs logical structures, ADT, memory, Big-O analysis.</p>
                                <a href="dsa-foundations-memory-complexity.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 3: Arrays & Array ADT</h5>
                                <p class="text-muted small mb-2">Deep dive into arrays: static vs dynamic, multi-dimensional, ADT operations.</p>
                                <a href="dsa-arrays-adt-operations.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                            <div class="related-post-item">
                                <h5 class="mb-2">Part 4: Strings</h5>
                                <p class="text-muted small mb-2">String manipulation, palindromes, anagrams, pattern matching.</p>
                                <a href="dsa-strings-manipulation.html">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.</p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest"><i class="fab fa-pinterest-p"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Scroll-to-Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top"><i class="fas fa-arrow-up"></i></button>
    
    <!-- Cookie Consent JS -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>

    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    <!-- Scroll-to-Top Script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const scrollToTopBtn = document.getElementById('scrollToTop');
            window.addEventListener('scroll', function() {
                if (window.scrollY > 300) {
                    scrollToTopBtn.classList.add('show');
                } else {
                    scrollToTopBtn.classList.remove('show');
                }
            });
            scrollToTopBtn.addEventListener('click', function() {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });
    </script>

    <!-- Side Navigation Script -->
    <script>
        function openNav() {
            document.getElementById('tocSidenav').classList.add('open');
            document.getElementById('tocOverlay').classList.add('show');
            document.body.style.overflow = 'hidden';
        }
        function closeNav() {
            document.getElementById('tocSidenav').classList.remove('open');
            document.getElementById('tocOverlay').classList.remove('show');
            document.body.style.overflow = 'auto';
        }
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeNav();
        });
        document.addEventListener('DOMContentLoaded', function() {
            const sections = document.querySelectorAll('[id]');
            const tocLinks = document.querySelectorAll('.sidenav-toc a');
            function highlightActiveSection() {
                let currentSection = '';
                sections.forEach(section => {
                    const sectionTop = section.offsetTop;
                    if (window.scrollY >= sectionTop - 200) {
                        currentSection = section.getAttribute('id');
                    }
                });
                tocLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === '#' + currentSection) {
                        link.classList.add('active');
                    }
                });
            }
            window.addEventListener('scroll', highlightActiveSection);
            highlightActiveSection();
            tocLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetSection = document.querySelector(targetId);
                    if (targetSection) {
                        const offsetTop = targetSection.offsetTop - 80;
                        window.scrollTo({ top: offsetTop, behavior: 'smooth' });
                    }
                    setTimeout(closeNav, 300);
                });
            });
        });
    </script>

    <!-- Prism Theme Switcher -->
    <script>
        const themes = {
            'prism-theme': 'Tomorrow Night',
            'prism-default': 'Default',
            'prism-dark': 'Dark',
            'prism-twilight': 'Twilight',
            'prism-okaidia': 'Okaidia',
            'prism-solarizedlight': 'Solarized Light'
        };
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        function switchTheme(themeId) {
            Object.keys(themes).forEach(id => {
                const link = document.getElementById(id);
                if (link) link.disabled = true;
            });
            const selectedLink = document.getElementById(themeId);
            if (selectedLink) {
                selectedLink.disabled = false;
                localStorage.setItem('prism-theme', themeId);
            }
            document.querySelectorAll('div.code-toolbar select').forEach(dropdown => {
                dropdown.value = themeId;
            });
            setTimeout(() => Prism.highlightAll(), 10);
        }
        document.addEventListener('DOMContentLoaded', function() {
            switchTheme(savedTheme);
        });
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) {
            const select = document.createElement('select');
            select.setAttribute('aria-label', 'Select code theme');
            Object.keys(themes).forEach(themeId => {
                const option = document.createElement('option');
                option.value = themeId;
                option.textContent = themes[themeId];
                if (themeId === savedTheme) option.selected = true;
                select.appendChild(option);
            });
            select.addEventListener('change', function(e) {
                switchTheme(e.target.value);
            });
            return select;
        });
    </script>
</body>
</html>
