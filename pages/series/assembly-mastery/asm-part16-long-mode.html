<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="robots" content="index, archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Master x86-64 Long Mode and Protected Mode: real mode to protected mode transition, paging, GDT, segmentation, privilege levels (rings), and 64-bit memory model fundamentals." />
    <meta name="author" content="Wasil Zafar" />
    <meta name="keywords" content="Long Mode, Protected Mode, Real Mode, GDT, Paging, Segmentation, x86-64 Memory, Privilege Rings, CPU Modes" />
    <meta property="og:title" content="x86 Assembly Series Part 16: x64 Long Mode & Protected Mode" />
    <meta property="og:description" content="Understand CPU modes, memory protection, and the 64-bit memory model." />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2026-02-06" />
    <meta property="article:author" content="Wasil Zafar" />
    <meta property="article:section" content="Technology" />
    
    <title>x86 Assembly Series Part 16: x64 Long Mode & Protected Mode - Wasil Zafar</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/favicon_io/favicon-32x32.png">
    <link rel="manifest" href="../../../images/favicon_io/site.webmanifest">

    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', { 'ad_storage': 'denied', 'ad_user_data': 'denied', 'ad_personalization': 'denied', 'analytics_storage': 'denied', 'region': ['AT','BE','BG','HR','CY','CZ','DK','EE','FI','FR','DE','GR','HU','IE','IT','LV','LT','LU','MT','NL','PL','PT','RO','SK','SI','ES','SE'] });
        gtag('consent', 'default', { 'ad_storage': 'granted', 'ad_user_data': 'granted', 'ad_personalization': 'granted', 'analytics_storage': 'granted' });
    </script>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-PBS8M2JR');</script>
</head>
<body>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="/"><span class="gradient-text">Wasil Zafar</span></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#certifications">Certifications</a></li>
                    <li class="nav-item"><a class="nav-link" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <section class="blog-hero">
        <div class="container py-5">
            <div class="blog-header">
                <a href="/pages/categories/technology.html" class="back-link"><i class="fas fa-arrow-left me-2"></i>Back to Technology</a>
                <h1 class="display-4 fw-bold mb-3">x86 Assembly Series Part 16: x64 Long Mode & Protected Mode</h1>
                <div class="blog-meta">
                    <span><i class="fas fa-calendar me-2"></i>February 6, 2026</span>
                    <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                    <span class="reading-time"><i class="fas fa-clock me-1"></i>40 min read</span>
                    <button onclick="window.print()" class="print-btn"><i class="fas fa-print"></i> Print</button>
                </div>
                <p class="lead">Master CPU operating modes: real mode (16-bit), protected mode (32-bit), and long mode (64-bit). Understand the GDT, paging, segmentation, privilege rings, and memory protection mechanisms.</p>
            </div>
        </div>
    </section>

    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents"><i class="fas fa-list"></i></button>

    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Table of Contents</h3>
            <button class="closebtn" onclick="closeNav()">&times;</button>
        </div>
        <ol>
            <li><a href="#modes-overview" onclick="closeNav()">CPU Modes Overview</a></li>
            <li><a href="#real-mode" onclick="closeNav()">Real Mode (16-bit)</a></li>
            <li><a href="#protected-mode" onclick="closeNav()">Protected Mode (32-bit)</a>
                <ul>
                    <li><a href="#gdt" onclick="closeNav()">Global Descriptor Table</a></li>
                    <li><a href="#segmentation" onclick="closeNav()">Segmentation</a></li>
                </ul>
            </li>
            <li><a href="#long-mode" onclick="closeNav()">Long Mode (64-bit)</a></li>
            <li><a href="#paging" onclick="closeNav()">Paging</a></li>
            <li><a href="#rings" onclick="closeNav()">Privilege Rings</a></li>
            <li><a href="#transition" onclick="closeNav()">Mode Transitions</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">

                <div id="modes-overview" class="blog-content">
                    <h2><i class="fas fa-layer-group me-2 text-teal"></i>CPU Modes Overview</h2>
                    
                    <div class="experiment-card">
                        <div class="card-meta mb-2"><span class="badge bg-teal text-white">Reference</span></div>
                        <h4>x86 Operating Modes</h4>
                        <table class="table table-bordered table-sm">
                            <thead class="table-dark">
                                <tr><th>Mode</th><th>Registers</th><th>Address Space</th><th>Intro</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>Real Mode</td><td>16-bit</td><td>1 MB</td><td>8086 (1978)</td></tr>
                                <tr><td>Protected Mode</td><td>32-bit</td><td>4 GB</td><td>386 (1985)</td></tr>
                                <tr><td>Long Mode</td><td>64-bit</td><td>256 TB</td><td>AMD64 (2003)</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div id="real-mode" class="blog-content mt-5">
                    <h2><i class="fas fa-history me-2 text-teal"></i>Real Mode (16-bit)</h2>
                    
                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Legacy Mode:</strong> CPUs start in real mode for BIOS compatibility. No memory protection—any program can access any memory. Segment:Offset addressing with 20-bit physical addresses.
                    </div>

                    <div class="experiment-card">
                        <h4><i class="fas fa-map-signs me-2"></i>Complete Series Navigation</h4>
                        <div class="meta mb-2">
                            <span class="badge bg-teal me-2">25-Part Series</span>
                            <span class="badge bg-crimson">x86 Assembly Mastery</span>
                        </div>
                        <div class="content">
                            <p><strong>Foundation & Environment Setup</strong></p>
                            <ol start="0">
                                <li><a href="asm-part00-environment-setup.html">Development Environment, Tooling & Workflow</a></li>
                                <li><a href="asm-part01-fundamentals.html">Assembly Language Fundamentals & Toolchain Setup</a></li>
                                <li><a href="asm-part02-cpu-architecture.html">x86 CPU Architecture Overview</a></li>
                                <li><a href="asm-part03-registers.html">Registers – Complete Deep Dive</a></li>
                                <li><a href="asm-part04-instruction-encoding.html">Instruction Encoding & Binary Layout</a></li>
                            </ol>
                            <p class="mt-3"><strong>Assemblers, Syntax & Memory</strong></p>
                            <ol start="5">
                                <li><a href="asm-part05-nasm.html">NASM Syntax, Directives & Macros</a></li>
                                <li><a href="asm-part06-masm.html">Complete Assembler Comparison</a></li>
                                <li><a href="asm-part07-memory-addressing.html">Memory Addressing Modes</a></li>
                            </ol>
                            <p class="mt-3"><strong>Control Flow, Stack & Computation</strong></p>
                            <ol start="8">
                                <li><a href="asm-part08-stack-calling.html">Stack Internals & Calling Conventions</a></li>
                                <li><a href="asm-part09-control-flow.html">Control Flow & Procedures</a></li>
                                <li><a href="asm-part10-arithmetic.html">Integer, Bitwise & Arithmetic Operations</a></li>
                            </ol>
                            <p class="mt-3"><strong>Floating Point, SIMD & Performance</strong></p>
                            <ol start="11">
                                <li><a href="asm-part11-floating-point.html">Floating Point & SIMD Foundations</a></li>
                                <li><a href="asm-part12-simd.html">SIMD, Vectorization & Performance</a></li>
                            </ol>
                            <p class="mt-3"><strong>OS Interaction & Debugging</strong></p>
                            <ol start="13">
                                <li><a href="asm-part13-syscalls-interrupts.html">System Calls, Interrupts & Privilege Transitions</a></li>
                                <li><a href="asm-part14-debugging.html">Debugging & Reverse Engineering</a></li>
                                <li><a href="asm-part15-linking.html">Linking, Relocation & Loader Behavior</a></li>
                            </ol>
                            <p class="mt-3"><strong>Advanced Architecture & Interoperability</strong></p>
                            <ol start="16">
                                <li><strong>x86-64 Long Mode & Advanced Features (This Guide)</strong></li>
                                <li><a href="asm-part17-c-interop.html">Assembly + C/C++ Interoperability</a></li>
                                <li><a href="asm-part18-security.html">Memory Protection & Security Concepts</a></li>
                            </ol>
                            <p class="mt-3"><strong>Bare Metal, Kernel & Virtualization</strong></p>
                            <ol start="19">
                                <li><a href="asm-part19-bootloader.html">Bootloaders & Bare-Metal Programming</a></li>
                                <li><a href="asm-part20-kernel.html">Kernel-Level Assembly</a></li>
                                <li><a href="asm-part21-qemu.html">Complete Emulator & Simulator Guide</a></li>
                            </ol>
                            <p class="mt-3"><strong>CPU Microarchitecture & Optimization</strong></p>
                            <ol start="22">
                                <li><a href="asm-part22-optimization.html">Advanced Optimization & CPU Internals</a></li>
                            </ol>
                            <p class="mt-3"><strong>Real-World Application & Mastery</strong></p>
                            <ol start="23">
                                <li><a href="asm-part23-projects.html">Real-World Assembly Projects</a></li>
                                <li><a href="asm-part24-capstone.html">Assembly Mastery Capstone</a></li>
                            </ol>
                        </div>
                    </div>

                    <pre><code class="language-nasm">; Real mode addressing: segment:offset
; Physical Address = (segment × 16) + offset
; Example: 0x07C0:0x0000 = 0x7C00 (boot sector)</code></pre>
                </div>

                <div id="protected-mode" class="blog-content mt-5">
                    <h2><i class="fas fa-shield-alt me-2 text-teal"></i>Protected Mode (32-bit)</h2>
                    
                    <h3 id="gdt">Global Descriptor Table (GDT)</h3>
                    
                    <pre><code class="language-nasm">; GDT entry structure (8 bytes)
gdt_null:
    dq 0                    ; Null descriptor (required)

gdt_code:
    dw 0xFFFF               ; Limit 0-15
    dw 0x0000               ; Base 0-15
    db 0x00                 ; Base 16-23
    db 10011010b            ; Access: present, ring 0, code, readable
    db 11001111b            ; Flags + Limit 16-19
    db 0x00                 ; Base 24-31

gdt_data:
    dw 0xFFFF
    dw 0x0000
    db 0x00
    db 10010010b            ; Access: present, ring 0, data, writable
    db 11001111b
    db 0x00

gdt_descriptor:
    dw $ - gdt_null - 1     ; Size
    dd gdt_null             ; Address</code></pre>

                    <h3 id="segmentation">Segmentation</h3>
                    
                    <p>Segmentation divides memory into logical segments. Think of it like chapters in a book—each chapter (segment) has its own starting point and rules about who can read it.</p>
                    
                    <h4>Segment Selector Format (16 bits)</h4>
                    <pre><code class="language-plaintext">15                              3   2   1 0
┌────────────────────────────────┬───┬─────┐
│           Index                │ TI│ RPL │
│         (13 bits)              │   │     │
└────────────────────────────────┴───┴─────┘
Index: Entry number in GDT/LDT (0-8191)
TI:    Table Indicator (0=GDT, 1=LDT)
RPL:   Requested Privilege Level (0-3)</code></pre>

                    <h4>Segment Descriptor (8 bytes)</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead class="table-dark">
                                <tr><th>Bits</th><th>Field</th><th>Description</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0-15</td><td>Limit 0:15</td><td>Segment size (low 16 bits)</td></tr>
                                <tr><td>16-31</td><td>Base 0:15</td><td>Base address (low 16 bits)</td></tr>
                                <tr><td>32-39</td><td>Base 16:23</td><td>Base address (mid 8 bits)</td></tr>
                                <tr><td>40-47</td><td>Access Byte</td><td>Type and permissions</td></tr>
                                <tr><td>48-51</td><td>Limit 16:19</td><td>Segment size (high 4 bits)</td></tr>
                                <tr><td>52-55</td><td>Flags</td><td>G, D/B, L, AVL</td></tr>
                                <tr><td>56-63</td><td>Base 24:31</td><td>Base address (high 8 bits)</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <h4>Access Byte Breakdown</h4>
<pre><code class="language-plaintext">Bit 7: P   (Present)        - Segment is in memory
Bit 6-5: DPL (Privilege)    - Ring level 0-3
Bit 4: S   (Descriptor)     - 1=code/data, 0=system
Bit 3: E   (Executable)     - 1=code, 0=data
Bit 2: DC  (Direction/Conf) - Data: grow direction, Code: conforming
Bit 1: RW  (Read/Write)     - Code: readable, Data: writable
Bit 0: A   (Accessed)       - CPU sets when segment accessed</code></pre>

                    <div class="highlight-box highlight-navy">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Long Mode Note:</strong> In 64-bit long mode, segmentation is mostly disabled. The CPU ignores base and limit for CS, DS, ES, SS (treats them as 0 and unlimited). Only FS and GS retain their base address functionality for thread-local storage.
                    </div>
                </div>

                <div id="long-mode" class="blog-content mt-5">
                    <h2><i class="fas fa-rocket me-2 text-teal"></i>Long Mode (64-bit)</h2>
                    
                    <p>Long mode is the native operating mode of x86-64 CPUs. It provides 64-bit registers, a flat memory model, and access to vastly more memory than 32-bit protected mode.</p>
                    
                    <h3>Sub-Modes of Long Mode</h3>
                    <div class="table-responsive">
                        <table class="table table-bordered">
                            <thead class="table-dark">
                                <tr><th>Sub-Mode</th><th>Code Size</th><th>Registers</th><th>Use Case</th></tr>
                            </thead>
                            <tbody>
                                <tr><td><strong>64-bit Mode</strong></td><td>64-bit default, 32-bit via prefix</td><td>Full R8-R15, RIP-relative</td><td>Native 64-bit applications</td></tr>
                                <tr><td><strong>Compatibility Mode</strong></td><td>32/16-bit</td><td>EAX-EDI only</td><td>Run legacy 32-bit apps</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <h3>Canonical Addresses</h3>
                    <p>Although 64-bit mode has 64-bit pointers, current CPUs only implement 48 bits of virtual address space. Valid addresses must be "canonical"—bits 48-63 must match bit 47.</p>
                    
<pre><code class="language-plaintext">48-bit Virtual Address Space:

Canonical High: 0xFFFF800000000000 - 0xFFFFFFFFFFFFFFFF (kernel space)
                ↑ bits 48-63 = 1 (sign extension of bit 47)

Non-Canonical:  0x0001000000000000 - 0xFFFE7FFFFFFFFFFF (FORBIDDEN)
                ↑ causes #GP fault if accessed!

Canonical Low:  0x0000000000000000 - 0x00007FFFFFFFFFFF (user space)
                ↑ bits 48-63 = 0 (sign extension of bit 47)</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-lightbulb me-2"></i>
                        <strong>Why This Matters:</strong> The canonical address gap provides a natural kernel/user split. Kernel addresses have bit 47 set (0xFFFF...), user addresses don't (0x0000...). Any attempt to jump into the "non-canonical hole" triggers a General Protection Fault.
                    </div>

                    <h3>Key Long Mode Features</h3>
                    <ul>
                        <li><strong>RIP-Relative Addressing:</strong> Default for most memory operands</li>
                        <li><strong>No Segmentation:</strong> Flat 64-bit address space (except FS/GS)</li>
                        <li><strong>NX Bit:</strong> Page-level execute disable (security)</li>
                        <li><strong>Larger Registers:</strong> RAX, RBX, R8-R15, XMM0-XMM15</li>
                        <li><strong>Red Zone:</strong> 128 bytes below RSP usable without decrementing</li>
                        <li><strong>New Calling Convention:</strong> Parameters in registers (RDI, RSI, RDX, RCX, R8, R9)</li>
                    </ul>

<pre><code class="language-nasm">; 64-bit mode code example
bits 64

section .data
    message db "Hello from long mode!", 10, 0
    msg_len equ $ - message

section .text
global _start

_start:
    ; Syscall: write(1, message, msg_len)
    mov rax, 1              ; syscall number (write)
    mov rdi, 1              ; fd = stdout
    lea rsi, [rel message]  ; RIP-relative addressing
    mov rdx, msg_len
    syscall
    
    ; Syscall: exit(0)
    mov rax, 60
    xor rdi, rdi
    syscall</code></pre>
                </div>

                <div id="paging" class="blog-content mt-5">
                    <h2><i class="fas fa-table me-2 text-teal"></i>Paging</h2>
                    
                    <p>Paging is the cornerstone of modern memory management. It translates virtual addresses (what your program sees) to physical addresses (actual RAM locations), enabling memory protection, isolation, and more memory than physically exists.</p>
                    
                    <h3>4-Level Paging (Long Mode)</h3>
<pre><code class="language-plaintext">Virtual Address (48-bit):
┌─────────┬─────────┬─────────┬─────────┬──────────────┐
│ PML4    │  PDPT   │   PD    │   PT    │    Offset    │
│ 9 bits  │  9 bits │  9 bits │  9 bits │   12 bits    │
└────┬────┴────┬────┴────┬────┴────┬────┴──────┬───────┘
     │         │         │         │           │
     ▼         ▼         ▼         ▼           ▼
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
│  PML4   │→│  PDPT   │→│   PD    │→│   PT    │→│ 4KB Page│
│  Table  │ │  Table  │ │  Table  │ │  Table  │ │ in RAM  │
└─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘
    512       512         512         512
   entries   entries     entries     entries

CR3 register holds physical address of PML4 table</code></pre>

                    <h3>Page Table Entry Format (64-bit)</h3>
                    <div class="table-responsive">
                        <table class="table table-bordered table-sm">
                            <thead class="table-dark">
                                <tr><th>Bit(s)</th><th>Name</th><th>Meaning</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>P</td><td>Present (1=in memory)</td></tr>
                                <tr><td>1</td><td>R/W</td><td>Read/Write (0=read-only)</td></tr>
                                <tr><td>2</td><td>U/S</td><td>User/Supervisor (1=user accessible)</td></tr>
                                <tr><td>3</td><td>PWT</td><td>Page Write-Through</td></tr>
                                <tr><td>4</td><td>PCD</td><td>Page Cache Disable</td></tr>
                                <tr><td>5</td><td>A</td><td>Accessed (set by CPU)</td></tr>
                                <tr><td>6</td><td>D</td><td>Dirty (page written to)</td></tr>
                                <tr><td>7</td><td>PS</td><td>Page Size (1=large page)</td></tr>
                                <tr><td>12-51</td><td>Address</td><td>Physical page frame address</td></tr>
                                <tr><td>63</td><td>NX</td><td>No Execute (1=non-executable)</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <h3>Translation Lookaside Buffer (TLB)</h3>
                    <p>Walking 4 levels of page tables for every memory access would be impossibly slow. The TLB is a hardware cache that stores recent virtual→physical translations.</p>
                    
                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>TLB Shootdown:</strong> When page tables change, old TLB entries become stale. The OS must invalidate them using <code>INVLPG</code> (single page) or reload CR3 (flush entire TLB). On multi-core systems, this requires expensive inter-processor interrupts.
                    </div>

<pre><code class="language-nasm">; Invalidate TLB entry for a specific address
mov rax, [virtual_address]
invlpg [rax]              ; Invalidate single page

; Flush entire TLB (reload CR3)
mov rax, cr3
mov cr3, rax              ; Writing CR3 flushes TLB</code></pre>

                    <h3>Page Faults (#PF)</h3>
                    <p>When the CPU can't complete a page table walk, it raises exception 14 (Page Fault). The error code pushed to the stack tells you what happened:</p>
                    
<pre><code class="language-plaintext">Page Fault Error Code:
Bit 0 (P):    0 = non-present page, 1 = protection violation
Bit 1 (W/R):  0 = read access, 1 = write access
Bit 2 (U/S):  0 = supervisor mode, 1 = user mode
Bit 3 (RSVD): 1 = reserved bit set in page table
Bit 4 (I/D):  1 = instruction fetch

CR2 register contains the faulting virtual address</code></pre>

                    <div class="experiment-card">
                        <div class="experiment-meta">
                            <span class="badge bg-teal">Page Sizes</span>
                        </div>
                        <div class="experiment-content">
                            <h4>Huge Pages for Performance</h4>
                            <p>4KB pages work for most cases, but large allocations benefit from bigger pages:</p>
                            <ul>
                                <li><strong>2MB pages:</strong> Set PS bit in PD entry (skip PT level)</li>
                                <li><strong>1GB pages:</strong> Set PS bit in PDPT entry (skip PD and PT)</li>
                            </ul>
                            <p>Huge pages reduce TLB misses dramatically—one TLB entry covers 2MB instead of 4KB!</p>
                        </div>
                    </div>
                </div>

                <div id="rings" class="blog-content mt-5">
                    <h2><i class="fas fa-ring me-2 text-teal"></i>Privilege Rings</h2>
                    
                    <p>x86 implements hardware-enforced privilege levels to isolate the kernel from user programs. Think of it like security clearances—higher clearance (lower ring number) grants more access.</p>
                    
<pre><code class="language-plaintext">         Ring 0 (Kernel Mode)
        ┌────────────────────┐
        │  OS Kernel, Drivers │  ← Full hardware access
        │  All instructions   │
        └────────┬───────────┘
                 │
         Ring 1-2 (Rarely Used)
        ┌────────────────────┐
        │  Device Drivers*    │  ← Originally for drivers
        │  (unused today)     │    Modern OS: everything Ring 0
        └────────┬───────────┘
                 │
         Ring 3 (User Mode)
        ┌────────────────────┐
        │  Applications       │  ← Limited access
        │  No privileged instr│    Must ask kernel via syscall
        └────────────────────┘</code></pre>

                    <h3>Privilege Level Types</h3>
                    <div class="table-responsive">
                        <table class="table table-bordered">
                            <thead class="table-dark">
                                <tr><th>Acronym</th><th>Name</th><th>Stored In</th><th>Purpose</th></tr>
                            </thead>
                            <tbody>
                                <tr><td><strong>CPL</strong></td><td>Current Privilege Level</td><td>CS register (bits 0-1)</td><td>Current code's privilege</td></tr>
                                <tr><td><strong>DPL</strong></td><td>Descriptor Privilege Level</td><td>Segment descriptor</td><td>Required privilege to access</td></tr>
                                <tr><td><strong>RPL</strong></td><td>Requested Privilege Level</td><td>Segment selector (bits 0-1)</td><td>Requested access level</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <h3>Access Check Rules</h3>
<pre><code class="language-plaintext">Data Segment Access:
  CPL ≤ DPL  AND  RPL ≤ DPL  →  Access allowed
  
Code Segment Access (via JMP/CALL):
  Non-conforming: CPL = DPL
  Conforming:     CPL ≥ DPL (can call from lower privilege)

Examples:
  Ring 3 code accessing Ring 0 data → #GP fault!
  Ring 0 code accessing Ring 3 data → Allowed
  Ring 3 calling Ring 0 code directly → #GP fault!
  Ring 3 using SYSCALL to enter Ring 0 → Allowed (controlled entry)</code></pre>

                    <div class="highlight-box">
                        <i class="fas fa-shield-alt me-2"></i>
                        <strong>Privileged Instructions:</strong> Some instructions only work in Ring 0: <code>HLT</code> (halt CPU), <code>LGDT</code>/<code>LIDT</code> (load descriptor tables), <code>MOV CRx</code> (control registers), <code>IN</code>/<code>OUT</code> (port I/O), <code>WRMSR</code>/<code>RDMSR</code> (model-specific registers). Executing these in Ring 3 triggers #GP.
                    </div>

                    <h3>Ring Transitions</h3>
<pre><code class="language-nasm">; User (Ring 3) → Kernel (Ring 0)
; Method 1: Software interrupt (legacy)
int 0x80              ; Linux legacy syscall

; Method 2: SYSCALL instruction (modern, faster)
mov rax, 1            ; syscall number
syscall               ; Enters Ring 0 via MSR-defined entry

; Kernel (Ring 0) → User (Ring 3)
; IRET or SYSRET restores user context and drops privilege
sysretq               ; Return from SYSCALL to user mode</code></pre>

                    <div class="experiment-card">
                        <div class="experiment-meta">
                            <span class="badge bg-primary">Exercise</span>
                        </div>
                        <div class="experiment-content">
                            <h4>Test Privilege Enforcement</h4>
                            <p>Try running this privileged instruction in a user-mode program:</p>
<pre><code class="language-nasm">section .text
global _start
_start:
    cli               ; Disable interrupts (Ring 0 only!)
    mov rax, 60
    xor rdi, rdi
    syscall</code></pre>
                            <p>Result: Segmentation fault! The CPU denies <code>CLI</code> in Ring 3.</p>
                        </div>
                    </div>
                </div>

                <div id="transition" class="blog-content mt-5">
                    <h2><i class="fas fa-exchange-alt me-2 text-teal"></i>Mode Transitions</h2>
                    
                    <p>When an x86-64 CPU powers on, it starts in 16-bit real mode for BIOS compatibility. Transitioning to 64-bit long mode requires careful setup of multiple CPU features.</p>
                    
                    <h3>The Journey: Real → Protected → Long</h3>
<pre><code class="language-plaintext">┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│  Real Mode   │────→│Protected Mode│────→│  Long Mode   │
│   16-bit     │     │   32-bit     │     │   64-bit     │
│   1MB limit  │     │   4GB limit  │     │   256TB (48b)│
│   No paging  │     │   Paging opt.│     │Paging required│
│   No protect.│     │   Rings 0-3  │     │   Rings 0-3  │
└──────────────┘     └──────────────┘     └──────────────┘
     Steps:               Steps:               
     1. Setup GDT         1. Enable PAE        
     2. Set CR0.PE=1      2. Setup PML4        
     3. Far jump          3. Enable EFER.LME   
                          4. Enable CR0.PG     
                          5. Far jump to 64-bit</code></pre>

                    <h3>Complete Transition Code</h3>
<pre><code class="language-nasm">bits 16
org 0x7C00

start:
    cli                     ; Disable interrupts
    xor ax, ax
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7C00          ; Stack below bootloader

; ═══════════════════════════════════════════════════════════
; STEP 1: Load GDT
; ═══════════════════════════════════════════════════════════
    lgdt [gdt_descriptor]

; ═══════════════════════════════════════════════════════════
; STEP 2: Enable Protected Mode (CR0.PE = 1)
; ═══════════════════════════════════════════════════════════
    mov eax, cr0
    or eax, 1               ; Set PE bit
    mov cr0, eax
    jmp 0x08:protected_mode ; Far jump flushes prefetch queue

bits 32
protected_mode:
; ═══════════════════════════════════════════════════════════
; STEP 3: Setup 32-bit segments
; ═══════════════════════════════════════════════════════════
    mov ax, 0x10            ; Data segment selector
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov esp, 0x90000

; ═══════════════════════════════════════════════════════════
; STEP 4: Enable PAE (required for long mode)
; ═══════════════════════════════════════════════════════════
    mov eax, cr4
    or eax, (1 << 5)        ; CR4.PAE = 1
    mov cr4, eax

; ═══════════════════════════════════════════════════════════
; STEP 5: Setup identity-mapped page tables
; ═══════════════════════════════════════════════════════════
    ; PML4[0] → PDPT
    mov edi, 0x1000         ; PML4 at 0x1000
    mov eax, 0x2003         ; PDPT address | Present | Writable
    stosd
    xor eax, eax
    mov ecx, 1023
    rep stosd               ; Clear rest of PML4

    ; PDPT[0] → PD
    mov eax, 0x3003         ; PD address | Present | Writable
    stosd
    xor eax, eax
    mov ecx, 1023
    rep stosd

    ; PD: 512 x 2MB pages = 1GB identity mapped
    mov edi, 0x3000
    mov eax, 0x83           ; Present | Writable | 2MB page
    mov ecx, 512
.pd_loop:
    stosd
    add edi, 4              ; Skip high 32 bits
    add eax, 0x200000       ; Next 2MB
    loop .pd_loop

; ═══════════════════════════════════════════════════════════
; STEP 6: Load CR3 with PML4 address
; ═══════════════════════════════════════════════════════════
    mov eax, 0x1000
    mov cr3, eax

; ═══════════════════════════════════════════════════════════
; STEP 7: Enable Long Mode (EFER.LME = 1)
; ═══════════════════════════════════════════════════════════
    mov ecx, 0xC0000080     ; EFER MSR
    rdmsr
    or eax, (1 << 8)        ; LME = Long Mode Enable
    wrmsr

; ═══════════════════════════════════════════════════════════
; STEP 8: Enable Paging (CR0.PG = 1) - Activates Long Mode!
; ═══════════════════════════════════════════════════════════
    mov eax, cr0
    or eax, (1 << 31)       ; PG = 1
    mov cr0, eax

; ═══════════════════════════════════════════════════════════
; STEP 9: Far jump to 64-bit code
; ═══════════════════════════════════════════════════════════
    jmp 0x18:long_mode      ; 64-bit code segment

bits 64
long_mode:
    ; We're now in 64-bit Long Mode!
    mov ax, 0x20            ; 64-bit data segment
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov rsp, 0x90000

    ; Print 'L' for Long Mode success
    mov byte [0xB8000], 'L'
    mov byte [0xB8001], 0x0A ; Light green

    hlt

; ═══════════════════════════════════════════════════════════
; GDT with 16, 32, and 64-bit segments
; ═══════════════════════════════════════════════════════════
align 16
gdt_start:
    dq 0                    ; Null descriptor
gdt_code32:
    dw 0xFFFF, 0x0000
    db 0x00, 10011010b, 11001111b, 0x00
gdt_data32:
    dw 0xFFFF, 0x0000
    db 0x00, 10010010b, 11001111b, 0x00
gdt_code64:
    dw 0xFFFF, 0x0000
    db 0x00, 10011010b, 10101111b, 0x00  ; L=1, D=0 for 64-bit
gdt_data64:
    dw 0xFFFF, 0x0000
    db 0x00, 10010010b, 11001111b, 0x00
gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start

times 510 - ($ - $$) db 0
dw 0xAA55                   ; Boot signature</code></pre>

                    <div class="highlight-box highlight-crimson">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Critical Sequence:</strong> The order matters! You must enable PAE before setting EFER.LME, and you must set both before enabling paging. Violating this sequence causes a #GP fault.
                    </div>

                    <h3>Testing with QEMU</h3>
<pre><code class="language-bash"># Assemble and create bootable image
nasm -f bin boot64.asm -o boot64.bin

# Run in QEMU
qemu-system-x86_64 -drive format=raw,file=boot64.bin

# Debug with GDB
qemu-system-x86_64 -drive format=raw,file=boot64.bin -s -S &
gdb -ex "target remote :1234" -ex "set architecture i8086"</code></pre>
                </div>

                <div class="blog-content mt-5">
                    <div class="related-posts">
                        <h3><i class="fas fa-book-reader me-2"></i>Continue the Series</h3>
                        <div class="related-post-item">
                            <h5 class="mb-2">Part 15: Linking & Object Files</h5>
                            <p class="text-muted small mb-2">Understand ELF format and the linking process.</p>
                            <a href="asm-part15-linking.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5 class="mb-2">Part 17: C & Assembly Interoperability</h5>
                            <p class="text-muted small mb-2">Call C from assembly and vice versa.</p>
                            <a href="asm-part17-c-interop.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                        <div class="related-post-item">
                            <h5 class="mb-2">Part 19: Bootloader Development</h5>
                            <p class="text-muted small mb-2">Write bootloaders and boot sector code.</p>
                            <a href="asm-part19-bootloader.html" class="text-decoration-none">Read Article <i class="fas fa-arrow-right ms-1"></i></a>
                        </div>
                    </div>
                </div>

                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer id="social-media" class="bg-dark text-light py-5">
        <div class="container py-5">
            <div class="row mb-4">
                <div class="col-lg-6 mb-4 mb-lg-0">
                    <h5 class="fw-bold mb-3">Let's Connect</h5>
                    <p class="text-light">
                        I'm always interested in sharing content about my interests on different topics. Read disclaimer and feel free to share further.
                    </p>
                </div>
                <div class="col-lg-6">
                    <h5 class="fw-bold mb-3">Follow Me</h5>
                    <div class="social-links d-flex gap-2 flex-wrap">
                        <a href="https://www.facebook.com/wasil.zafar/" target="_blank" class="social-icon" title="Facebook"><i class="fab fa-facebook-f"></i></a>
                        <a href="https://twitter.com/wasilzafar" target="_blank" class="social-icon" title="Twitter"><i class="fab fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/in/wasilzafar" target="_blank" class="social-icon" title="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://www.youtube.com/@wasilzafar" target="_blank" class="social-icon" title="YouTube"><i class="fab fa-youtube"></i></a>
                        <a href="https://www.instagram.com/itswzee/" target="_blank" class="social-icon" title="Instagram"><i class="fab fa-instagram"></i></a>
                        <a href="https://in.pinterest.com/wasilz/" target="_blank" class="social-icon" title="Pinterest"><i class="fab fa-pinterest-p"></i></a>
                        <a href="mailto:wasil.zafar@gmail.com" class="social-icon" title="Email"><i class="fas fa-envelope"></i></a>
                    </div>
                </div>
            </div>
            <hr class="bg-secondary">
            <div class="row mt-4">
                <div class="col-md-6">
                    <p class="small"><i class="fas fa-icons me-2"></i>Icons from <a href="https://www.flaticon.com/" target="_blank" class="text-light">Flaticon</a> &amp; <a href="https://fontawesome.com/" target="_blank" class="text-light">Font Awesome</a></p>
                    <p class="small mt-3">
                        <a href="/" class="text-light text-decoration-none">Home</a> | 
                        <a href="/disclaimer.html" class="text-light text-decoration-none">Disclaimer</a> | 
                        <a href="/privacy-policy.html" class="text-light text-decoration-none">Privacy Policy</a>
                    </p>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="small">Enjoying this content? ☕ <a href="https://buymeacoffee.com/itswzee" target="_blank" class="text-light" style="text-decoration: underline;">Keep me caffeinated</a> to keep the pixels flowing!</p>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <button id="scrollToTop" class="scroll-to-top"><i class="fas fa-arrow-up"></i></button>
    <div id="categoryIndicator" class="category-indicator"></div>
    <script src="../../../js/cookie-consent.js"></script>
    <script src="../../../js/main.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-nasm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
</body>
</html>
