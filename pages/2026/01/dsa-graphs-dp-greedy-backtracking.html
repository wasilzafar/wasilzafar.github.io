<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master Graphs, Dynamic Programming, Greedy Algorithms, and Backtracking for FAANG interviews. Complete guide with Python implementations, BFS/DFS, shortest paths, DP patterns, and classic problems.">
    <meta name="keywords" content="graph algorithms, dynamic programming, greedy algorithms, backtracking, BFS, DFS, Dijkstra, Python, data structures, FAANG interview, LeetCode">
    <meta name="author" content="Wasil Zafar">
    
    <!-- Open Graph / Social Media -->
    <meta property="og:title" content="DSA Part 12: Graphs, DP, Greedy & Backtracking | Wasil Zafar">
    <meta property="og:description" content="Complete guide to graphs, dynamic programming, greedy algorithms, and backtracking for technical interviews.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://wasilzafar.com/pages/2026/01/dsa-graphs-dp-greedy-backtracking.html">
    <meta property="article:published_time" content="2026-01-28">
    <meta property="article:author" content="Wasil Zafar">
    <meta property="article:section" content="Technology">
    
    <title>DSA Part 12: Graphs, DP, Greedy & Backtracking | Wasil Zafar</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../../../images/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/favicon_io/apple-touch-icon.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Prism.js Syntax Highlighting - Multiple Themes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-default" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" id="prism-dark" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css" id="prism-twilight" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" id="prism-okaidia" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" id="prism-solarizedlight" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css">
    
    <!-- Main CSS -->
    <link rel="stylesheet" href="../../../css/main.css">

    <!-- Google tag (gtag.js) - Google Consent Mode v2 -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied',
            'analytics_storage': 'denied',
            'functionality_storage': 'granted',
            'personalization_storage': 'denied',
            'security_storage': 'granted',
            'wait_for_update': 500
        });
        
        gtag('set', 'ads_data_redaction', true);
        gtag('set', 'url_passthrough', true);
    </script>
    
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-PBS8M2JR');</script>
    
    <style>
        :root {
            --color-crimson: #BF092F;
            --color-navy: #132440;
            --color-blue: #16476A;
            --color-teal: #3B9797;
            --color-light: #f8f9fa;
            --color-white: #ffffff;
        }
        
        .blog-hero {
            background: linear-gradient(135deg, var(--color-navy) 0%, var(--color-blue) 100%);
            color: white;
            padding: 4rem 0 3rem;
            margin-bottom: 0;
        }
        
        .blog-hero h1 {
            font-family: 'Playfair Display', serif;
            font-weight: 700;
            margin-bottom: 1rem;
        }
        
        .blog-meta {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            font-size: 0.95rem;
            color: var(--color-teal);
            margin-bottom: 1rem;
        }
        
        .reading-time {
            background: var(--color-crimson);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
        }
        
        .print-btn {
            background: var(--color-teal);
            color: white;
            border: none;
            padding: 0.4rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .print-btn:hover {
            background: var(--color-crimson);
            transform: translateY(-1px);
        }
        
        .blog-content {
            font-family: 'DM Sans', sans-serif;
            font-size: 1.05rem;
            line-height: 1.8;
            color: #333;
            text-align: justify;
        }
        
        .blog-content h2 {
            font-family: 'Poppins', sans-serif;
            color: var(--color-navy);
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--color-teal);
        }
        
        .blog-content h3 {
            font-family: 'Poppins', sans-serif;
            color: var(--color-blue);
            margin-top: 2rem;
            margin-bottom: 0.75rem;
        }
        
        .blog-content h4 {
            font-family: 'Poppins', sans-serif;
            color: var(--color-crimson);
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
        }
        
        .highlight-box {
            background: linear-gradient(135deg, rgba(59, 151, 151, 0.1) 0%, rgba(22, 71, 106, 0.1) 100%);
            border-left: 4px solid var(--color-teal);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        .highlight-box h4 {
            color: var(--color-navy);
            margin-top: 0;
            margin-bottom: 0.75rem;
        }
        
        .experiment-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            border: 1px solid #e0e0e0;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .experiment-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
        }
        
        .experiment-card h4 {
            color: var(--color-crimson);
            margin-top: 0;
        }
        
        pre[class*="language-"] {
            border-radius: 8px;
            margin: 1.5rem 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        code:not([class*="language-"]) {
            background: rgba(59, 151, 151, 0.15);
            color: var(--color-navy);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
        }
        
        div.code-toolbar > .toolbar {
            opacity: 1;
            display: flex;
            gap: 0.5rem;
        }
        
        div.code-toolbar > .toolbar > .toolbar-item > button {
            background: var(--color-teal);
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        div.code-toolbar > .toolbar > .toolbar-item > button:hover {
            background: var(--color-blue);
            transform: translateY(-1px);
        }
        
        div.code-toolbar > .toolbar > .toolbar-item > select {
            background: var(--color-navy);
            color: white;
            border: 1px solid var(--color-teal);
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        div.code-toolbar > .toolbar > .toolbar-item > select:hover {
            background: var(--color-blue);
            border-color: var(--color-crimson);
        }
        
        div.code-toolbar > .toolbar > .toolbar-item > select option {
            background: var(--color-navy);
            color: white;
        }
        
        .toc-toggle-btn {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            width: 60px;
            height: 60px;
            background: var(--color-teal);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 151, 151, 0.4);
            transition: all 0.3s ease;
            z-index: 1049;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .toc-toggle-btn:hover {
            background: var(--color-crimson);
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(191, 9, 47, 0.5);
        }
        
        .sidenav-toc {
            height: calc(100% - 64px);
            width: 0;
            position: fixed;
            z-index: 1050;
            top: 64px;
            left: 0;
            background: linear-gradient(135deg, var(--color-navy) 0%, var(--color-blue) 100%);
            overflow-x: hidden;
            overflow-y: auto;
            transition: width 0.4s ease;
            padding-top: 30px;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3);
        }
        
        .sidenav-toc.open {
            width: 350px;
        }
        
        .sidenav-toc .toc-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 30px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--color-teal);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .sidenav-toc.open .toc-header {
            opacity: 1;
            visibility: visible;
        }
        
        .sidenav-toc .closebtn {
            font-size: 32px;
            color: white;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .sidenav-toc .closebtn:hover {
            color: var(--color-crimson);
            transform: rotate(90deg);
        }
        
        .sidenav-toc h3 {
            color: white;
            margin: 0;
            font-weight: 700;
            font-size: 1.3rem;
        }
        
        .sidenav-toc ol {
            list-style: decimal;
            padding: 0 30px;
            margin: 0;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .sidenav-toc ol li {
            margin-bottom: 8px;
        }
        
        .sidenav-toc a {
            padding: 12px 30px;
            text-decoration: none;
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.85);
            display: block;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
        }
        
        .sidenav-toc a:hover {
            color: white;
            background: rgba(59, 151, 151, 0.2);
            border-left-color: var(--color-teal);
            padding-left: 35px;
        }
        
        .sidenav-toc a.active {
            color: white;
            background: rgba(191, 9, 47, 0.3);
            border-left-color: var(--color-crimson);
            font-weight: 600;
        }
        
        .sidenav-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1049;
        }
        
        .sidenav-overlay.show {
            display: block;
        }
        
        .scroll-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            background: var(--color-teal);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(59, 151, 151, 0.3);
            z-index: 999;
        }
        
        .scroll-to-top.show {
            opacity: 1;
            visibility: visible;
        }
        
        .scroll-to-top:hover {
            background: var(--color-crimson);
            transform: translateY(-3px);
        }
        
        .badge-easy { background: #28a745; color: white; }
        .badge-medium { background: #ffc107; color: #333; }
        .badge-hard { background: #dc3545; color: white; }
        
        @media (max-width: 768px) {
            .sidenav-toc.open { width: 280px; }
            .toc-toggle-btn { width: 50px; height: 50px; font-size: 1.2rem; left: 1rem; bottom: 1rem; }
            .scroll-to-top { bottom: 1rem; right: 1rem; width: 45px; height: 45px; }
        }
        
        html { scroll-behavior: smooth; }
        
        @media print {
            * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
            nav, .navbar, footer, .back-link, .related-posts, .scroll-to-top, .print-btn, .toc-toggle-btn, .sidenav-toc, .sidenav-overlay { display: none !important; }
            body { font-size: 12pt; line-height: 1.6; }
            .container { max-width: 100%; padding: 0; }
            h1, h2, h3, h4, h5, h6 { page-break-after: avoid; }
            pre { page-break-inside: avoid; border: 1px solid #ddd !important; }
            .highlight-box, .experiment-card { page-break-inside: avoid; }
        }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBS8M2JR"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm sticky-top">
        <div class="container">
            <a class="navbar-brand fw-bold" href="../../../index.html">Wasil Zafar</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="../../../index.html">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="../../../index.html#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="../../../index.html#interests">Interests</a></li>
                    <li class="nav-item"><a class="nav-link active" href="../../categories/technology.html">Technology</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- TOC Toggle Button -->
    <button class="toc-toggle-btn" onclick="openNav()" title="Table of Contents">
        <i class="fas fa-list"></i>
    </button>

    <!-- Side Navigation TOC -->
    <div id="tocSidenav" class="sidenav-toc">
        <div class="toc-header">
            <h3><i class="fas fa-list me-2"></i>Contents</h3>
            <button class="closebtn" onclick="closeNav()">&times;</button>
        </div>
        <ol>
            <li><a href="#graphs" onclick="closeNav()">Graph Fundamentals</a></li>
            <li><a href="#graph-traversal" onclick="closeNav()">BFS & DFS</a></li>
            <li><a href="#shortest-path" onclick="closeNav()">Shortest Path</a></li>
            <li><a href="#topological" onclick="closeNav()">Topological Sort</a></li>
            <li><a href="#dp-intro" onclick="closeNav()">DP Introduction</a></li>
            <li><a href="#dp-patterns" onclick="closeNav()">DP Patterns</a></li>
            <li><a href="#greedy" onclick="closeNav()">Greedy Algorithms</a></li>
            <li><a href="#backtracking" onclick="closeNav()">Backtracking</a></li>
            <li><a href="#leetcode" onclick="closeNav()">LeetCode Problems</a></li>
            <li><a href="#series-nav" onclick="closeNav()">Complete Series</a></li>
        </ol>
    </div>
    <div id="tocOverlay" class="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Blog Hero -->
    <section class="blog-hero">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">
                    <a href="../../categories/technology.html" class="text-light text-decoration-none mb-3 d-inline-block">
                        <i class="fas fa-arrow-left me-2"></i>Back to Technology
                    </a>
                    <h1 class="display-4">DSA Part 12: Graphs, DP, Greedy & Backtracking</h1>
                    <div class="blog-meta">
                        <span><i class="fas fa-calendar me-2"></i>January 28, 2026</span>
                        <span><i class="fas fa-user me-2"></i>Wasil Zafar</span>
                        <span class="reading-time"><i class="fas fa-clock me-1"></i>35 min read</span>
                        <button onclick="window.print()" class="print-btn" title="Print this article">
                            <i class="fas fa-print"></i> Print
                        </button>
                    </div>
                    <p class="lead">Master graphs, dynamic programming, greedy algorithms, and backtracking - the final pillars for FAANG interview success with complete Python implementations.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Blog Content -->
    <section class="py-5">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 mx-auto">
                    <div class="blog-content">
                        
                        <!-- Graphs -->
                        <h2 id="graphs"><i class="fas fa-project-diagram me-2"></i>Graph Fundamentals</h2>
                        
                        <p>A <strong>Graph</strong> is a collection of nodes (vertices) and edges connecting them. Graphs model relationships and networks, appearing frequently in interview problems.</p>
                        
                        <div class="highlight-box">
                            <h4><i class="fas fa-lightbulb me-2"></i>Graph Terminology</h4>
                            <ul>
                                <li><strong>Directed:</strong> Edges have direction (A→B)</li>
                                <li><strong>Undirected:</strong> Edges go both ways (A—B)</li>
                                <li><strong>Weighted:</strong> Edges have costs/weights</li>
                                <li><strong>Cycle:</strong> Path that starts and ends at same node</li>
                                <li><strong>Connected:</strong> Path exists between all vertex pairs</li>
                            </ul>
                        </div>

                        <h3>Graph Representations</h3>
                        
<pre><code class="language-python">from collections import defaultdict

# 1. Adjacency List (most common for sparse graphs)
class GraphAdjList:
    """
    Adjacency List representation
    Space: O(V + E)
    Best for: sparse graphs, most interview problems
    """
    def __init__(self, directed=False):
        self.graph = defaultdict(list)
        self.directed = directed
    
    def add_edge(self, u, v, weight=1):
        self.graph[u].append((v, weight))
        if not self.directed:
            self.graph[v].append((u, weight))
    
    def get_neighbors(self, u):
        return self.graph[u]
    
    def __str__(self):
        return str(dict(self.graph))

# Example
g = GraphAdjList(directed=False)
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(1, 2)
g.add_edge(2, 3)

print("Adjacency List:", g)
print("Neighbors of 0:", g.get_neighbors(0))
</code></pre>

<pre><code class="language-python">import numpy as np

# 2. Adjacency Matrix (good for dense graphs)
class GraphAdjMatrix:
    """
    Adjacency Matrix representation
    Space: O(V²)
    Best for: dense graphs, quick edge lookups
    """
    def __init__(self, num_vertices):
        self.V = num_vertices
        self.matrix = [[0] * num_vertices for _ in range(num_vertices)]
    
    def add_edge(self, u, v, weight=1):
        self.matrix[u][v] = weight
        self.matrix[v][u] = weight  # For undirected
    
    def has_edge(self, u, v):
        return self.matrix[u][v] != 0
    
    def get_neighbors(self, u):
        return [v for v in range(self.V) if self.matrix[u][v] != 0]
    
    def display(self):
        for row in self.matrix:
            print(row)

# Example
g = GraphAdjMatrix(4)
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(1, 2)
g.add_edge(2, 3)

print("Adjacency Matrix:")
g.display()
print("Neighbors of 2:", g.get_neighbors(2))
</code></pre>

<pre><code class="language-python"># 3. Edge List (simplest representation)
class GraphEdgeList:
    """
    Edge List representation
    Space: O(E)
    Best for: algorithms that iterate over all edges
    """
    def __init__(self):
        self.edges = []
    
    def add_edge(self, u, v, weight=1):
        self.edges.append((u, v, weight))
    
    def get_edges(self):
        return self.edges

# Example
g = GraphEdgeList()
g.add_edge(0, 1, 4)
g.add_edge(0, 2, 2)
g.add_edge(1, 2, 1)
g.add_edge(2, 3, 5)

print("Edge List:", g.get_edges())
</code></pre>

                        <!-- Graph Traversal -->
                        <h2 id="graph-traversal"><i class="fas fa-route me-2"></i>BFS & DFS Traversal</h2>
                        
                        <h3>Breadth-First Search (BFS)</h3>
                        
<pre><code class="language-python">from collections import deque, defaultdict

def bfs(graph, start):
    """
    Breadth-First Search
    Time: O(V + E), Space: O(V)
    Use for: shortest path in unweighted graphs, level-order traversal
    """
    visited = set([start])
    queue = deque([start])
    result = []
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return result

def bfs_shortest_path(graph, start, end):
    """
    BFS for shortest path in unweighted graph
    Returns path from start to end
    """
    if start == end:
        return [start]
    
    visited = {start}
    queue = deque([(start, [start])])
    
    while queue:
        node, path = queue.popleft()
        
        for neighbor in graph[node]:
            if neighbor == end:
                return path + [neighbor]
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return []  # No path found

# Example
graph = defaultdict(list)
edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4)]
for u, v in edges:
    graph[u].append(v)
    graph[v].append(u)

print("BFS traversal:", bfs(graph, 0))
print("Shortest path 0→4:", bfs_shortest_path(graph, 0, 4))
</code></pre>

                        <h3>Depth-First Search (DFS)</h3>
                        
<pre><code class="language-python">from collections import defaultdict

def dfs_recursive(graph, start, visited=None):
    """
    DFS - Recursive implementation
    Time: O(V + E), Space: O(V) for call stack
    """
    if visited is None:
        visited = set()
    
    visited.add(start)
    result = [start]
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            result.extend(dfs_recursive(graph, neighbor, visited))
    
    return result

def dfs_iterative(graph, start):
    """
    DFS - Iterative implementation using stack
    Time: O(V + E), Space: O(V)
    """
    visited = set()
    stack = [start]
    result = []
    
    while stack:
        node = stack.pop()
        
        if node not in visited:
            visited.add(node)
            result.append(node)
            
            # Add neighbors in reverse order for consistent ordering
            for neighbor in reversed(graph[node]):
                if neighbor not in visited:
                    stack.append(neighbor)
    
    return result

# Example
graph = defaultdict(list)
edges = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5)]
for u, v in edges:
    graph[u].append(v)
    graph[v].append(u)

print("DFS recursive:", dfs_recursive(graph, 0))
print("DFS iterative:", dfs_iterative(graph, 0))
</code></pre>

                        <h3>Number of Islands (Classic Graph Problem)</h3>
                        
<pre><code class="language-python">def num_islands(grid):
    """
    LeetCode 200: Number of Islands
    Time: O(m*n), Space: O(m*n) for recursion
    """
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    count = 0
    
    def dfs(r, c):
        # Boundary check and water/visited check
        if (r < 0 or r >= rows or 
            c < 0 or c >= cols or 
            grid[r][c] != '1'):
            return
        
        # Mark as visited
        grid[r][c] = '#'
        
        # Explore all 4 directions
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                count += 1
                dfs(r, c)
    
    return count

# Example
grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
]

print("Number of islands:", num_islands(grid))  # 3
</code></pre>

                        <!-- Shortest Path -->
                        <h2 id="shortest-path"><i class="fas fa-map-marker-alt me-2"></i>Shortest Path Algorithms</h2>
                        
                        <h3>Dijkstra's Algorithm</h3>
                        
<pre><code class="language-python">import heapq
from collections import defaultdict

def dijkstra(graph, start):
    """
    Dijkstra's Algorithm for shortest paths
    Time: O((V + E) log V), Space: O(V)
    Works for non-negative weights only
    """
    # Distance to all nodes (infinity initially)
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    
    # Priority queue: (distance, node)
    pq = [(0, start)]
    
    # Track visited nodes
    visited = set()
    
    while pq:
        dist, node = heapq.heappop(pq)
        
        if node in visited:
            continue
        
        visited.add(node)
        
        for neighbor, weight in graph[node]:
            if neighbor not in visited:
                new_dist = dist + weight
                
                if new_dist < distances[neighbor]:
                    distances[neighbor] = new_dist
                    heapq.heappush(pq, (new_dist, neighbor))
    
    return distances

# Example: Weighted graph
graph = defaultdict(list)
edges = [
    (0, 1, 4), (0, 2, 1),
    (1, 3, 1),
    (2, 1, 2), (2, 3, 5),
    (3, 4, 3)
]

for u, v, w in edges:
    graph[u].append((v, w))

distances = dijkstra(graph, 0)
print("Shortest distances from 0:")
for node, dist in sorted(distances.items()):
    print(f"  To {node}: {dist}")
</code></pre>

                        <h3>Bellman-Ford Algorithm</h3>
                        
<pre><code class="language-python">def bellman_ford(vertices, edges, start):
    """
    Bellman-Ford Algorithm
    Time: O(V * E), Space: O(V)
    Handles negative weights, detects negative cycles
    """
    # Initialize distances
    distances = {v: float('inf') for v in vertices}
    distances[start] = 0
    
    # Relax edges V-1 times
    for _ in range(len(vertices) - 1):
        for u, v, weight in edges:
            if distances[u] != float('inf'):
                if distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight
    
    # Check for negative cycles
    for u, v, weight in edges:
        if distances[u] != float('inf'):
            if distances[u] + weight < distances[v]:
                return None  # Negative cycle detected
    
    return distances

# Example
vertices = [0, 1, 2, 3, 4]
edges = [
    (0, 1, 4), (0, 2, 1),
    (1, 3, 1),
    (2, 1, 2), (2, 3, 5),
    (3, 4, 3)
]

distances = bellman_ford(vertices, edges, 0)
print("Bellman-Ford distances from 0:")
for node, dist in sorted(distances.items()):
    print(f"  To {node}: {dist}")
</code></pre>

                        <!-- Topological Sort -->
                        <h2 id="topological"><i class="fas fa-sort-amount-down me-2"></i>Topological Sort</h2>
                        
<pre><code class="language-python">from collections import deque, defaultdict

def topological_sort_kahn(num_nodes, edges):
    """
    Kahn's Algorithm (BFS-based)
    Time: O(V + E), Space: O(V)
    Returns topological order or empty list if cycle exists
    """
    # Build graph and compute in-degrees
    graph = defaultdict(list)
    in_degree = [0] * num_nodes
    
    for u, v in edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    # Start with nodes having no prerequisites
    queue = deque([i for i in range(num_nodes) if in_degree[i] == 0])
    result = []
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Check if all nodes are included (no cycle)
    return result if len(result) == num_nodes else []

def topological_sort_dfs(num_nodes, edges):
    """
    DFS-based topological sort
    Time: O(V + E), Space: O(V)
    """
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    
    visited = [0] * num_nodes  # 0: unvisited, 1: visiting, 2: visited
    result = []
    
    def dfs(node):
        if visited[node] == 1:  # Cycle detected
            return False
        if visited[node] == 2:
            return True
        
        visited[node] = 1  # Mark as visiting
        
        for neighbor in graph[node]:
            if not dfs(neighbor):
                return False
        
        visited[node] = 2  # Mark as visited
        result.append(node)
        return True
    
    for i in range(num_nodes):
        if visited[i] == 0:
            if not dfs(i):
                return []  # Cycle detected
    
    return result[::-1]  # Reverse for topological order

# Example: Course Schedule
# 0 -> 1 -> 3
#      |
# 2 ---+
num_courses = 4
prerequisites = [(0, 1), (1, 3), (2, 1)]

print("Topological order (Kahn):", topological_sort_kahn(num_courses, prerequisites))
print("Topological order (DFS):", topological_sort_dfs(num_courses, prerequisites))
</code></pre>

                        <!-- DP Introduction -->
                        <h2 id="dp-intro"><i class="fas fa-brain me-2"></i>Dynamic Programming Introduction</h2>
                        
                        <p><strong>Dynamic Programming (DP)</strong> solves problems by breaking them into overlapping subproblems, storing solutions to avoid recomputation. It's essential for optimization problems.</p>
                        
                        <div class="highlight-box">
                            <h4><i class="fas fa-key me-2"></i>DP Characteristics</h4>
                            <ul>
                                <li><strong>Optimal Substructure:</strong> Optimal solution contains optimal solutions to subproblems</li>
                                <li><strong>Overlapping Subproblems:</strong> Same subproblems solved multiple times</li>
                                <li><strong>Memoization:</strong> Top-down approach with caching</li>
                                <li><strong>Tabulation:</strong> Bottom-up approach building solution iteratively</li>
                            </ul>
                        </div>

                        <h3>Fibonacci - DP Example</h3>
                        
<pre><code class="language-python">def fib_recursive(n):
    """
    Naive recursive - O(2^n) time!
    """
    if n <= 1:
        return n
    return fib_recursive(n-1) + fib_recursive(n-2)

def fib_memoization(n, memo=None):
    """
    Top-down with memoization - O(n) time, O(n) space
    """
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]
    
    if n <= 1:
        return n
    
    memo[n] = fib_memoization(n-1, memo) + fib_memoization(n-2, memo)
    return memo[n]

def fib_tabulation(n):
    """
    Bottom-up tabulation - O(n) time, O(n) space
    """
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

def fib_optimized(n):
    """
    Space-optimized - O(n) time, O(1) space
    """
    if n <= 1:
        return n
    
    prev2, prev1 = 0, 1
    
    for _ in range(2, n + 1):
        curr = prev1 + prev2
        prev2 = prev1
        prev1 = curr
    
    return prev1

# Compare all approaches
n = 30
print(f"Fibonacci({n}):")
print(f"  Memoization: {fib_memoization(n)}")
print(f"  Tabulation: {fib_tabulation(n)}")
print(f"  Optimized: {fib_optimized(n)}")
</code></pre>

                        <!-- DP Patterns -->
                        <h2 id="dp-patterns"><i class="fas fa-puzzle-piece me-2"></i>Common DP Patterns</h2>
                        
                        <h3>1D DP: Climbing Stairs</h3>
                        
<pre><code class="language-python">def climb_stairs(n):
    """
    LeetCode 70: Climbing Stairs
    Ways to reach top climbing 1 or 2 steps at a time
    Time: O(n), Space: O(1)
    """
    if n <= 2:
        return n
    
    prev2, prev1 = 1, 2
    
    for i in range(3, n + 1):
        curr = prev1 + prev2
        prev2 = prev1
        prev1 = curr
    
    return prev1

# Example
for n in [2, 3, 4, 5]:
    print(f"Ways to climb {n} stairs: {climb_stairs(n)}")
</code></pre>

                        <h3>1D DP: House Robber</h3>
                        
<pre><code class="language-python">def house_robber(nums):
    """
    LeetCode 198: House Robber
    Max money robbing non-adjacent houses
    Time: O(n), Space: O(1)
    """
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    # dp[i] = max(rob this house + dp[i-2], skip this house + dp[i-1])
    prev2 = nums[0]
    prev1 = max(nums[0], nums[1])
    
    for i in range(2, len(nums)):
        curr = max(nums[i] + prev2, prev1)
        prev2 = prev1
        prev1 = curr
    
    return prev1

# Example
houses = [2, 7, 9, 3, 1]
print(f"Houses: {houses}")
print(f"Max robbery: {house_robber(houses)}")  # 12 (2 + 9 + 1)
</code></pre>

                        <h3>2D DP: Longest Common Subsequence</h3>
                        
<pre><code class="language-python">def longest_common_subsequence(text1, text2):
    """
    LeetCode 1143: Longest Common Subsequence
    Time: O(m*n), Space: O(m*n)
    """
    m, n = len(text1), len(text2)
    
    # dp[i][j] = LCS of text1[0:i] and text2[0:j]
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

# Example
text1 = "abcde"
text2 = "ace"
print(f"LCS of '{text1}' and '{text2}': {longest_common_subsequence(text1, text2)}")  # 3
</code></pre>

                        <h3>2D DP: Coin Change</h3>
                        
<pre><code class="language-python">def coin_change(coins, amount):
    """
    LeetCode 322: Coin Change
    Minimum coins to make amount
    Time: O(amount * len(coins)), Space: O(amount)
    """
    # dp[i] = minimum coins to make amount i
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1

def coin_change_ways(coins, amount):
    """
    LeetCode 518: Coin Change 2
    Number of ways to make amount
    """
    dp = [0] * (amount + 1)
    dp[0] = 1
    
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    
    return dp[amount]

# Examples
coins = [1, 2, 5]
amount = 11
print(f"Coins: {coins}, Amount: {amount}")
print(f"Min coins: {coin_change(coins, amount)}")  # 3 (5+5+1)
print(f"Number of ways: {coin_change_ways(coins, amount)}")
</code></pre>

                        <h3>Knapsack Problem</h3>
                        
<pre><code class="language-python">def knapsack_01(weights, values, capacity):
    """
    0/1 Knapsack Problem
    Each item can be taken at most once
    Time: O(n * capacity), Space: O(capacity)
    """
    n = len(weights)
    
    # Space-optimized: 1D array
    dp = [0] * (capacity + 1)
    
    for i in range(n):
        # Traverse backwards to avoid using same item twice
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]

def knapsack_unbounded(weights, values, capacity):
    """
    Unbounded Knapsack
    Each item can be taken multiple times
    """
    dp = [0] * (capacity + 1)
    
    for w in range(1, capacity + 1):
        for i in range(len(weights)):
            if weights[i] <= w:
                dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]

# Example
weights = [1, 2, 3, 4]
values = [10, 20, 30, 40]
capacity = 5

print(f"Weights: {weights}")
print(f"Values: {values}")
print(f"Capacity: {capacity}")
print(f"0/1 Knapsack: {knapsack_01(weights, values, capacity)}")  # 50
print(f"Unbounded Knapsack: {knapsack_unbounded(weights, values, capacity)}")  # 50
</code></pre>

                        <!-- Greedy Algorithms -->
                        <h2 id="greedy"><i class="fas fa-star me-2"></i>Greedy Algorithms</h2>
                        
                        <p><strong>Greedy algorithms</strong> make locally optimal choices at each step, hoping to find a global optimum. They work when the problem has the greedy-choice property.</p>
                        
                        <h3>Activity Selection</h3>
                        
<pre><code class="language-python">def activity_selection(activities):
    """
    Select maximum non-overlapping activities
    activities: list of (start, end) tuples
    Time: O(n log n), Space: O(1)
    """
    # Sort by end time
    activities = sorted(activities, key=lambda x: x[1])
    
    selected = [activities[0]]
    last_end = activities[0][1]
    
    for start, end in activities[1:]:
        if start >= last_end:  # Non-overlapping
            selected.append((start, end))
            last_end = end
    
    return selected

# Example
activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)]
result = activity_selection(activities)
print(f"Activities: {len(activities)}")
print(f"Max selected: {len(result)}")
print(f"Selected: {result}")
</code></pre>

                        <h3>Jump Game</h3>
                        
<pre><code class="language-python">def can_jump(nums):
    """
    LeetCode 55: Jump Game
    Can you reach the last index?
    Time: O(n), Space: O(1)
    """
    max_reach = 0
    
    for i, jump in enumerate(nums):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + jump)
    
    return True

def min_jumps(nums):
    """
    LeetCode 45: Jump Game II
    Minimum jumps to reach end
    Time: O(n), Space: O(1)
    """
    if len(nums) <= 1:
        return 0
    
    jumps = 0
    current_end = 0
    farthest = 0
    
    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        
        if i == current_end:
            jumps += 1
            current_end = farthest
            
            if current_end >= len(nums) - 1:
                break
    
    return jumps

# Examples
nums1 = [2, 3, 1, 1, 4]
print(f"Array: {nums1}")
print(f"Can reach end: {can_jump(nums1)}")  # True
print(f"Min jumps: {min_jumps(nums1)}")  # 2

nums2 = [3, 2, 1, 0, 4]
print(f"\nArray: {nums2}")
print(f"Can reach end: {can_jump(nums2)}")  # False
</code></pre>

                        <h3>Interval Scheduling</h3>
                        
<pre><code class="language-python">def erase_overlap_intervals(intervals):
    """
    LeetCode 435: Non-overlapping Intervals
    Minimum intervals to remove for no overlap
    Time: O(n log n), Space: O(1)
    """
    if not intervals:
        return 0
    
    # Sort by end time
    intervals.sort(key=lambda x: x[1])
    
    removals = 0
    prev_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] < prev_end:  # Overlap
            removals += 1
        else:
            prev_end = intervals[i][1]
    
    return removals

def merge_intervals(intervals):
    """
    LeetCode 56: Merge Intervals
    Time: O(n log n), Space: O(n)
    """
    if not intervals:
        return []
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    merged = [intervals[0]]
    
    for start, end in intervals[1:]:
        if start <= merged[-1][1]:  # Overlap
            merged[-1][1] = max(merged[-1][1], end)
        else:
            merged.append([start, end])
    
    return merged

# Examples
intervals1 = [[1, 2], [2, 3], [3, 4], [1, 3]]
print(f"Intervals: {intervals1}")
print(f"Remove to eliminate overlap: {erase_overlap_intervals(intervals1)}")  # 1

intervals2 = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(f"\nIntervals: {intervals2}")
print(f"Merged: {merge_intervals(intervals2)}")  # [[1,6],[8,10],[15,18]]
</code></pre>

                        <!-- Backtracking -->
                        <h2 id="backtracking"><i class="fas fa-undo me-2"></i>Backtracking</h2>
                        
                        <p><strong>Backtracking</strong> is a systematic way to explore all possible solutions by building candidates incrementally and abandoning ("backtracking") candidates that fail to satisfy constraints.</p>
                        
                        <div class="highlight-box">
                            <h4><i class="fas fa-code me-2"></i>Backtracking Template</h4>
                            <pre><code>def backtrack(candidate):
    if is_solution(candidate):
        output(candidate)
        return
    
    for choice in choices:
        if is_valid(choice):
            make_choice(choice)
            backtrack(candidate)
            undo_choice(choice)  # Backtrack</code></pre>
                        </div>

                        <h3>Permutations</h3>
                        
<pre><code class="language-python">def permute(nums):
    """
    LeetCode 46: Permutations
    Generate all permutations
    Time: O(n! * n), Space: O(n)
    """
    result = []
    
    def backtrack(current, remaining):
        if not remaining:
            result.append(current[:])
            return
        
        for i in range(len(remaining)):
            # Make choice
            current.append(remaining[i])
            
            # Recurse with remaining elements
            backtrack(current, remaining[:i] + remaining[i+1:])
            
            # Undo choice
            current.pop()
    
    backtrack([], nums)
    return result

# Example
nums = [1, 2, 3]
print(f"Permutations of {nums}:")
for perm in permute(nums):
    print(f"  {perm}")
</code></pre>

                        <h3>Subsets</h3>
                        
<pre><code class="language-python">def subsets(nums):
    """
    LeetCode 78: Subsets
    Generate all subsets (power set)
    Time: O(2^n * n), Space: O(n)
    """
    result = []
    
    def backtrack(start, current):
        result.append(current[:])
        
        for i in range(start, len(nums)):
            current.append(nums[i])
            backtrack(i + 1, current)
            current.pop()
    
    backtrack(0, [])
    return result

def subsets_with_dup(nums):
    """
    LeetCode 90: Subsets II (with duplicates)
    """
    result = []
    nums.sort()
    
    def backtrack(start, current):
        result.append(current[:])
        
        for i in range(start, len(nums)):
            # Skip duplicates
            if i > start and nums[i] == nums[i-1]:
                continue
            current.append(nums[i])
            backtrack(i + 1, current)
            current.pop()
    
    backtrack(0, [])
    return result

# Example
nums = [1, 2, 3]
print(f"Subsets of {nums}:")
for subset in subsets(nums):
    print(f"  {subset}")
</code></pre>

                        <h3>Combination Sum</h3>
                        
<pre><code class="language-python">def combination_sum(candidates, target):
    """
    LeetCode 39: Combination Sum
    Find combinations that sum to target (can reuse)
    Time: O(2^target), Space: O(target)
    """
    result = []
    
    def backtrack(start, current, remaining):
        if remaining == 0:
            result.append(current[:])
            return
        
        if remaining < 0:
            return
        
        for i in range(start, len(candidates)):
            current.append(candidates[i])
            # Can reuse same element, so pass i (not i+1)
            backtrack(i, current, remaining - candidates[i])
            current.pop()
    
    backtrack(0, [], target)
    return result

# Example
candidates = [2, 3, 6, 7]
target = 7
print(f"Candidates: {candidates}, Target: {target}")
print(f"Combinations:")
for combo in combination_sum(candidates, target):
    print(f"  {combo}")
</code></pre>

                        <h3>N-Queens</h3>
                        
<pre><code class="language-python">def solve_n_queens(n):
    """
    LeetCode 51: N-Queens
    Place n queens on n×n board with no attacks
    Time: O(n!), Space: O(n)
    """
    result = []
    board = [['.'] * n for _ in range(n)]
    
    # Track columns and diagonals under attack
    cols = set()
    diag1 = set()  # row - col
    diag2 = set()  # row + col
    
    def backtrack(row):
        if row == n:
            result.append([''.join(row) for row in board])
            return
        
        for col in range(n):
            if col in cols or (row - col) in diag1 or (row + col) in diag2:
                continue
            
            # Place queen
            board[row][col] = 'Q'
            cols.add(col)
            diag1.add(row - col)
            diag2.add(row + col)
            
            backtrack(row + 1)
            
            # Remove queen
            board[row][col] = '.'
            cols.remove(col)
            diag1.remove(row - col)
            diag2.remove(row + col)
    
    backtrack(0)
    return result

# Example
n = 4
solutions = solve_n_queens(n)
print(f"{n}-Queens has {len(solutions)} solutions:")
for i, sol in enumerate(solutions):
    print(f"\nSolution {i+1}:")
    for row in sol:
        print(f"  {row}")
</code></pre>

                        <!-- LeetCode Problems -->
                        <h2 id="leetcode"><i class="fas fa-code me-2"></i>LeetCode Practice Problems</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-tasks me-2"></i>Essential Problems</h4>
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>#</th>
                                        <th>Problem</th>
                                        <th>Difficulty</th>
                                        <th>Key Concept</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>200</td>
                                        <td>Number of Islands</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Graph DFS/BFS</td>
                                    </tr>
                                    <tr>
                                        <td>207</td>
                                        <td>Course Schedule</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Topological Sort</td>
                                    </tr>
                                    <tr>
                                        <td>743</td>
                                        <td>Network Delay Time</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Dijkstra</td>
                                    </tr>
                                    <tr>
                                        <td>70</td>
                                        <td>Climbing Stairs</td>
                                        <td><span class="badge badge-easy">Easy</span></td>
                                        <td>1D DP</td>
                                    </tr>
                                    <tr>
                                        <td>198</td>
                                        <td>House Robber</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>1D DP</td>
                                    </tr>
                                    <tr>
                                        <td>322</td>
                                        <td>Coin Change</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>DP - Unbounded Knapsack</td>
                                    </tr>
                                    <tr>
                                        <td>1143</td>
                                        <td>Longest Common Subsequence</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>2D DP</td>
                                    </tr>
                                    <tr>
                                        <td>55</td>
                                        <td>Jump Game</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Greedy</td>
                                    </tr>
                                    <tr>
                                        <td>46</td>
                                        <td>Permutations</td>
                                        <td><span class="badge badge-medium">Medium</span></td>
                                        <td>Backtracking</td>
                                    </tr>
                                    <tr>
                                        <td>51</td>
                                        <td>N-Queens</td>
                                        <td><span class="badge badge-hard">Hard</span></td>
                                        <td>Backtracking</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Series Navigation -->
                        <h2 id="series-nav"><i class="fas fa-book me-2"></i>Complete DSA Series</h2>
                        
                        <div class="experiment-card">
                            <h4><i class="fas fa-graduation-cap me-2"></i>FAANG Interview Preparation - Series Complete! 🎉</h4>
                            <div class="row">
                                <div class="col-md-6">
                                    <ol>
                                        <li><a href="dsa-foundations-memory-complexity.html">Foundations & Complexity</a></li>
                                        <li><a href="dsa-recursion-complete-guide.html">Recursion Deep Dive</a></li>
                                        <li><a href="dsa-arrays-adt-operations.html">Arrays & ADT</a></li>
                                        <li><a href="dsa-strings-manipulation.html">Strings & Manipulation</a></li>
                                        <li><a href="dsa-matrices-special-sparse.html">Matrices & Sparse</a></li>
                                        <li><a href="dsa-linked-lists-guide.html">Linked Lists</a></li>
                                    </ol>
                                </div>
                                <div class="col-md-6">
                                    <ol start="7">
                                        <li><a href="dsa-stack-applications.html">Stack & Applications</a></li>
                                        <li><a href="dsa-queue-implementations.html">Queue & Variants</a></li>
                                        <li><a href="dsa-trees-fundamentals.html">Trees & Traversals</a></li>
                                        <li><a href="dsa-bst-avl-redblack.html">BST & Balanced Trees</a></li>
                                        <li><a href="dsa-heaps-sorting-hashing.html">Heaps, Sorting & Hashing</a></li>
                                        <li><strong>Graphs, DP, Greedy & Backtracking (You are here)</strong></li>
                                    </ol>
                                </div>
                            </div>
                            <div class="alert alert-success mt-3">
                                <i class="fas fa-check-circle me-2"></i><strong>Congratulations!</strong> You've completed the entire 12-part DSA series. Practice these concepts consistently on LeetCode, and you'll be well-prepared for FAANG interviews!
                            </div>
                        </div>

                        <!-- Related Posts -->
                        <div class="related-posts mt-5">
                            <h3><i class="fas fa-link me-2"></i>Related Articles</h3>
                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <div class="card h-100">
                                        <div class="card-body">
                                            <h5 class="card-title">Part 11: Heaps, Sorting & Hashing</h5>
                                            <p class="card-text">Priority queues, sorting algorithms, and hash table implementations.</p>
                                            <a href="dsa-heaps-sorting-hashing.html" class="btn btn-outline-primary btn-sm">Read Article</a>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6 mb-3">
                                    <div class="card h-100">
                                        <div class="card-body">
                                            <h5 class="card-title">Part 1: DSA Foundations</h5>
                                            <p class="card-text">Start from the beginning with memory, complexity analysis, and Big O.</p>
                                            <a href="dsa-foundations-memory-complexity.html" class="btn btn-outline-primary btn-sm">Read Article</a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="bg-dark text-light py-4">
        <div class="container">
            <div class="row">
                <div class="col-md-6">
                    <p>&copy; 2026 Wasil Zafar. All rights reserved.</p>
                </div>
                <div class="col-md-6 text-md-end">
                    <a href="https://linkedin.com/in/wasilzafar" class="text-light me-3" target="_blank"><i class="fab fa-linkedin fa-lg"></i></a>
                    <a href="https://github.com/wasilzafar" class="text-light me-3" target="_blank"><i class="fab fa-github fa-lg"></i></a>
                    <a href="mailto:contact@wasilzafar.com" class="text-light"><i class="fas fa-envelope fa-lg"></i></a>
                </div>
            </div>
        </div>
    </footer>

    <!-- Scroll to Top Button -->
    <button id="scrollToTop" class="scroll-to-top" title="Back to Top">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Cookie Consent -->
    <script src="../../../js/cookie-consent.js"></script>
    
    <!-- Main JS -->
    <script src="../../../js/main.js"></script>
    
    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    
    <!-- Custom Scripts -->
    <script>
        // Scroll to Top
        document.addEventListener('DOMContentLoaded', function() {
            const scrollBtn = document.getElementById('scrollToTop');
            
            window.addEventListener('scroll', function() {
                if (window.scrollY > 300) {
                    scrollBtn.classList.add('show');
                } else {
                    scrollBtn.classList.remove('show');
                }
            });
            
            scrollBtn.addEventListener('click', function() {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });
        
        // TOC Navigation
        function openNav() {
            document.getElementById('tocSidenav').classList.add('open');
            document.getElementById('tocOverlay').classList.add('show');
            document.body.style.overflow = 'hidden';
        }
        
        function closeNav() {
            document.getElementById('tocSidenav').classList.remove('open');
            document.getElementById('tocOverlay').classList.remove('show');
            document.body.style.overflow = 'auto';
        }
        
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeNav();
        });
        
        // Active section highlighting
        document.addEventListener('DOMContentLoaded', function() {
            const sections = document.querySelectorAll('[id]');
            const tocLinks = document.querySelectorAll('.sidenav-toc a');
            
            function highlightActive() {
                let current = '';
                sections.forEach(section => {
                    if (window.scrollY >= section.offsetTop - 200) {
                        current = section.getAttribute('id');
                    }
                });
                
                tocLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === '#' + current) {
                        link.classList.add('active');
                    }
                });
            }
            
            window.addEventListener('scroll', highlightActive);
            highlightActive();
        });
        
        // Prism Theme Switcher
        const themes = {
            'prism-theme': 'Tomorrow Night',
            'prism-default': 'Default',
            'prism-dark': 'Dark',
            'prism-twilight': 'Twilight',
            'prism-okaidia': 'Okaidia',
            'prism-solarizedlight': 'Solarized Light'
        };
        
        const savedTheme = localStorage.getItem('prism-theme') || 'prism-theme';
        
        function switchTheme(themeId) {
            Object.keys(themes).forEach(id => {
                const link = document.getElementById(id);
                if (link) link.disabled = true;
            });
            
            const selectedLink = document.getElementById(themeId);
            if (selectedLink) {
                selectedLink.disabled = false;
                localStorage.setItem('prism-theme', themeId);
            }
            
            document.querySelectorAll('select.prism-theme-selector').forEach(dropdown => {
                dropdown.value = themeId;
            });
            
            setTimeout(() => Prism.highlightAll(), 10);
        }
        
        document.addEventListener('DOMContentLoaded', () => switchTheme(savedTheme));
        
        Prism.plugins.toolbar.registerButton('theme-switcher', function(env) {
            const select = document.createElement('select');
            select.className = 'prism-theme-selector';
            select.setAttribute('aria-label', 'Select code theme');
            
            Object.keys(themes).forEach(themeId => {
                const option = document.createElement('option');
                option.value = themeId;
                option.textContent = themes[themeId];
                if (themeId === savedTheme) option.selected = true;
                select.appendChild(option);
            });
            
            select.addEventListener('change', e => switchTheme(e.target.value));
            return select;
        });
    </script>
</body>
</html>
